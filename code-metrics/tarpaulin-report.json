{"files":[{"path":["/","Users","magnusmanske","rust","wikibase_rest_api","examples","Q42.rs"],"content":"use wikibase_rest_api::prelude::*;\n\n#[cfg(not(tarpaulin_include))]\n#[tokio::main]\nasync fn main() -> Result<(), RestApiError> {\n    // #lizard forgives the complexity\n\n    // Use the Wikidata API\n    let api = RestApi::wikidata()?;\n\n    // Use Q42 as an example item\n    let id_q42 = EntityId::new(\"Q42\")?;\n\n    // Get the label and sitelink of Q42\n    let q42_label_en = Label::get(&id_q42, \"en\", &api).await?.value().to_owned();\n    let q42_sitelink = Sitelink::get(&id_q42, \"enwiki\", &api)\n        .await?\n        .title()\n        .to_owned();\n    println!(\"Q42 '{q42_label_en}' => [[enwiki:{q42_sitelink}]]\");\n\n    // Get the statements of Q42\n    let statements = Statements::get(&id_q42, &api).await?;\n    for statement in statements.property(\"P31\") {\n        if let StatementValue::Value(StatementValueContent::String(id)) = statement.value() {\n            let label = Label::get(&EntityId::Item(id.to_owned()), \"en\", &api)\n                .await?\n                .value()\n                .to_owned();\n            println!(\"{q42_label_en} ([[Q42]]) is a {label} ([[{id}]])\");\n        }\n    }\n\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","magnusmanske","rust","wikibase_rest_api","examples","container.rs"],"content":"use std::sync::Arc;\nuse wikibase_rest_api::prelude::*;\n\n#[cfg(not(tarpaulin_include))]\n#[tokio::main]\nasync fn main() -> Result<(), RestApiError> {\n    // #lizard forgives the complexity\n    let api = RestApi::builder(\"https://www.wikidata.org/w/rest.php\")?.build();\n    let api = Arc::new(api);\n\n    // Load several items at once\n    // Try to load some items, and a property; Q6, Q7, and Q9 do not exist though.\n    // They will be silently ignored.\n    let entity_ids = [\n        \"Q42\", \"Q1\", \"Q2\", \"Q3\", \"Q4\", \"Q5\", \"Q6\", \"Q7\", \"Q8\", \"Q9\", \"P214\",\n    ]\n    .iter()\n    .map(|id| EntityId::new(*id))\n    .collect::<Result<Vec<_>, RestApiError>>()?;\n\n    let entity_container = EntityContainer::builder()\n        .api(api)\n        .max_concurrent(5)\n        .build()?;\n    println!(\"Trying to load {} items&properties\", entity_ids.len());\n    entity_container.load(&entity_ids).await?;\n    println!(\n        \"Loaded {} items\",\n        entity_container.items().read().await.len()\n    );\n    println!(\n        \"Loaded {} properties\",\n        entity_container.properties().read().await.len()\n    );\n    println!(\n        \"Items loaded: {:?}\",\n        entity_container.items().read().await.keys()\n    );\n    println!(\n        \"Properties loaded: {:?}\",\n        entity_container.properties().read().await.keys()\n    );\n\n    // Access item info from the container\n    let q42 = entity_container\n        .items()\n        .read()\n        .await\n        .get(\"Q42\")\n        .ok_or_else(|| RestApiError::IsNone)?\n        .to_owned();\n    let q42_label_en = q42\n        .labels()\n        .get_lang(\"en\")\n        .ok_or_else(|| RestApiError::IsNone)?;\n    println!(\"Container item Q42 label is '{q42_label_en}'\");\n\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","magnusmanske","rust","wikibase_rest_api","examples","create_item.rs"],"content":"use wikibase_rest_api::prelude::*;\n\n#[cfg(not(tarpaulin_include))]\n#[tokio::main]\nasync fn main() -> Result<(), RestApiError> {\n    // #lizard forgives the complexity\n    // let token = \"MY_ACCESS_TOKEN\";\n    let api = RestApi::builder(\"https://test.wikidata.org/w/rest.php\")?\n        // .with_access_token(token)\n        .build();\n    let mut item = Item::default();\n    item.labels_mut()\n        .insert(LanguageString::new(\"en\", \"My label\"));\n    item.descriptions_mut()\n        .insert(LanguageString::new(\"en\", \"My description123\"));\n    item.statements_mut()\n        .insert(Statement::new_string(\"P31\", \"Q13406268\"));\n    let item = item.post(&api).await?;\n    println!(\n        \"Created new item https://test.wikidata.org/wiki/{}\",\n        item.id()\n    );\n\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","magnusmanske","rust","wikibase_rest_api","src","aliases.rs"],"content":"use crate::{\n    aliases_patch::AliasesPatch, prelude::LanguageStrings, EntityId, FromJson, HeaderInfo,\n    LanguageString, RestApi, RestApiError, RevisionMatch,\n};\nuse derivative::Derivative;\nuse reqwest::StatusCode;\nuse serde::ser::{Serialize, SerializeMap};\nuse serde_json::{json, Value};\nuse std::collections::HashMap;\n\n#[derive(Derivative, Debug, Clone, Default)]\n#[derivative(PartialEq)]\npub struct Aliases {\n    ls: HashMap<String, Vec<String>>,\n    #[derivative(PartialEq = \"ignore\")]\n    header_info: HeaderInfo,\n}\n\nimpl Aliases {\n    /// Creates a new `Aliases` struct for the given entity ID.\n    /// If the API cannot find anything, the `Aliases` struct will be empty.\n    pub async fn get_match(\n        id: &EntityId,\n        api: &RestApi,\n        rm: RevisionMatch,\n    ) -> Result<Self, RestApiError> {\n        let response = Self::get_match_response(id, api, rm).await?;\n\n        let header_info = HeaderInfo::from_header(response.headers());\n        let ls = Self::get_match_check_response(response).await?;\n        Ok(Self { ls, header_info })\n    }\n\n    /// Creates a new `Aliases` struct for the given entity ID.\n    /// If the API cannot find anything, the `Aliases` struct will be empty.\n    pub async fn get(id: &EntityId, api: &RestApi) -> Result<Self, RestApiError> {\n        Self::get_match(id, api, RevisionMatch::default()).await\n    }\n\n    /// Returns the list of values for a language\n    pub fn get_lang<S: Into<String>>(&self, language: S) -> Vec<&str> {\n        self.ls\n            .get(&language.into())\n            .map_or_else(Vec::new, |v| v.iter().map(|s| s.as_str()).collect())\n    }\n\n    /// Returns the list of values for a language, mutable\n    pub fn get_lang_mut<S: Into<String>>(&mut self, language: S) -> &mut Vec<String> {\n        self.ls.entry(language.into()).or_default()\n    }\n\n    /// Generates a patch to transform `other` into `self`\n    pub fn patch(&self, other: &Self) -> Result<AliasesPatch, RestApiError> {\n        let patch = json_patch::diff(&json!(&other), &json!(&self));\n        let patch = AliasesPatch::from_json(&json!(patch))?;\n        Ok(patch)\n    }\n\n    /// Returns the number of languages\n    pub fn len(&self) -> usize {\n        self.ls.len()\n    }\n\n    /// Returns true if there are no language strings\n    pub fn is_empty(&self) -> bool {\n        self.ls.is_empty()\n    }\n\n    fn from_json_header_info_part(\n        language: &str,\n        values: &[Value],\n    ) -> Result<(String, Vec<String>), RestApiError> {\n        let values = values\n            .iter()\n            .map(|v| {\n                Ok(v.as_str()\n                    .ok_or_else(|| RestApiError::MissingOrInvalidField {\n                        field: \"LanguageStringsMultiple\".into(),\n                        j: v.to_owned(),\n                    })?\n                    .to_string())\n            })\n            .collect::<Result<Vec<String>, RestApiError>>()?;\n        Ok((language.to_owned(), values))\n    }\n\n    async fn get_match_response(\n        id: &EntityId,\n        api: &RestApi,\n        rm: RevisionMatch,\n    ) -> Result<reqwest::Response, RestApiError> {\n        let path = format!(\"/entities/{group}/{id}/aliases\", group = id.group()?);\n        let mut request = api\n            .wikibase_request_builder(&path, HashMap::new(), reqwest::Method::GET)\n            .await?\n            .build()?;\n        rm.modify_headers(request.headers_mut())?;\n        let response = api.execute(request).await?;\n        Ok(response)\n    }\n\n    async fn get_match_check_response(\n        response: reqwest::Response,\n    ) -> Result<HashMap<String, Vec<String>>, RestApiError> {\n        let ls: HashMap<String, Vec<String>> = match response.error_for_status() {\n            Ok(response) => response.json().await?,\n            Err(e) => {\n                if e.status() == Some(StatusCode::NOT_FOUND) {\n                    HashMap::new()\n                } else {\n                    return Err(e.into());\n                }\n            }\n        };\n        Ok(ls)\n    }\n}\n\nimpl FromJson for Aliases {\n    fn header_info(&self) -> &HeaderInfo {\n        &self.header_info\n    }\n\n    fn from_json_header_info(j: &Value, header_info: HeaderInfo) -> Result<Self, RestApiError> {\n        let ls = j\n            .as_object()\n            .ok_or_else(|| RestApiError::MissingOrInvalidField {\n                field: \"LanguageStringsMultiple\".into(),\n                j: j.to_owned(),\n            })?\n            .iter()\n            .map(|(language, value)| {\n                value.as_array().map_or_else(\n                    || {\n                        Err(RestApiError::MissingOrInvalidField {\n                            field: \"LanguageStringsMultiple\".into(),\n                            j: value.to_owned(),\n                        })\n                    },\n                    |v| Self::from_json_header_info_part(language, v),\n                )\n            })\n            .collect::<Result<HashMap<String, Vec<String>>, RestApiError>>()?;\n        let ret = Self { ls, header_info };\n        Ok(ret)\n    }\n}\n\nimpl LanguageStrings for Aliases {\n    fn has_language<S: Into<String>>(&self, language: S) -> bool {\n        self.ls.contains_key(&language.into())\n    }\n\n    fn insert(&mut self, ls: LanguageString) {\n        let entry = self.ls.entry(ls.language().to_string()).or_default();\n        if !entry.contains(ls.value()) {\n            entry.push(ls.value().to_owned());\n        }\n    }\n}\n\nimpl Serialize for Aliases {\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: serde::Serializer,\n    {\n        let mut s = serializer.serialize_map(Some(self.ls.len()))?;\n        for (language, values) in &self.ls {\n            s.serialize_entry(language, &values)?;\n        }\n        s.end()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use serde_json::json;\n    use wiremock::matchers::{method, path};\n    use wiremock::{Mock, MockServer, ResponseTemplate};\n\n    #[tokio::test]\n    #[cfg_attr(miri, ignore)]\n    async fn test_aliases_get() {\n        let v = std::fs::read_to_string(\"test_data/Q42.json\").unwrap();\n        let v: Value = serde_json::from_str(&v).unwrap();\n        let id = v[\"id\"].as_str().unwrap();\n        let v: Value = v[\"aliases\"].clone();\n\n        let mock_path = format!(\"/w/rest.php/wikibase/v1/entities/items/{id}/aliases\");\n        let mock_server = MockServer::start().await;\n        Mock::given(method(\"GET\"))\n            .and(path(&mock_path))\n            .respond_with(ResponseTemplate::new(200).set_body_json(&v))\n            .mount(&mock_server)\n            .await;\n        let api = RestApi::builder(&(mock_server.uri() + \"/w/rest.php\"))\n            .unwrap()\n            .build();\n\n        let sitelinks = Aliases::get(&EntityId::item(\"Q42\"), &api).await.unwrap();\n        assert_eq!(sitelinks.ls.len(), 64);\n        assert_eq!(sitelinks.get_lang(\"tok\")[0], \"jan Takala Atan\");\n    }\n\n    #[test]\n    fn test_aliases() {\n        let j = json!({\n            \"en\": [\"Hello\", \"Hi\"],\n            \"de\": [\"Hallo\", \"Hi\"],\n        });\n        let ls = Aliases::from_json(&j).unwrap();\n        assert_eq!(ls.get_lang(\"en\"), vec![\"Hello\", \"Hi\"]);\n        assert_eq!(ls.get_lang(\"de\"), vec![\"Hallo\", \"Hi\"]);\n        assert!(ls.get_lang(\"fr\").is_empty());\n    }\n\n    #[test]\n    fn test_aliases_insert() {\n        let mut ls = Aliases::default();\n        ls.insert(LanguageString::new(\"en\", \"Hello\"));\n        ls.insert(LanguageString::new(\"de\", \"Hallo\"));\n        ls.insert(LanguageString::new(\"en\", \"Hi\"));\n        assert_eq!(ls.get_lang(\"en\"), vec![\"Hello\", \"Hi\"]);\n        assert_eq!(ls.get_lang(\"de\"), vec![\"Hallo\"]);\n    }\n\n    #[test]\n    fn test_patch_aliases() {\n        let mut l1 = Aliases::default();\n        l1.insert(LanguageString::new(\"en\", \"Foo\"));\n        l1.insert(LanguageString::new(\"en\", \"Bar\"));\n        l1.insert(LanguageString::new(\"en\", \"Baz\"));\n        l1.insert(LanguageString::new(\"de\", \"Foobar\"));\n        let mut l2 = l1.clone();\n        l2.get_lang_mut(\"en\")[2] = \"Boo\".to_string();\n        l2.get_lang_mut(\"en\").remove(1);\n        l2.insert(LanguageString::new(\"de\", \"Foobaz\"));\n\n        let patch = l2.patch(&l1).unwrap();\n        let patch_json = json!(patch);\n        assert_eq!(\n            patch_json,\n            json!({\"patch\":[{\"op\":\"add\",\"path\":\"/de/1\",\"value\":\"Foobaz\"},{\"op\":\"replace\",\"path\":\"/en/1\",\"value\":\"Boo\"},{\"op\":\"remove\",\"path\":\"/en/2\"}]})\n        );\n    }\n\n    #[test]\n    fn test_header_info_multiple() {\n        let l = Aliases::default();\n        assert_eq!(l.header_info(), &HeaderInfo::default());\n    }\n\n    #[test]\n    fn test_serialize2() {\n        let mut l = Aliases::default();\n        l.insert(LanguageString::new(\"en\", \"Foo\"));\n        l.insert(LanguageString::new(\"en\", \"Bar\"));\n        l.insert(LanguageString::new(\"de\", \"Baz\"));\n        let s = serde_json::to_string(&l).unwrap();\n        assert!(s.contains(r#\"\"en\":[\"Foo\",\"Bar\"]\"#));\n        assert!(s.contains(r#\"\"de\":[\"Baz\"]\"#));\n    }\n\n    #[test]\n    fn test_is_empty() {\n        let mut l = Aliases::default();\n        assert!(l.is_empty());\n        l.insert(LanguageString::new(\"en\", \"Foo\"));\n        assert!(!l.is_empty());\n    }\n}\n","traces":[{"line":22,"address":[],"length":0,"stats":{"Line":1}},{"line":27,"address":[],"length":0,"stats":{"Line":2}},{"line":30,"address":[],"length":0,"stats":{"Line":1}},{"line":36,"address":[],"length":0,"stats":{"Line":2}},{"line":37,"address":[],"length":0,"stats":{"Line":1}},{"line":41,"address":[],"length":0,"stats":{"Line":11}},{"line":42,"address":[],"length":0,"stats":{"Line":11}},{"line":43,"address":[],"length":0,"stats":{"Line":11}},{"line":44,"address":[],"length":0,"stats":{"Line":57}},{"line":48,"address":[],"length":0,"stats":{"Line":2}},{"line":49,"address":[],"length":0,"stats":{"Line":2}},{"line":53,"address":[],"length":0,"stats":{"Line":2}},{"line":54,"address":[],"length":0,"stats":{"Line":2}},{"line":55,"address":[],"length":0,"stats":{"Line":4}},{"line":60,"address":[],"length":0,"stats":{"Line":4}},{"line":61,"address":[],"length":0,"stats":{"Line":4}},{"line":65,"address":[],"length":0,"stats":{"Line":18}},{"line":66,"address":[],"length":0,"stats":{"Line":18}},{"line":69,"address":[],"length":0,"stats":{"Line":1246}},{"line":73,"address":[],"length":0,"stats":{"Line":2492}},{"line":75,"address":[],"length":0,"stats":{"Line":3383}},{"line":76,"address":[],"length":0,"stats":{"Line":2137}},{"line":77,"address":[],"length":0,"stats":{"Line":2137}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":2137}},{"line":87,"address":[],"length":0,"stats":{"Line":1}},{"line":92,"address":[],"length":0,"stats":{"Line":2}},{"line":93,"address":[],"length":0,"stats":{"Line":1}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":2}},{"line":102,"address":[],"length":0,"stats":{"Line":1}},{"line":105,"address":[],"length":0,"stats":{"Line":2}},{"line":106,"address":[],"length":0,"stats":{"Line":1}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":1}},{"line":121,"address":[],"length":0,"stats":{"Line":1}},{"line":124,"address":[],"length":0,"stats":{"Line":17}},{"line":125,"address":[],"length":0,"stats":{"Line":34}},{"line":127,"address":[],"length":0,"stats":{"Line":17}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":1263}},{"line":133,"address":[],"length":0,"stats":{"Line":1246}},{"line":134,"address":[],"length":0,"stats":{"Line":1246}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":3738}},{"line":150,"address":[],"length":0,"stats":{"Line":1}},{"line":151,"address":[],"length":0,"stats":{"Line":1}},{"line":154,"address":[],"length":0,"stats":{"Line":17}},{"line":155,"address":[],"length":0,"stats":{"Line":17}},{"line":156,"address":[],"length":0,"stats":{"Line":34}},{"line":157,"address":[],"length":0,"stats":{"Line":17}},{"line":163,"address":[],"length":0,"stats":{"Line":12}},{"line":167,"address":[],"length":0,"stats":{"Line":24}},{"line":168,"address":[],"length":0,"stats":{"Line":1160}},{"line":169,"address":[],"length":0,"stats":{"Line":574}},{"line":171,"address":[],"length":0,"stats":{"Line":12}}],"covered":51,"coverable":64},{"path":["/","Users","magnusmanske","rust","wikibase_rest_api","src","aliases_in_language.rs"],"content":"use crate::{\n    EditMetadata, EntityId, HeaderInfo, HttpGet, HttpMisc, RestApi, RestApiError, RevisionMatch,\n};\nuse async_trait::async_trait;\nuse derivative::Derivative;\nuse reqwest::{Response, StatusCode};\nuse serde_json::{json, Value};\nuse std::collections::HashMap;\n\n/// A group of aliases in a specific language.\n#[derive(Derivative, Debug, Clone)]\n#[derivative(PartialEq)]\npub struct AliasesInLanguage {\n    language: String,\n    values: Vec<String>,\n    #[derivative(PartialEq = \"ignore\")]\n    header_info: HeaderInfo,\n}\n\nimpl AliasesInLanguage {\n    /// Constructs a new `Aliases` object from a language code and a list of aliases.\n    pub fn new<S: Into<String>>(language: S, values: Vec<String>) -> Self {\n        Self {\n            language: language.into(),\n            values,\n            header_info: HeaderInfo::default(),\n        }\n    }\n\n    /// Constructs a new `Aliases` object from a language code and a JSON array of (string) aliases.\n    pub fn from_json<S: Into<String>>(language: S, j: &Value) -> Result<Self, RestApiError> {\n        Self::from_json_header_info(language, j, HeaderInfo::default())\n    }\n\n    /// Constructs a new `Aliases` object from a language code and a JSON array of (string) aliases.\n    pub fn from_json_header_info<S: Into<String>>(\n        language: S,\n        j: &Value,\n        header_info: HeaderInfo,\n    ) -> Result<Self, RestApiError> {\n        let language = language.into();\n        if language.trim().is_empty() {\n            return Err(RestApiError::EmptyValue(\"Language\".into()));\n        }\n        let aliases = j\n            .as_array()\n            .ok_or_else(|| RestApiError::MissingOrInvalidField {\n                field: \"Aliases\".into(),\n                j: j.to_owned(),\n            })?\n            .iter()\n            .map(|v| {\n                Ok(v.as_str()\n                    .ok_or_else(|| RestApiError::MissingOrInvalidField {\n                        field: \"Aliases\".into(),\n                        j: v.to_owned(),\n                    })?\n                    .to_string())\n            })\n            .collect::<Result<Vec<String>, RestApiError>>()?;\n        Ok(Self {\n            language,\n            values: aliases,\n            header_info,\n        })\n    }\n\n    /// Adds an alias to the list of aliases (only if it is not already present).\n    pub fn push(&mut self, alias: String) {\n        if !self.values.contains(&alias) {\n            self.values.push(alias);\n        }\n    }\n\n    /// Returns the list of aliases.\n    pub const fn values(&self) -> &Vec<String> {\n        &self.values\n    }\n\n    /// Returns the number of aliases.\n    pub fn len(&self) -> usize {\n        self.values.len()\n    }\n\n    /// Returns true if the list of aliases is empty.\n    pub fn is_empty(&self) -> bool {\n        self.values.is_empty()\n    }\n\n    /// Returns the language code of the aliases.\n    pub fn language(&self) -> &str {\n        &self.language\n    }\n\n    /// Adds one or more aliases to the list of aliases.\n    pub async fn post(&self, id: &EntityId, api: &mut RestApi) -> Result<Self, RestApiError> {\n        self.post_meta(id, api, EditMetadata::default()).await\n    }\n\n    /// Adds one or more aliases to the list of aliases, using conditions and edit metadata.\n    pub async fn post_meta(\n        &self,\n        id: &EntityId,\n        api: &mut RestApi,\n        em: EditMetadata,\n    ) -> Result<Self, RestApiError> {\n        let j = json!({\"aliases\": self.values});\n        let (j, header_info) = self\n            .run_json_query(id, reqwest::Method::POST, j, api, &em)\n            .await?;\n        Self::from_json_header_info(&self.language, &j, header_info)\n    }\n\n    /// Returns the header information of the last HTTP response (revision ID, last modified).\n    pub const fn header_info(&self) -> &HeaderInfo {\n        &self.header_info\n    }\n\n    async fn check_get_match_response(\n        language: &str,\n        response: Response,\n    ) -> Result<Self, RestApiError> {\n        let header_info = HeaderInfo::from_header(response.headers());\n        let j: Value = match response.error_for_status() {\n            Ok(response) => response.json().await?,\n            Err(e) => {\n                if e.status() == Some(StatusCode::NOT_FOUND) {\n                    json!([])\n                } else {\n                    return Err(e.into());\n                }\n            }\n        };\n        Self::from_json_header_info(language, &j, header_info)\n    }\n}\n\nimpl HttpMisc for AliasesInLanguage {\n    fn get_my_rest_api_path(&self, id: &EntityId) -> Result<String, RestApiError> {\n        Ok(format!(\n            \"/entities/{group}/{id}/aliases/{language}\",\n            group = id.group()?,\n            language = self.language\n        ))\n    }\n}\n\n#[async_trait]\nimpl HttpGet for AliasesInLanguage {\n    async fn get_match(\n        id: &EntityId,\n        language: &str,\n        api: &RestApi,\n        rm: RevisionMatch,\n    ) -> Result<Self, RestApiError> {\n        let path = format!(\n            \"/entities/{group}/{id}/aliases/{language}\",\n            group = id.group()?\n        );\n        let mut request = api\n            .wikibase_request_builder(&path, HashMap::new(), reqwest::Method::GET)\n            .await?\n            .build()?;\n        rm.modify_headers(request.headers_mut())?;\n        let response = api.execute(request).await?;\n        Self::check_get_match_response(language, response).await\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use wiremock::matchers::{bearer_token, body_partial_json, method, path};\n    use wiremock::{Mock, MockServer, ResponseTemplate};\n\n    #[tokio::test]\n    #[cfg_attr(miri, ignore)]\n    async fn test_aliases_get() {\n        let v = std::fs::read_to_string(\"test_data/Q42.json\").unwrap();\n        let v: Value = serde_json::from_str(&v).unwrap();\n        let id_q42 = v[\"id\"].as_str().unwrap();\n\n        let mock_path = format!(\"/w/rest.php/wikibase/v1/entities/items/{id_q42}/aliases/en\");\n        let mock_server = MockServer::start().await;\n        Mock::given(method(\"GET\"))\n            .and(path(&mock_path))\n            .respond_with(ResponseTemplate::new(200).set_body_json(&v[\"aliases\"][\"en\"]))\n            .mount(&mock_server)\n            .await;\n        let api = RestApi::builder(&(mock_server.uri() + \"/w/rest.php\"))\n            .unwrap()\n            .build();\n\n        let id = EntityId::item(\"Q42\");\n        let aliases = AliasesInLanguage::get(&id, \"en\", &api).await.unwrap();\n        assert!(aliases.values.contains(&\"Douglas NoÃ«l Adams\".to_string()));\n    }\n\n    #[tokio::test]\n    #[cfg_attr(miri, ignore)]\n    async fn test_aliases_post() {\n        // #lizard forgives the complexity\n        let v = std::fs::read_to_string(\"test_data/Q42.json\").unwrap();\n        let v: Value = serde_json::from_str(&v).unwrap();\n        let id = v[\"id\"].as_str().unwrap();\n        let new_alias = \"Foo bar baz\";\n        let mut new_aliases = v[\"aliases\"][\"en\"].to_owned();\n        new_aliases.as_array_mut().unwrap().push(json!(new_alias));\n\n        let mock_path = format!(\"/w/rest.php/wikibase/v1/entities/items/{id}/aliases/en\");\n        let mock_server = MockServer::start().await;\n        let token = \"FAKE_TOKEN\";\n        Mock::given(method(\"GET\"))\n            .and(path(&mock_path))\n            .respond_with(ResponseTemplate::new(200).set_body_json(&v[\"aliases\"][\"en\"]))\n            .mount(&mock_server)\n            .await;\n        Mock::given(body_partial_json(json!({\"aliases\": [new_alias]})))\n            .and(method(\"POST\"))\n            .and(path(&mock_path))\n            .and(bearer_token(token))\n            .respond_with(ResponseTemplate::new(200).set_body_json(&new_aliases))\n            .mount(&mock_server)\n            .await;\n        let mut api = RestApi::builder(&(mock_server.uri() + \"/w/rest.php\"))\n            .unwrap()\n            .with_access_token(token)\n            .build();\n\n        let id2 = EntityId::item(\"Q42\");\n        let aliases = AliasesInLanguage::get(&id2, \"en\", &api).await.unwrap();\n        let new_aliases2 = AliasesInLanguage::new(\"en\", vec![new_alias.to_string()]);\n        let new_aliases2 = new_aliases2.post(&id2, &mut api).await.unwrap();\n        assert_eq!(new_aliases2.len(), aliases.len() + 1);\n        assert!(new_aliases2.values.contains(&new_alias.to_string()));\n\n        // Check non-existing item\n        let id3 = EntityId::item(\"Q12345\");\n        assert_eq!(\n            AliasesInLanguage::get(&id3, \"en\", &api)\n                .await\n                .unwrap()\n                .len(),\n            0\n        );\n    }\n\n    #[test]\n    fn test_aliases_new() {\n        let aliases = AliasesInLanguage::new(\"en\", vec![\"Foo\".to_string(), \"Bar\".to_string()]);\n        assert_eq!(aliases.language(), \"en\");\n        assert_eq!(aliases.len(), 2);\n    }\n\n    #[test]\n    fn test_aliases_from_json() {\n        let j = json!([\"Foo\", \"Bar\"]);\n        let aliases = AliasesInLanguage::from_json(\"en\", &j).unwrap();\n        assert_eq!(aliases.language(), \"en\");\n        assert_eq!(aliases.len(), 2);\n    }\n\n    #[test]\n    fn test_aliases_push() {\n        let mut aliases = AliasesInLanguage::new(\"en\", vec![\"Foo\".to_string()]);\n        aliases.push(\"Bar\".to_string());\n        aliases.push(\"Foo\".to_string());\n        assert_eq!(aliases.len(), 2);\n    }\n\n    #[test]\n    fn test_aliases_values() {\n        let aliases = AliasesInLanguage::new(\"en\", vec![\"Foo\".to_string(), \"Bar\".to_string()]);\n        assert_eq!(\n            aliases.values(),\n            &vec![\"Foo\".to_string(), \"Bar\".to_string()]\n        );\n    }\n\n    #[test]\n    fn test_aliases_len() {\n        let aliases = AliasesInLanguage::new(\"en\", vec![\"Foo\".to_string(), \"Bar\".to_string()]);\n        assert_eq!(aliases.len(), 2);\n    }\n\n    #[test]\n    fn test_aliases_header_info() {\n        let aliases = AliasesInLanguage::new(\"en\", vec![\"Foo\".to_string(), \"Bar\".to_string()]);\n        assert_eq!(aliases.header_info(), &HeaderInfo::default());\n    }\n\n    #[test]\n    fn test_from_json_header_info() {\n        let j = json!(12345);\n\n        let aliases = AliasesInLanguage::from_json(\"\", &j).unwrap_err();\n        assert_eq!(aliases.to_string(), \"Empty value: Language\");\n\n        let aliases2 = AliasesInLanguage::from_json(\"en\", &j).unwrap_err();\n        assert_eq!(aliases2.to_string(), \"Missing field Aliases: 12345\");\n    }\n\n    #[test]\n    fn test_is_empty() {\n        let aliases = AliasesInLanguage::new(\"en\", vec![\"Foo\".to_string(), \"Bar\".to_string()]);\n        assert!(!aliases.is_empty());\n        let aliases2 = AliasesInLanguage::new(\"en\", vec![]);\n        assert!(aliases2.is_empty());\n    }\n}\n","traces":[{"line":22,"address":[],"length":0,"stats":{"Line":10}},{"line":24,"address":[],"length":0,"stats":{"Line":10}},{"line":26,"address":[],"length":0,"stats":{"Line":10}},{"line":31,"address":[],"length":0,"stats":{"Line":3}},{"line":32,"address":[],"length":0,"stats":{"Line":3}},{"line":36,"address":[],"length":0,"stats":{"Line":7}},{"line":41,"address":[],"length":0,"stats":{"Line":7}},{"line":42,"address":[],"length":0,"stats":{"Line":7}},{"line":43,"address":[],"length":0,"stats":{"Line":1}},{"line":45,"address":[],"length":0,"stats":{"Line":5}},{"line":47,"address":[],"length":0,"stats":{"Line":1}},{"line":48,"address":[],"length":0,"stats":{"Line":1}},{"line":49,"address":[],"length":0,"stats":{"Line":1}},{"line":52,"address":[],"length":0,"stats":{"Line":14}},{"line":53,"address":[],"length":0,"stats":{"Line":9}},{"line":54,"address":[],"length":0,"stats":{"Line":9}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":9}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":2}},{"line":70,"address":[],"length":0,"stats":{"Line":3}},{"line":71,"address":[],"length":0,"stats":{"Line":1}},{"line":76,"address":[],"length":0,"stats":{"Line":1}},{"line":77,"address":[],"length":0,"stats":{"Line":1}},{"line":81,"address":[],"length":0,"stats":{"Line":9}},{"line":82,"address":[],"length":0,"stats":{"Line":9}},{"line":86,"address":[],"length":0,"stats":{"Line":2}},{"line":87,"address":[],"length":0,"stats":{"Line":2}},{"line":91,"address":[],"length":0,"stats":{"Line":2}},{"line":92,"address":[],"length":0,"stats":{"Line":2}},{"line":96,"address":[],"length":0,"stats":{"Line":2}},{"line":97,"address":[],"length":0,"stats":{"Line":1}},{"line":101,"address":[],"length":0,"stats":{"Line":1}},{"line":107,"address":[],"length":0,"stats":{"Line":1}},{"line":108,"address":[],"length":0,"stats":{"Line":2}},{"line":109,"address":[],"length":0,"stats":{"Line":1}},{"line":110,"address":[],"length":0,"stats":{"Line":1}},{"line":115,"address":[],"length":0,"stats":{"Line":1}},{"line":116,"address":[],"length":0,"stats":{"Line":1}},{"line":119,"address":[],"length":0,"stats":{"Line":3}},{"line":123,"address":[],"length":0,"stats":{"Line":3}},{"line":124,"address":[],"length":0,"stats":{"Line":6}},{"line":125,"address":[],"length":0,"stats":{"Line":2}},{"line":126,"address":[],"length":0,"stats":{"Line":1}},{"line":127,"address":[],"length":0,"stats":{"Line":1}},{"line":128,"address":[],"length":0,"stats":{"Line":1}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":1}},{"line":140,"address":[],"length":0,"stats":{"Line":1}},{"line":141,"address":[],"length":0,"stats":{"Line":1}},{"line":142,"address":[],"length":0,"stats":{"Line":1}},{"line":156,"address":[],"length":0,"stats":{"Line":3}},{"line":158,"address":[],"length":0,"stats":{"Line":3}},{"line":160,"address":[],"length":0,"stats":{"Line":3}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":6}}],"covered":52,"coverable":61},{"path":["/","Users","magnusmanske","rust","wikibase_rest_api","src","aliases_patch.rs"],"content":"use crate::{\n    aliases::Aliases, patch_entry::PatchEntry, EditMetadata, EntityId, FromJson, HttpMisc, Patch,\n    PatchApply, RestApi, RestApiError,\n};\nuse async_trait::async_trait;\nuse serde::Serialize;\nuse serde_json::{json, Value};\n\n#[derive(Debug, Clone, Default, PartialEq, Serialize)]\npub struct AliasesPatch {\n    patch: Vec<PatchEntry>,\n}\n\nimpl AliasesPatch {\n    /// Adds a command to replace an alias in a specific language, at a specific position\n    pub fn replace<S1: Into<String>, S2: Into<String>>(\n        &mut self,\n        language: S1,\n        num: usize,\n        value: S2,\n    ) {\n        <Self as Patch>::replace(\n            self,\n            format!(\"/{}/{num}\", language.into()),\n            value.into().into(),\n        );\n    }\n\n    /// Adds a command to remove an alias in a specific language, at a specific position\n    pub fn remove<S: Into<String>>(&mut self, language: S, num: usize) {\n        <Self as Patch>::remove(self, format!(\"/{}/{num}\", language.into()));\n    }\n\n    /// Generates a patch from JSON, presumably from `json_patch`\n    pub fn from_json(j: &Value) -> Result<Self, RestApiError> {\n        let pe = j\n            .as_array()\n            .ok_or(RestApiError::MissingOrInvalidField {\n                field: \"AliasPatch\".to_string(),\n                j: j.clone(),\n            })?\n            .iter()\n            .map(|x| serde_json::from_value(x.clone()))\n            .collect::<Result<Vec<PatchEntry>, serde_json::Error>>()?;\n        Ok(Self { patch: pe })\n    }\n}\n\nimpl Patch for AliasesPatch {\n    fn patch(&self) -> &Vec<PatchEntry> {\n        &self.patch\n    }\n\n    fn patch_mut(&mut self) -> &mut Vec<PatchEntry> {\n        &mut self.patch\n    }\n}\n\n#[async_trait]\nimpl PatchApply<Aliases> for AliasesPatch {\n    async fn apply_match(\n        &self,\n        id: &EntityId,\n        api: &mut RestApi,\n        em: EditMetadata,\n    ) -> Result<Aliases, RestApiError> {\n        let j = json!({\"patch\": self.patch});\n        let request = self\n            .generate_json_request(id, reqwest::Method::PATCH, j, api, &em)\n            .await?;\n        let response = api.execute(request).await?;\n        let (j2, header_info) = self.filter_response_error(response).await?;\n        Aliases::from_json_header_info(&j2, header_info)\n    }\n}\n\nimpl HttpMisc for AliasesPatch {\n    fn get_my_rest_api_path(&self, id: &EntityId) -> Result<String, RestApiError> {\n        Ok(format!(\"/entities/{}/{id}/aliases\", id.group()?))\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use serde_json::Value;\n    use wiremock::matchers::{bearer_token, body_partial_json, header, method, path};\n    use wiremock::{Mock, MockServer, ResponseTemplate};\n\n    #[tokio::test]\n    #[cfg_attr(miri, ignore)]\n    async fn test_aliases_patch() {\n        let id = \"Q42\";\n        let new_alias = \"Foo bar baz\";\n        let v = std::fs::read_to_string(\"test_data/Q42.json\").unwrap();\n        let v: Value = serde_json::from_str(&v).unwrap();\n        let mut new_aliases = v[\"aliases\"].to_owned();\n        new_aliases[\"en\"][1] = json!(new_alias);\n\n        let mock_path = format!(\"/w/rest.php/wikibase/v1/entities/items/{id}/aliases\");\n        let mock_server = MockServer::start().await;\n        let token = \"FAKE_TOKEN\";\n        Mock::given(body_partial_json(\n            json!({\"patch\":[{\"op\": \"replace\",\"path\": \"/en/1\",\"value\": new_alias}]}),\n        ))\n        .and(method(\"PATCH\"))\n        .and(path(&mock_path))\n        .and(bearer_token(token))\n        .and(header(\"content-type\", \"application/json-patch+json\"))\n        .respond_with(\n            ResponseTemplate::new(200)\n                .insert_header(\"ETag\", \"12345\")\n                .set_body_json(&new_aliases),\n        )\n        .mount(&mock_server)\n        .await;\n        let mut api = RestApi::builder(&(mock_server.uri() + \"/w/rest.php\"))\n            .unwrap()\n            .with_access_token(token)\n            .build();\n\n        // Apply patch\n        let id = EntityId::new(id).unwrap();\n        let mut patch = AliasesPatch::default();\n        patch.replace(\"en\", 1, new_alias);\n        let new_aliases2 = patch.apply(&id, &mut api).await.unwrap();\n        assert_eq!(new_aliases2.get_lang(\"en\")[1], new_alias);\n    }\n}\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":2}},{"line":23,"address":[],"length":0,"stats":{"Line":2}},{"line":24,"address":[],"length":0,"stats":{"Line":2}},{"line":25,"address":[],"length":0,"stats":{"Line":2}},{"line":30,"address":[],"length":0,"stats":{"Line":1}},{"line":31,"address":[],"length":0,"stats":{"Line":1}},{"line":35,"address":[],"length":0,"stats":{"Line":2}},{"line":36,"address":[],"length":0,"stats":{"Line":4}},{"line":38,"address":[],"length":0,"stats":{"Line":2}},{"line":39,"address":[],"length":0,"stats":{"Line":2}},{"line":40,"address":[],"length":0,"stats":{"Line":2}},{"line":43,"address":[],"length":0,"stats":{"Line":5}},{"line":50,"address":[],"length":0,"stats":{"Line":5}},{"line":51,"address":[],"length":0,"stats":{"Line":5}},{"line":54,"address":[],"length":0,"stats":{"Line":4}},{"line":55,"address":[],"length":0,"stats":{"Line":4}},{"line":67,"address":[],"length":0,"stats":{"Line":1}},{"line":68,"address":[],"length":0,"stats":{"Line":2}},{"line":69,"address":[],"length":0,"stats":{"Line":1}},{"line":70,"address":[],"length":0,"stats":{"Line":1}},{"line":71,"address":[],"length":0,"stats":{"Line":1}},{"line":72,"address":[],"length":0,"stats":{"Line":1}},{"line":78,"address":[],"length":0,"stats":{"Line":1}},{"line":79,"address":[],"length":0,"stats":{"Line":2}}],"covered":24,"coverable":24},{"path":["/","Users","magnusmanske","rust","wikibase_rest_api","src","bearer_token.rs"],"content":"use std::collections::HashMap;\n\nuse reqwest::Request;\nuse serde_json::Value;\n\nuse crate::{RestApi, RestApiError};\n\n/// The default time to wait until bearer token is renewed. API says 4h so setting it to 3h50min\nconst DEFAULT_RENEWAL_INTERVAL_SEC: u64 = (3 * 60 + 50) * 60;\n\n#[derive(Debug, Clone, Default)]\npub struct BearerToken {\n    client_id: Option<String>,\n    client_secret: Option<String>,\n    access_token: Option<String>,\n    refresh_token: Option<String>,\n    last_update: Option<std::time::Instant>,\n    renewal_interval: std::time::Duration,\n}\n\nimpl BearerToken {\n    /// Returns the `OAuth2` bearer token\n    pub const fn get(&self) -> &Option<String> {\n        &self.access_token\n    }\n\n    /// For non-owner-only clients, returns a URL to send the user to login and authorize the client.\n    /// Upon authorizing, the user will be redirected to the URL with a code, which can be exchanged for an access token, via `get_access_token`.\n    pub fn authorization_code_url(&self, api: &RestApi) -> Result<String, RestApiError> {\n        let client_id = self\n            .client_id\n            .as_ref()\n            .ok_or_else(|| RestApiError::ClientIdRequired)?;\n        let api_url = api.api_url();\n        Ok(format!(\n            \"{api_url}/oauth2/authorize?client_id={client_id}&response_type=code\"\n        ))\n    }\n\n    /// Returns the renewal interval for the `OAuth2` bearer token.\n    pub const fn access_token_renewal_interval(&self) -> std::time::Duration {\n        self.renewal_interval\n    }\n\n    /// Internal use only.\n    pub const fn client_id(&self) -> &Option<String> {\n        &self.client_id\n    }\n\n    /// Internal use only.\n    pub const fn client_secret(&self) -> &Option<String> {\n        &self.client_secret\n    }\n\n    fn generate_get_access_token_parameters(\n        &self,\n        code: &str,\n    ) -> Result<HashMap<String, String>, RestApiError> {\n        let client_id = self\n            .client_id\n            .as_ref()\n            .ok_or(RestApiError::ClientIdRequired)?;\n        let client_secret = self\n            .client_secret\n            .as_ref()\n            .ok_or(RestApiError::ClientSecretRequired)?;\n\n        let params = [\n            (\"grant_type\", \"authorization_code\"),\n            (\"client_id\", client_id.as_str()),\n            (\"client_secret\", client_secret.as_str()),\n            (\"code\", code),\n        ];\n        Ok(Self::array2hashmap(&params))\n    }\n\n    async fn generate_get_access_token_request(\n        &self,\n        api: &RestApi,\n        code: &str,\n    ) -> Result<Request, RestApiError> {\n        let params = self.generate_get_access_token_parameters(code)?;\n        let headers = api.headers_from_token(self).await?;\n        let url = format!(\"{api_url}/oauth2/access_token\", api_url = api.api_url());\n        let mut request = api\n            .client()\n            .post(url)\n            .headers(headers)\n            .form(&params)\n            .build()?;\n        request.headers_mut().insert(\n            reqwest::header::CONTENT_TYPE,\n            \"application/x-www-form-urlencoded\".parse()?,\n        );\n        Ok(request)\n    }\n\n    /// Exchanges a code for an access token\n    pub async fn get_access_token(\n        &mut self,\n        api: &RestApi,\n        code: &str,\n    ) -> Result<(), RestApiError> {\n        let request = self.generate_get_access_token_request(api, code).await?;\n        let response = api.client().execute(request).await?;\n        let j: Value = response.json().await?;\n        self.set_tokens_from_json(j)\n    }\n\n    /// Sets the `OAuth2` bearer token and refresh token from a JSON response\n    fn set_tokens_from_json(&mut self, j: Value) -> Result<(), RestApiError> {\n        let access_token = j[\"access_token\"]\n            .as_str()\n            .ok_or(RestApiError::AccessTokenRequired)?\n            .to_string();\n        let refresh_token = j[\"refresh_token\"]\n            .as_str()\n            .ok_or(RestApiError::RefreshTokenRequired)?\n            .to_string();\n        let renewal_interval = j[\"expires_in\"].as_u64().unwrap_or_default() / 10 * 9; // 90% of max duration\n        self.set_tokens(Some(access_token), Some(refresh_token));\n        self.set_renewal_interval(renewal_interval);\n        self.touch_access_token();\n        Ok(())\n    }\n\n    /// Updates the last bearer token update time to current time\n    fn touch_access_token(&mut self) {\n        self.last_update = Some(std::time::Instant::now());\n    }\n\n    pub const fn refresh_token(&self) -> &Option<String> {\n        &self.refresh_token\n    }\n\n    /// Sets the renewal interval for the `OAuth2` bearer token\n    pub const fn set_renewal_interval(&mut self, renewal_interval: u64) {\n        let renewal_interval = match renewal_interval {\n            0 => DEFAULT_RENEWAL_INTERVAL_SEC,\n            renewal_interval => renewal_interval,\n        };\n        self.renewal_interval = std::time::Duration::from_secs(renewal_interval);\n    }\n\n    /// Sets the `OAuth2` bearer token and refresh token\n    pub fn set_tokens(&mut self, access_token: Option<String>, refresh_token: Option<String>) {\n        self.access_token = access_token;\n        self.refresh_token = refresh_token;\n    }\n\n    /// Checks if the bearer token needs to be updated, and updates it if necessary\n    pub async fn check(&mut self, api: &RestApi, request: &Request) -> Result<(), RestApiError> {\n        let method = request.method();\n        if method == reqwest::Method::GET {\n            return Ok(());\n        }\n        if self.can_update_access_token() {\n            self.renew_access_token(api).await?;\n        }\n        Ok(())\n    }\n\n    /// Sets the `OAuth2` bearer token (owner-only clients are supported)\n    pub fn set_access_token<S: Into<String>>(&mut self, access_token: S) {\n        self.access_token = Some(access_token.into());\n    }\n\n    //// Sets the OAuth2 client ID and client secret\n    pub fn set_oauth2_info<S1: Into<String>, S2: Into<String>>(\n        &mut self,\n        client_id: S1,\n        client_secret: S2,\n    ) {\n        self.client_id = Some(client_id.into());\n        self.client_secret = Some(client_secret.into());\n    }\n\n    /// Returns `true` if an `OAuth2` bearer token is present\n    pub const fn has_access_token(&self) -> bool {\n        self.access_token.is_some()\n    }\n\n    /// Returns `true` if the client ID and client secret are present\n    const fn can_update_access_token(&self) -> bool {\n        self.client_id.is_some() && self.client_secret.is_some()\n    }\n\n    /// Check if last bearer token update is within the renewal interval\n    fn does_access_token_need_updating(&self) -> bool {\n        if let Some(last_update) = self.last_update {\n            let elapsed = last_update.elapsed();\n            if elapsed < self.renewal_interval {\n                return false;\n            }\n        }\n        true\n    }\n\n    fn get_renew_access_token_parameters(&self) -> Result<HashMap<String, String>, RestApiError> {\n        let client_id = self\n            .client_id\n            .as_ref()\n            .ok_or(RestApiError::ClientIdRequired)?;\n        let client_secret = self\n            .client_secret\n            .as_ref()\n            .ok_or(RestApiError::ClientSecretRequired)?;\n        let refresh_token = self\n            .refresh_token\n            .as_ref()\n            .ok_or_else(|| RestApiError::RefreshTokenRequired)?;\n        let params = [\n            (\"client_id\", client_id.as_str()),\n            (\"client_secret\", client_secret.as_str()),\n            (\"grant_type\", \"refresh_token\"),\n            (\"refresh_token\", refresh_token.as_str()),\n        ];\n        Ok(Self::array2hashmap(&params))\n    }\n\n    async fn get_renew_access_token_request(&self, api: &RestApi) -> Result<Request, RestApiError> {\n        let params = self.get_renew_access_token_parameters()?;\n        let headers = api.headers_from_token(self).await?;\n        let url = format!(\"{}{}\", api.api_url(), \"/oauth2/access_token\");\n        let mut request = api\n            .client()\n            .post(url)\n            .headers(headers)\n            .form(&params)\n            .build()?;\n\n        request.headers_mut().insert(\n            reqwest::header::CONTENT_TYPE,\n            \"application/x-www-form-urlencoded\".parse()?,\n        );\n        Ok(request)\n    }\n\n    /// Refresh the `OAuth2` bearer token for Non-owner-only clients\n    pub async fn renew_access_token(&mut self, api: &RestApi) -> Result<(), RestApiError> {\n        if !self.does_access_token_need_updating() {\n            return Ok(());\n        }\n        let request = self.get_renew_access_token_request(api).await?;\n        let response = api.client().execute(request).await?;\n        let j: Value = response.json().await?;\n        self.set_tokens_from_json(j)\n    }\n\n    fn array2hashmap(array: &[(&str, &str)]) -> HashMap<String, String> {\n        array\n            .iter()\n            .map(|(k, v)| (k.to_string(), v.to_string()))\n            .collect()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use serde_json::json;\n    use wiremock::matchers::{body_string_contains, method, path};\n    use wiremock::{Mock, MockServer, ResponseTemplate};\n\n    #[test]\n    fn test_has_access_token() {\n        let mut token = BearerToken::default();\n        assert!(!token.has_access_token());\n        token.set_access_token(\"test\");\n        assert!(token.has_access_token());\n    }\n\n    #[test]\n    fn test_can_update_access_token() {\n        let mut token = BearerToken::default();\n        assert!(!token.can_update_access_token());\n        token.set_oauth2_info(\"client_id\", \"client_secret\");\n        assert!(token.can_update_access_token());\n    }\n\n    #[test]\n    fn test_does_access_token_need_updating() {\n        let mut token = BearerToken::default();\n        assert!(token.does_access_token_need_updating());\n        token.touch_access_token();\n        assert!(token.does_access_token_need_updating());\n        token.set_renewal_interval(0);\n        assert!(!token.does_access_token_need_updating());\n    }\n\n    #[test]\n    fn test_get() {\n        let mut token = BearerToken::default();\n        assert_eq!(token.get(), &None);\n        token.set_access_token(\"test\");\n        assert_eq!(token.get(), &Some(\"test\".to_string()));\n    }\n\n    #[test]\n    #[cfg_attr(miri, ignore)] // TODO this should work in miri\n    fn test_authorization_code_url() {\n        let mut token = BearerToken::default();\n        let api = RestApi::builder(\"https://www.wikidata.org/w/rest.php\")\n            .unwrap()\n            .build();\n        token.set_oauth2_info(\"client_id\", \"client_secret\");\n        assert_eq!(token.authorization_code_url(&api).unwrap(), \"https://www.wikidata.org/w/rest.php/oauth2/authorize?client_id=client_id&response_type=code\");\n    }\n\n    #[test]\n    fn test_set_tokens_from_json() {\n        let mut token = BearerToken::default();\n        let j = serde_json::json!({\n            \"access_token\": \"foo\",\n            \"refresh_token\": \"bar\",\n            \"expires_in\": 3600,\n        });\n        token.set_tokens_from_json(j).unwrap();\n        assert_eq!(token.get(), &Some(\"foo\".to_string()));\n        assert_eq!(token.refresh_token(), &Some(\"bar\".to_string()));\n        assert_eq!(\n            token.renewal_interval,\n            std::time::Duration::from_secs(3600 / 10 * 9)\n        );\n    }\n\n    #[tokio::test]\n    #[cfg_attr(miri, ignore)]\n    async fn test_get_access_token() {\n        // #lizard forgives the complexity\n        let client_id = \"client_id_foobar\";\n        let client_secret = \"client_secret_foobar\";\n        let code = \"code_foobar\";\n        let mock_path = \"/w/rest.php/oauth2/access_token\";\n\n        let mock_server = MockServer::start().await;\n        Mock::given(method(\"POST\"))\n            .and(body_string_contains(\"grant_type=authorization_code\"))\n            .and(body_string_contains(format!(\"client_id={client_id}\")))\n            .and(body_string_contains(format!(\n                \"client_secret={client_secret}\"\n            )))\n            .and(body_string_contains(format!(\"code={code}\")))\n            .and(path(mock_path))\n            .respond_with(ResponseTemplate::new(200).set_body_json(json!({\n                \"access_token\": \"access_token_foobar\",\n                \"refresh_token\": \"refresh_token_foobar\",\n                \"expires_in\": 3600,\n            })))\n            .mount(&mock_server)\n            .await;\n        let api = RestApi::builder(&(mock_server.uri() + \"/w/rest.php\"))\n            .unwrap()\n            .build();\n\n        // Test error cases\n        assert!(api\n            .token\n            .write()\n            .await\n            .get_access_token(&api, code)\n            .await\n            .is_err());\n\n        // Test success case\n        api.token\n            .write()\n            .await\n            .set_oauth2_info(client_id, client_secret);\n        api.token\n            .write()\n            .await\n            .get_access_token(&api, code)\n            .await\n            .unwrap();\n        assert_eq!(\n            api.token.read().await.get().to_owned().unwrap(),\n            \"access_token_foobar\"\n        );\n        assert_eq!(\n            api.token.read().await.refresh_token().to_owned().unwrap(),\n            \"refresh_token_foobar\"\n        );\n        assert_eq!(\n            api.token.read().await.renewal_interval,\n            std::time::Duration::from_secs(3600 / 10 * 9)\n        );\n    }\n\n    #[tokio::test]\n    #[cfg_attr(miri, ignore)]\n    async fn test_renew_access_token() {\n        // #lizard forgives the complexity\n        let client_id = \"client_id_foobar\";\n        let client_secret = \"client_secret_foobar\";\n        let refresh_token = \"refresh_token_foobar\";\n        let mock_path = \"/w/rest.php/oauth2/access_token\";\n\n        let mock_server = MockServer::start().await;\n        Mock::given(method(\"POST\"))\n            .and(body_string_contains(\"grant_type=refresh_token\"))\n            .and(body_string_contains(format!(\"client_id={client_id}\")))\n            .and(body_string_contains(format!(\n                \"client_secret={client_secret}\"\n            )))\n            .and(body_string_contains(format!(\n                \"refresh_token={refresh_token}\"\n            )))\n            .and(path(mock_path))\n            .respond_with(ResponseTemplate::new(200).set_body_json(json!({\n                \"access_token\": \"access_token_foobar2\",\n                \"refresh_token\": \"refresh_token_foobar2\",\n                \"expires_in\": 3600,\n            })))\n            .mount(&mock_server)\n            .await;\n        let api = RestApi::builder(&(mock_server.uri() + \"/w/rest.php\"))\n            .unwrap()\n            .build();\n\n        // Test error cases\n        assert!(api\n            .token\n            .write()\n            .await\n            .renew_access_token(&api)\n            .await\n            .is_err());\n\n        // Test success case\n        api.token\n            .write()\n            .await\n            .set_oauth2_info(client_id, client_secret);\n        api.token\n            .write()\n            .await\n            .set_tokens(None, Some(\"refresh_token_foobar\".to_string()));\n        api.token\n            .write()\n            .await\n            .renew_access_token(&api)\n            .await\n            .unwrap();\n        assert_eq!(\n            api.token.read().await.get().to_owned().unwrap(),\n            \"access_token_foobar2\"\n        );\n        assert_eq!(\n            api.token.read().await.refresh_token().to_owned().unwrap(),\n            \"refresh_token_foobar2\"\n        );\n        assert_eq!(\n            api.token.read().await.renewal_interval,\n            std::time::Duration::from_secs(3600 / 10 * 9)\n        );\n    }\n\n    #[tokio::test]\n    #[cfg_attr(miri, ignore)]\n    async fn test_renew_access_token_no_need() {\n        let api = RestApi::builder(\"https://test.wikidata.org/w/rest.php\")\n            .unwrap()\n            .build();\n        let mut bt = BearerToken::default();\n        bt.touch_access_token();\n        bt.renewal_interval = std::time::Duration::from_secs(3600);\n        // This will fail if not for \"no update needed\", since client ID and secret are not set\n        assert!(bt.renew_access_token(&api).await.is_ok());\n    }\n\n    #[test]\n    fn test_array2hashmap() {\n        let array = [(\"a\", \"1\"), (\"b\", \"2\")];\n        let hashmap = BearerToken::array2hashmap(&array);\n        assert_eq!(hashmap.get(\"a\"), Some(&\"1\".to_string()));\n        assert_eq!(hashmap.get(\"b\"), Some(&\"2\".to_string()));\n    }\n}\n","traces":[{"line":23,"address":[],"length":0,"stats":{"Line":56}},{"line":24,"address":[],"length":0,"stats":{"Line":56}},{"line":29,"address":[],"length":0,"stats":{"Line":1}},{"line":30,"address":[],"length":0,"stats":{"Line":2}},{"line":31,"address":[],"length":0,"stats":{"Line":1}},{"line":33,"address":[],"length":0,"stats":{"Line":2}},{"line":41,"address":[],"length":0,"stats":{"Line":2}},{"line":42,"address":[],"length":0,"stats":{"Line":2}},{"line":46,"address":[],"length":0,"stats":{"Line":2}},{"line":47,"address":[],"length":0,"stats":{"Line":2}},{"line":51,"address":[],"length":0,"stats":{"Line":2}},{"line":52,"address":[],"length":0,"stats":{"Line":2}},{"line":55,"address":[],"length":0,"stats":{"Line":2}},{"line":59,"address":[],"length":0,"stats":{"Line":3}},{"line":60,"address":[],"length":0,"stats":{"Line":2}},{"line":62,"address":[],"length":0,"stats":{"Line":3}},{"line":63,"address":[],"length":0,"stats":{"Line":1}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":2}},{"line":82,"address":[],"length":0,"stats":{"Line":4}},{"line":83,"address":[],"length":0,"stats":{"Line":1}},{"line":85,"address":[],"length":0,"stats":{"Line":1}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":1}},{"line":99,"address":[],"length":0,"stats":{"Line":2}},{"line":104,"address":[],"length":0,"stats":{"Line":4}},{"line":105,"address":[],"length":0,"stats":{"Line":1}},{"line":106,"address":[],"length":0,"stats":{"Line":1}},{"line":111,"address":[],"length":0,"stats":{"Line":3}},{"line":112,"address":[],"length":0,"stats":{"Line":6}},{"line":114,"address":[],"length":0,"stats":{"Line":3}},{"line":116,"address":[],"length":0,"stats":{"Line":3}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":5}},{"line":129,"address":[],"length":0,"stats":{"Line":5}},{"line":132,"address":[],"length":0,"stats":{"Line":3}},{"line":133,"address":[],"length":0,"stats":{"Line":3}},{"line":137,"address":[],"length":0,"stats":{"Line":5}},{"line":138,"address":[],"length":0,"stats":{"Line":10}},{"line":139,"address":[],"length":0,"stats":{"Line":1}},{"line":140,"address":[],"length":0,"stats":{"Line":4}},{"line":142,"address":[],"length":0,"stats":{"Line":5}},{"line":146,"address":[],"length":0,"stats":{"Line":4}},{"line":147,"address":[],"length":0,"stats":{"Line":4}},{"line":148,"address":[],"length":0,"stats":{"Line":4}},{"line":152,"address":[],"length":0,"stats":{"Line":98}},{"line":153,"address":[],"length":0,"stats":{"Line":49}},{"line":154,"address":[],"length":0,"stats":{"Line":49}},{"line":155,"address":[],"length":0,"stats":{"Line":31}},{"line":157,"address":[],"length":0,"stats":{"Line":18}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":18}},{"line":164,"address":[],"length":0,"stats":{"Line":15}},{"line":165,"address":[],"length":0,"stats":{"Line":15}},{"line":169,"address":[],"length":0,"stats":{"Line":5}},{"line":174,"address":[],"length":0,"stats":{"Line":5}},{"line":175,"address":[],"length":0,"stats":{"Line":5}},{"line":179,"address":[],"length":0,"stats":{"Line":2}},{"line":180,"address":[],"length":0,"stats":{"Line":2}},{"line":184,"address":[],"length":0,"stats":{"Line":20}},{"line":185,"address":[],"length":0,"stats":{"Line":21}},{"line":189,"address":[],"length":0,"stats":{"Line":6}},{"line":190,"address":[],"length":0,"stats":{"Line":9}},{"line":193,"address":[],"length":0,"stats":{"Line":2}},{"line":196,"address":[],"length":0,"stats":{"Line":4}},{"line":199,"address":[],"length":0,"stats":{"Line":2}},{"line":200,"address":[],"length":0,"stats":{"Line":3}},{"line":201,"address":[],"length":0,"stats":{"Line":2}},{"line":203,"address":[],"length":0,"stats":{"Line":3}},{"line":204,"address":[],"length":0,"stats":{"Line":1}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":1}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":4}},{"line":222,"address":[],"length":0,"stats":{"Line":4}},{"line":223,"address":[],"length":0,"stats":{"Line":1}},{"line":225,"address":[],"length":0,"stats":{"Line":1}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":1}},{"line":240,"address":[],"length":0,"stats":{"Line":6}},{"line":241,"address":[],"length":0,"stats":{"Line":3}},{"line":242,"address":[],"length":0,"stats":{"Line":1}},{"line":244,"address":[],"length":0,"stats":{"Line":4}},{"line":245,"address":[],"length":0,"stats":{"Line":1}},{"line":246,"address":[],"length":0,"stats":{"Line":1}},{"line":250,"address":[],"length":0,"stats":{"Line":3}},{"line":251,"address":[],"length":0,"stats":{"Line":3}},{"line":253,"address":[],"length":0,"stats":{"Line":16}}],"covered":81,"coverable":88},{"path":["/","Users","magnusmanske","rust","wikibase_rest_api","src","config.rs"],"content":"#[derive(Debug, Clone, Copy, PartialEq)]\npub struct Config {\n    item_letter: char,\n    property_letter: char,\n}\n\nimpl Config {\n    /// Constructs a new `Config` object from item and property letters.\n    pub const fn new(item_letter: char, property_letter: char) -> Config {\n        Config {\n            item_letter,\n            property_letter,\n        }\n    }\n\n    /// Returns the letter used for items.\n    pub const fn item_letter(&self) -> char {\n        self.item_letter\n    }\n\n    /// Returns the letter used for properties.\n    pub const fn property_letter(&self) -> char {\n        self.property_letter\n    }\n}\n\npub const WIKIDATA_CONFIG: Config = Config {\n    item_letter: 'Q',\n    property_letter: 'P',\n};\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_config() {\n        let config = Config::new('Q', 'P');\n        assert_eq!(config.item_letter(), 'Q');\n        assert_eq!(config.property_letter(), 'P');\n    }\n}\n","traces":[{"line":9,"address":[],"length":0,"stats":{"Line":2}},{"line":17,"address":[],"length":0,"stats":{"Line":20}},{"line":18,"address":[],"length":0,"stats":{"Line":20}},{"line":22,"address":[],"length":0,"stats":{"Line":6}},{"line":23,"address":[],"length":0,"stats":{"Line":6}}],"covered":5,"coverable":5},{"path":["/","Users","magnusmanske","rust","wikibase_rest_api","src","data_type.rs"],"content":"use crate::RestApiError;\n\n#[derive(Debug, Clone, PartialEq, Default, Copy)]\npub enum DataType {\n    #[default]\n    String,\n    Item,\n    Property,\n    Url,\n    Time,\n    GlobeCoordinate,\n    Quantity,\n    Monolingualtext,\n    CommonsMedia,\n    GeoShape,\n    TabularData,\n    Math,\n    MusicalNotation,\n    ExternalId,\n    WikibaseItem,\n    WikibaseProperty,\n    Lexeme,\n    Form,\n    Sense,\n    EntitySchema,\n}\n\nimpl DataType {\n    /// Constructs a new `DataType` object from a (valid) string.\n    /// # Errors\n    /// Returns a `RestApiError` if the string is not a valid `DataType`.\n    pub fn new<S: Into<String>>(s: S) -> Result<Self, RestApiError> {\n        match s.into().as_str() {\n            \"wikibase-item\" => Ok(DataType::WikibaseItem),\n            \"external-id\" => Ok(DataType::ExternalId),\n            \"url\" => Ok(DataType::Url),\n            \"commonsMedia\" => Ok(DataType::CommonsMedia),\n            \"monolingualtext\" => Ok(DataType::Monolingualtext),\n            \"quantity\" => Ok(DataType::Quantity),\n            \"string\" => Ok(DataType::String),\n            \"time\" => Ok(DataType::Time),\n            \"globe-coordinate\" => Ok(DataType::GlobeCoordinate),\n            \"wikibase-property\" => Ok(DataType::WikibaseProperty),\n            \"wikibase-lexeme\" => Ok(DataType::Lexeme),\n            \"wikibase-form\" => Ok(DataType::Form),\n            \"wikibase-sense\" => Ok(DataType::Sense),\n            \"geo-shape\" => Ok(DataType::GeoShape),\n            \"tabular-data\" => Ok(DataType::TabularData),\n            \"math\" => Ok(DataType::Math),\n            \"item\" => Ok(DataType::Item),\n            \"property\" => Ok(DataType::Property),\n            \"musical-notation\" => Ok(DataType::MusicalNotation),\n            \"entity-schema\" => Ok(DataType::EntitySchema),\n            other => Err(RestApiError::UnknownDataType(other.into())),\n        }\n    }\n\n    /// Returns the string representation of the data type.\n    pub const fn as_str(&self) -> &str {\n        match self {\n            DataType::WikibaseItem => \"wikibase-item\",\n            DataType::ExternalId => \"external-id\",\n            DataType::Url => \"url\",\n            DataType::CommonsMedia => \"commonsMedia\",\n            DataType::Monolingualtext => \"monolingualtext\",\n            DataType::Quantity => \"quantity\",\n            DataType::String => \"string\",\n            DataType::Time => \"time\",\n            DataType::GlobeCoordinate => \"globe-coordinate\",\n            DataType::WikibaseProperty => \"wikibase-property\",\n            DataType::Lexeme => \"wikibase-lexeme\",\n            DataType::Form => \"wikibase-form\",\n            DataType::Sense => \"wikibase-sense\",\n            DataType::GeoShape => \"geo-shape\",\n            DataType::TabularData => \"tabular-data\",\n            DataType::Math => \"math\",\n            DataType::Item => \"item\",\n            DataType::Property => \"property\",\n            DataType::MusicalNotation => \"musical-notation\",\n            DataType::EntitySchema => \"entity-schema\",\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::RestApi;\n    use std::collections::HashMap;\n\n    #[tokio::test]\n    #[cfg_attr(miri, ignore)]\n    async fn test_data_type_from_str() {\n        // Useful to have this query the live API, and fast enough.\n        let api = RestApi::builder(\"https://www.wikidata.org/w/rest.php\")\n            .unwrap()\n            .build();\n        let request = api\n            .wikibase_request_builder(\"/property-data-types\", HashMap::new(), reqwest::Method::GET)\n            .await\n            .unwrap()\n            .build()\n            .unwrap();\n        let h: HashMap<String, String> = api\n            .execute(request)\n            .await\n            .unwrap()\n            .error_for_status()\n            .unwrap()\n            .json()\n            .await\n            .unwrap();\n        for (k, _v) in h {\n            let dt = DataType::new(&k).unwrap();\n            assert_eq!(dt.as_str(), k);\n        }\n        assert!(DataType::new(\"not-a-data-type\").is_err());\n    }\n\n    #[test]\n    fn test_as_str() {\n        assert_eq!(DataType::WikibaseItem.as_str(), \"wikibase-item\");\n        assert_eq!(DataType::ExternalId.as_str(), \"external-id\");\n        assert_eq!(DataType::Url.as_str(), \"url\");\n        assert_eq!(DataType::CommonsMedia.as_str(), \"commonsMedia\");\n        assert_eq!(DataType::Monolingualtext.as_str(), \"monolingualtext\");\n        assert_eq!(DataType::Quantity.as_str(), \"quantity\");\n        assert_eq!(DataType::String.as_str(), \"string\");\n        assert_eq!(DataType::Time.as_str(), \"time\");\n        assert_eq!(DataType::GlobeCoordinate.as_str(), \"globe-coordinate\");\n        assert_eq!(DataType::WikibaseProperty.as_str(), \"wikibase-property\");\n        assert_eq!(DataType::Lexeme.as_str(), \"wikibase-lexeme\");\n        assert_eq!(DataType::Form.as_str(), \"wikibase-form\");\n        assert_eq!(DataType::Sense.as_str(), \"wikibase-sense\");\n        assert_eq!(DataType::GeoShape.as_str(), \"geo-shape\");\n        assert_eq!(DataType::TabularData.as_str(), \"tabular-data\");\n        assert_eq!(DataType::Math.as_str(), \"math\");\n        assert_eq!(DataType::Item.as_str(), \"item\");\n        assert_eq!(DataType::Property.as_str(), \"property\");\n        assert_eq!(DataType::MusicalNotation.as_str(), \"musical-notation\");\n        assert_eq!(DataType::EntitySchema.as_str(), \"entity-schema\");\n    }\n}\n","traces":[{"line":32,"address":[],"length":0,"stats":{"Line":9832}},{"line":33,"address":[],"length":0,"stats":{"Line":9832}},{"line":34,"address":[],"length":0,"stats":{"Line":12731}},{"line":35,"address":[],"length":0,"stats":{"Line":10230}},{"line":36,"address":[],"length":0,"stats":{"Line":4417}},{"line":37,"address":[],"length":0,"stats":{"Line":2899}},{"line":38,"address":[],"length":0,"stats":{"Line":3318}},{"line":39,"address":[],"length":0,"stats":{"Line":2377}},{"line":40,"address":[],"length":0,"stats":{"Line":2909}},{"line":41,"address":[],"length":0,"stats":{"Line":2992}},{"line":42,"address":[],"length":0,"stats":{"Line":123}},{"line":43,"address":[],"length":0,"stats":{"Line":201}},{"line":44,"address":[],"length":0,"stats":{"Line":10}},{"line":45,"address":[],"length":0,"stats":{"Line":9}},{"line":46,"address":[],"length":0,"stats":{"Line":8}},{"line":47,"address":[],"length":0,"stats":{"Line":7}},{"line":48,"address":[],"length":0,"stats":{"Line":6}},{"line":49,"address":[],"length":0,"stats":{"Line":5}},{"line":50,"address":[],"length":0,"stats":{"Line":3}},{"line":51,"address":[],"length":0,"stats":{"Line":3}},{"line":52,"address":[],"length":0,"stats":{"Line":4}},{"line":53,"address":[],"length":0,"stats":{"Line":3}},{"line":54,"address":[],"length":0,"stats":{"Line":1}},{"line":59,"address":[],"length":0,"stats":{"Line":3145}},{"line":60,"address":[],"length":0,"stats":{"Line":3145}},{"line":61,"address":[],"length":0,"stats":{"Line":893}},{"line":62,"address":[],"length":0,"stats":{"Line":974}},{"line":63,"address":[],"length":0,"stats":{"Line":275}},{"line":64,"address":[],"length":0,"stats":{"Line":14}},{"line":65,"address":[],"length":0,"stats":{"Line":185}},{"line":66,"address":[],"length":0,"stats":{"Line":26}},{"line":67,"address":[],"length":0,"stats":{"Line":229}},{"line":68,"address":[],"length":0,"stats":{"Line":467}},{"line":69,"address":[],"length":0,"stats":{"Line":5}},{"line":70,"address":[],"length":0,"stats":{"Line":59}},{"line":71,"address":[],"length":0,"stats":{"Line":2}},{"line":72,"address":[],"length":0,"stats":{"Line":2}},{"line":73,"address":[],"length":0,"stats":{"Line":2}},{"line":74,"address":[],"length":0,"stats":{"Line":2}},{"line":75,"address":[],"length":0,"stats":{"Line":2}},{"line":76,"address":[],"length":0,"stats":{"Line":2}},{"line":77,"address":[],"length":0,"stats":{"Line":1}},{"line":78,"address":[],"length":0,"stats":{"Line":1}},{"line":79,"address":[],"length":0,"stats":{"Line":2}},{"line":80,"address":[],"length":0,"stats":{"Line":2}}],"covered":45,"coverable":45},{"path":["/","Users","magnusmanske","rust","wikibase_rest_api","src","description.rs"],"content":"use crate::HttpGetEntityWithFallback;\nuse crate::{\n    get_put_delete::HttpMisc, EditMetadata, EntityId, HeaderInfo, HttpDelete, HttpGet, HttpPut,\n    LanguageString, RestApi, RestApiError, RevisionMatch,\n};\nuse async_trait::async_trait;\nuse derivative::Derivative;\nuse reqwest::Request;\nuse serde_json::json;\nuse std::collections::HashMap;\nuse std::ops::Deref;\n\n#[derive(Derivative, Debug, Clone)]\n#[derivative(PartialEq)]\npub struct Description {\n    ls: LanguageString,\n    #[derivative(PartialEq = \"ignore\")]\n    header_info: HeaderInfo,\n}\n\nimpl Description {\n    /// Constructs a new `Description` object from a language code and a description.\n    pub fn new<S1: Into<String>, S2: Into<String>>(language: S1, value: S2) -> Description {\n        Self {\n            ls: LanguageString::new(language, value),\n            header_info: HeaderInfo::default(),\n        }\n    }\n\n    async fn generate_get_match_request(\n        id: &EntityId,\n        language: &str,\n        api: &RestApi,\n        rm: RevisionMatch,\n        mode: &str,\n    ) -> Result<Request, RestApiError> {\n        let path = format!(\n            \"/entities/{group}/{id}/{mode}/{language}\",\n            group = id.group()?\n        );\n        let mut request = api\n            .wikibase_request_builder(&path, HashMap::new(), reqwest::Method::GET)\n            .await?\n            .build()?;\n        rm.modify_headers(request.headers_mut())?;\n        Ok(request)\n    }\n}\n\nimpl Deref for Description {\n    type Target = LanguageString;\n\n    fn deref(&self) -> &Self::Target {\n        &self.ls\n    }\n}\n\nimpl From<LanguageString> for Description {\n    fn from(ls: LanguageString) -> Self {\n        Self {\n            ls,\n            header_info: HeaderInfo::default(),\n        }\n    }\n}\n\nimpl From<Description> for LanguageString {\n    fn from(val: Description) -> Self {\n        val.ls\n    }\n}\n\nimpl HttpMisc for Description {\n    fn get_my_rest_api_path(&self, id: &EntityId) -> Result<String, RestApiError> {\n        Ok(format!(\n            \"/entities/{group}/{id}/descriptions/{language}\",\n            group = id.group()?,\n            language = self.ls.language()\n        ))\n    }\n}\n\n#[async_trait]\nimpl HttpGetEntityWithFallback for Description {\n    async fn get_match_with_fallback(\n        id: &EntityId,\n        language: &str,\n        api: &RestApi,\n        rm: RevisionMatch,\n    ) -> Result<Self, RestApiError> {\n        let request = Self::generate_get_match_request(\n            id,\n            language,\n            api,\n            rm,\n            \"descriptions_with_language_fallback\",\n        )\n        .await?;\n        let (j, header_info) = Self::api_execute(api, request).await?;\n        let s = j\n            .as_str()\n            .ok_or_else(|| RestApiError::MissingOrInvalidField {\n                field: \"Descriptions\".into(),\n                j: j.to_owned(),\n            })?;\n        Ok(Self {\n            ls: LanguageString::new(language, s),\n            header_info,\n        })\n    }\n}\n\n#[async_trait]\nimpl HttpGet for Description {\n    async fn get_match(\n        id: &EntityId,\n        language: &str,\n        api: &RestApi,\n        rm: RevisionMatch,\n    ) -> Result<Self, RestApiError> {\n        let request =\n            Self::generate_get_match_request(id, language, api, rm, \"descriptions\").await?;\n        let (j, header_info) = Self::api_execute(api, request).await?;\n        let s = j\n            .as_str()\n            .ok_or_else(|| RestApiError::MissingOrInvalidField {\n                field: \"Description\".into(),\n                j: j.to_owned(),\n            })?;\n        Ok(Self {\n            ls: LanguageString::new(language, s),\n            header_info,\n        })\n    }\n}\n\n#[async_trait]\nimpl HttpDelete for Description {\n    async fn delete_meta(\n        &self,\n        id: &EntityId,\n        api: &mut RestApi,\n        em: EditMetadata,\n    ) -> Result<(), RestApiError> {\n        let j = json!({});\n        self.run_json_query(id, reqwest::Method::DELETE, j, api, &em)\n            .await?;\n        Ok(())\n    }\n}\n\n#[async_trait]\nimpl HttpPut for Description {\n    async fn put_meta(\n        &self,\n        id: &EntityId,\n        api: &mut RestApi,\n        em: EditMetadata,\n    ) -> Result<Self, RestApiError> {\n        let j = json!({\"description\": self.ls.value()});\n        let (j, header_info) = self\n            .run_json_query(id, reqwest::Method::PUT, j, api, &em)\n            .await?;\n        let value = j\n            .as_str()\n            .ok_or_else(|| RestApiError::MissingOrInvalidField {\n                field: \"Description\".into(),\n                j: j.to_owned(),\n            })?;\n        let mut ret = Self::new(self.language(), value);\n        ret.header_info = header_info;\n        Ok(ret)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use wiremock::matchers::{bearer_token, body_partial_json, method, path};\n    use wiremock::{Mock, MockServer, ResponseTemplate};\n\n    #[tokio::test]\n    #[cfg_attr(miri, ignore)]\n    async fn test_descriptions_get_match_with_fallback() {\n        let id = \"Q42\";\n        let mock_path = format!(\n            \"/w/rest.php/wikibase/v1/entities/items/{id}/descriptions_with_language_fallback/foo\"\n        );\n        let mock_server = MockServer::start().await;\n        Mock::given(method(\"GET\"))\n            .and(path(&mock_path))\n            .respond_with(ResponseTemplate::new(200).set_body_json(json!(\"Douglas Adams\")))\n            .mount(&mock_server)\n            .await;\n        let api = RestApi::builder(&(mock_server.uri() + \"/w/rest.php\"))\n            .unwrap()\n            .build();\n\n        let id = EntityId::item(id);\n        let description = Description::get_with_fallback(&id, \"foo\", &api)\n            .await\n            .unwrap();\n        assert_eq!(description.language(), \"foo\");\n        assert_eq!(description.value(), \"Douglas Adams\");\n    }\n\n    #[tokio::test]\n    #[cfg_attr(miri, ignore)]\n    async fn test_description_get() {\n        let id = \"Q42\";\n        let mock_description = \"Foo bar baz\";\n        let mock_path = format!(\"/w/rest.php/wikibase/v1/entities/items/{id}/descriptions/en\");\n        let mock_server = MockServer::start().await;\n        Mock::given(method(\"GET\"))\n            .and(path(&mock_path))\n            .respond_with(ResponseTemplate::new(200).set_body_json(mock_description))\n            .mount(&mock_server)\n            .await;\n        let api = RestApi::builder(&(mock_server.uri() + \"/w/rest.php\"))\n            .unwrap()\n            .build();\n\n        let id = EntityId::item(id);\n        let description = Description::get(&id, \"en\", &api).await.unwrap();\n        assert_eq!(description.language(), \"en\");\n        assert_eq!(description.value(), mock_description);\n    }\n\n    #[tokio::test]\n    #[cfg_attr(miri, ignore)]\n    async fn test_description_put() {\n        let description = \"Foo bar baz\";\n        let id = \"Q42\";\n        let mock_path = format!(\"/w/rest.php/wikibase/v1/entities/items/{id}/descriptions/en\");\n        let mock_server = MockServer::start().await;\n        let token = \"FAKE_TOKEN\";\n        Mock::given(body_partial_json(json!({\"description\": description})))\n            .and(method(\"PUT\"))\n            .and(path(&mock_path))\n            .and(bearer_token(token))\n            .respond_with(ResponseTemplate::new(200).set_body_json(json!(description)))\n            .mount(&mock_server)\n            .await;\n        let mut api = RestApi::builder(&(mock_server.uri() + \"/w/rest.php\"))\n            .unwrap()\n            .with_access_token(token)\n            .build();\n\n        let id = EntityId::item(id);\n        let new_description = Description::new(\"en\", description);\n        let return_description = new_description.put(&id, &mut api).await.unwrap();\n        assert_eq!(return_description.language(), \"en\");\n        assert_eq!(return_description.value(), description);\n    }\n\n    #[tokio::test]\n    #[cfg_attr(miri, ignore)]\n    async fn test_description_delete() {\n        let id = \"Q42\";\n        let mock_path = format!(\"/w/rest.php/wikibase/v1/entities/items/{id}/descriptions/en\");\n        let mock_server = MockServer::start().await;\n        let token = \"FAKE_TOKEN\";\n        Mock::given(method(\"DELETE\"))\n            .and(path(&mock_path))\n            .and(bearer_token(token))\n            .respond_with(ResponseTemplate::new(200).set_body_json(json!(\"Description deleted\")))\n            .mount(&mock_server)\n            .await;\n        let mut api = RestApi::builder(&(mock_server.uri() + \"/w/rest.php\"))\n            .unwrap()\n            .with_access_token(token)\n            .build();\n\n        let id = EntityId::item(id);\n        let description = Description::new(\"en\", \"\");\n        let result = description.delete(&id, &mut api).await;\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_from() {\n        let ls = LanguageString::new(\"en\", \"Foo bar baz\");\n        let description = Description::from(ls);\n        assert_eq!(description.language(), \"en\");\n        assert_eq!(description.value(), \"Foo bar baz\");\n    }\n\n    #[test]\n    fn test_into() {\n        let description = Description::new(\"en\", \"Foo bar baz\");\n        let ls: LanguageString = description.into();\n        assert_eq!(ls.language(), \"en\");\n        assert_eq!(ls.value(), \"Foo bar baz\");\n    }\n}\n","traces":[{"line":23,"address":[],"length":0,"stats":{"Line":4}},{"line":25,"address":[],"length":0,"stats":{"Line":4}},{"line":26,"address":[],"length":0,"stats":{"Line":4}},{"line":30,"address":[],"length":0,"stats":{"Line":2}},{"line":37,"address":[],"length":0,"stats":{"Line":2}},{"line":39,"address":[],"length":0,"stats":{"Line":2}},{"line":41,"address":[],"length":0,"stats":{"Line":2}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":2}},{"line":53,"address":[],"length":0,"stats":{"Line":9}},{"line":54,"address":[],"length":0,"stats":{"Line":9}},{"line":59,"address":[],"length":0,"stats":{"Line":1}},{"line":62,"address":[],"length":0,"stats":{"Line":1}},{"line":68,"address":[],"length":0,"stats":{"Line":1}},{"line":69,"address":[],"length":0,"stats":{"Line":1}},{"line":74,"address":[],"length":0,"stats":{"Line":2}},{"line":75,"address":[],"length":0,"stats":{"Line":2}},{"line":76,"address":[],"length":0,"stats":{"Line":2}},{"line":77,"address":[],"length":0,"stats":{"Line":2}},{"line":92,"address":[],"length":0,"stats":{"Line":1}},{"line":93,"address":[],"length":0,"stats":{"Line":1}},{"line":94,"address":[],"length":0,"stats":{"Line":1}},{"line":95,"address":[],"length":0,"stats":{"Line":1}},{"line":98,"address":[],"length":0,"stats":{"Line":1}},{"line":99,"address":[],"length":0,"stats":{"Line":1}},{"line":100,"address":[],"length":0,"stats":{"Line":1}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":1}},{"line":122,"address":[],"length":0,"stats":{"Line":1}},{"line":123,"address":[],"length":0,"stats":{"Line":1}},{"line":124,"address":[],"length":0,"stats":{"Line":1}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":1}},{"line":146,"address":[],"length":0,"stats":{"Line":1}},{"line":147,"address":[],"length":0,"stats":{"Line":1}},{"line":148,"address":[],"length":0,"stats":{"Line":1}},{"line":160,"address":[],"length":0,"stats":{"Line":1}},{"line":161,"address":[],"length":0,"stats":{"Line":2}},{"line":162,"address":[],"length":0,"stats":{"Line":1}},{"line":163,"address":[],"length":0,"stats":{"Line":1}},{"line":164,"address":[],"length":0,"stats":{"Line":1}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}}],"covered":38,"coverable":49},{"path":["/","Users","magnusmanske","rust","wikibase_rest_api","src","descriptions.rs"],"content":"use crate::{\n    language_strings_patch::LanguageStringsPatch, prelude::LanguageStrings, EntityId, FromJson,\n    HeaderInfo, HttpGetEntity, HttpMisc, LanguageString, RestApi, RestApiError, RevisionMatch,\n};\nuse async_trait::async_trait;\nuse derivative::Derivative;\nuse serde::ser::{Serialize, SerializeMap};\nuse serde_json::{json, Value};\nuse std::collections::HashMap;\n\n#[derive(Derivative, Debug, Clone, Default)]\n#[derivative(PartialEq)]\npub struct Descriptions {\n    ls: HashMap<String, String>,\n    #[derivative(PartialEq = \"ignore\")]\n    header_info: HeaderInfo,\n}\n\nimpl Descriptions {\n    /// Returns the value for a language\n    pub fn get_lang<S: Into<String>>(&self, language: S) -> Option<&str> {\n        self.ls.get(&language.into()).map(|s| s.as_str())\n    }\n\n    /// Returns the number of labels/languages\n    pub fn len(&self) -> usize {\n        self.ls.len()\n    }\n\n    /// Returns true if there are no labels/languages\n    pub fn is_empty(&self) -> bool {\n        self.ls.is_empty()\n    }\n\n    /// Generates a patch to transform `other` into `self`\n    pub fn patch(&self, other: &Self) -> Result<LanguageStringsPatch, RestApiError> {\n        let patch = json_patch::diff(&json!(&other), &json!(&self));\n        let patch = LanguageStringsPatch::descriptions_from_json(&json!(patch))?;\n        Ok(patch)\n    }\n}\n\nimpl HttpMisc for Descriptions {\n    fn get_rest_api_path(id: &EntityId) -> Result<String, RestApiError> {\n        Ok(format!(\n            \"/entities/{group}/{id}/descriptions\",\n            group = id.group()?\n        ))\n    }\n}\n\n#[async_trait]\nimpl HttpGetEntity for Descriptions {\n    async fn get_match(\n        id: &EntityId,\n        api: &RestApi,\n        rm: RevisionMatch,\n    ) -> Result<Self, RestApiError> {\n        let path = Self::get_rest_api_path(id)?;\n        let (j, header_info) = Self::get_match_internal(api, &path, rm).await?;\n        Self::from_json_header_info(&j, header_info)\n    }\n}\n\nimpl FromJson for Descriptions {\n    fn header_info(&self) -> &HeaderInfo {\n        &self.header_info\n    }\n\n    fn from_json_header_info(j: &Value, header_info: HeaderInfo) -> Result<Self, RestApiError> {\n        let ls = j\n            .as_object()\n            .ok_or_else(|| RestApiError::WrongType {\n                field: \"Descriptions\".to_string(),\n                j: j.to_owned(),\n            })?\n            .iter()\n            .map(|(language, value)| {\n                let value = value\n                    .as_str()\n                    .ok_or_else(|| RestApiError::MissingOrInvalidField {\n                        field: \"Descriptions\".into(),\n                        j: value.to_owned(),\n                    })?;\n                Ok((language.to_owned(), value.to_string()))\n            })\n            .collect::<Result<HashMap<String, String>, RestApiError>>()?;\n        let ret = Self { ls, header_info };\n        Ok(ret)\n    }\n}\n\nimpl LanguageStrings for Descriptions {\n    fn has_language<S: Into<String>>(&self, language: S) -> bool {\n        self.ls.contains_key(&language.into())\n    }\n\n    fn insert(&mut self, ls: LanguageString) {\n        self.ls\n            .insert(ls.language().to_string(), ls.value().to_string());\n    }\n}\n\nimpl Serialize for Descriptions {\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: serde::Serializer,\n    {\n        let mut s = serializer.serialize_map(Some(self.ls.len()))?;\n        for (language, ls) in &self.ls {\n            s.serialize_entry(language, ls)?;\n        }\n        s.end()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use serde_json::json;\n    use wiremock::matchers::{method, path};\n    use wiremock::{Mock, MockServer, ResponseTemplate};\n\n    #[test]\n    fn test_language_strings_single() {\n        let j = json!({\n            \"en\": \"Hello\",\n            \"de\": \"Hallo\",\n        });\n        let ls = Descriptions::from_json(&j).unwrap();\n        assert_eq!(ls.get_lang(\"en\"), Some(\"Hello\"));\n        assert_eq!(ls.get_lang(\"de\"), Some(\"Hallo\"));\n        assert_eq!(ls.get_lang(\"fr\"), None);\n    }\n\n    #[test]\n    fn test_language_strings_insert() {\n        let mut ls = Descriptions::default();\n        ls.insert(LanguageString::new(\"en\", \"Hello\"));\n        ls.insert(LanguageString::new(\"de\", \"Hallo\"));\n        ls.insert(LanguageString::new(\"en\", \"Hi\"));\n        assert_eq!(ls.get_lang(\"en\"), Some(\"Hi\"));\n        assert_eq!(ls.get_lang(\"de\"), Some(\"Hallo\"));\n    }\n\n    #[tokio::test]\n    #[cfg_attr(miri, ignore)]\n    async fn test_language_strings_single_get() {\n        let v = std::fs::read_to_string(\"test_data/Q42.json\").unwrap();\n        let v: Value = serde_json::from_str(&v).unwrap();\n\n        let mock_path = \"/w/rest.php/wikibase/v1/entities/items/Q42/descriptions\";\n        let mock_server = MockServer::start().await;\n        Mock::given(method(\"GET\"))\n            .and(path(mock_path))\n            .respond_with(ResponseTemplate::new(200).set_body_json(&v[\"descriptions\"]))\n            .mount(&mock_server)\n            .await;\n        let api = RestApi::builder(&(mock_server.uri() + \"/w/rest.php\"))\n            .unwrap()\n            .build();\n\n        let id = EntityId::new(\"Q42\").unwrap();\n        let ls = Descriptions::get(&id, &api).await.unwrap();\n        assert_eq!(ls.get_lang(\"en-gb\"), Some(\"English writer and humourist\"));\n    }\n\n    #[test]\n    fn test_patch_descriptions() {\n        let mut l1 = Descriptions::default();\n        l1.insert(LanguageString::new(\"en\", \"Foo\"));\n        l1.insert(LanguageString::new(\"de\", \"Bar\"));\n        let mut l2 = l1.clone();\n        l2.insert(LanguageString::new(\"en\", \"Baz\"));\n\n        let patch = l2.patch(&l1).unwrap();\n        let patch_json = json!(patch);\n        assert_eq!(\n            patch_json,\n            json!({\"mode\":\"Descriptions\",\"patch\":[{\"op\":\"replace\",\"path\":\"/en\",\"value\":\"Baz\"}]})\n        );\n    }\n\n    #[test]\n    fn test_get_rest_api_path() {\n        let l = Descriptions::default();\n        let id = EntityId::new(\"Q42\").unwrap();\n        assert_eq!(\n            l.get_my_rest_api_path(&id).unwrap(),\n            \"/entities/items/Q42/descriptions\"\n        );\n    }\n\n    #[test]\n    fn test_header_info_single() {\n        let l = Descriptions::default();\n        assert_eq!(l.header_info(), &HeaderInfo::default());\n    }\n\n    #[test]\n    fn test_serialize() {\n        let mut l = Descriptions::default();\n        l.insert(LanguageString::new(\"en\", \"Foo\"));\n        l.insert(LanguageString::new(\"de\", \"Bar\"));\n        let s = serde_json::to_string(&l).unwrap();\n        assert!(s.contains(r#\"\"en\":\"Foo\"\"#));\n        assert!(s.contains(r#\"\"de\":\"Bar\"\"#));\n    }\n\n    #[test]\n    fn test_is_empty() {\n        let mut l = Descriptions::default();\n        assert!(l.is_empty());\n        l.insert(LanguageString::new(\"en\", \"Foo\"));\n        assert!(!l.is_empty());\n    }\n}\n","traces":[{"line":21,"address":[],"length":0,"stats":{"Line":7}},{"line":22,"address":[],"length":0,"stats":{"Line":20}},{"line":26,"address":[],"length":0,"stats":{"Line":4}},{"line":27,"address":[],"length":0,"stats":{"Line":4}},{"line":31,"address":[],"length":0,"stats":{"Line":18}},{"line":32,"address":[],"length":0,"stats":{"Line":18}},{"line":36,"address":[],"length":0,"stats":{"Line":2}},{"line":37,"address":[],"length":0,"stats":{"Line":2}},{"line":38,"address":[],"length":0,"stats":{"Line":4}},{"line":44,"address":[],"length":0,"stats":{"Line":2}},{"line":45,"address":[],"length":0,"stats":{"Line":2}},{"line":46,"address":[],"length":0,"stats":{"Line":2}},{"line":47,"address":[],"length":0,"stats":{"Line":2}},{"line":59,"address":[],"length":0,"stats":{"Line":2}},{"line":60,"address":[],"length":0,"stats":{"Line":1}},{"line":66,"address":[],"length":0,"stats":{"Line":1}},{"line":67,"address":[],"length":0,"stats":{"Line":1}},{"line":70,"address":[],"length":0,"stats":{"Line":17}},{"line":71,"address":[],"length":0,"stats":{"Line":34}},{"line":73,"address":[],"length":0,"stats":{"Line":17}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":1300}},{"line":79,"address":[],"length":0,"stats":{"Line":2566}},{"line":80,"address":[],"length":0,"stats":{"Line":1283}},{"line":81,"address":[],"length":0,"stats":{"Line":1283}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":1}},{"line":95,"address":[],"length":0,"stats":{"Line":1}},{"line":98,"address":[],"length":0,"stats":{"Line":12}},{"line":99,"address":[],"length":0,"stats":{"Line":12}},{"line":100,"address":[],"length":0,"stats":{"Line":12}},{"line":105,"address":[],"length":0,"stats":{"Line":12}},{"line":109,"address":[],"length":0,"stats":{"Line":24}},{"line":110,"address":[],"length":0,"stats":{"Line":1004}},{"line":111,"address":[],"length":0,"stats":{"Line":496}},{"line":113,"address":[],"length":0,"stats":{"Line":12}}],"covered":34,"coverable":38},{"path":["/","Users","magnusmanske","rust","wikibase_rest_api","src","descriptions_patch.rs"],"content":"use crate::{patch_entry::PatchEntry, EntityId, HttpMisc, Patch, RestApiError};\nuse serde::Serialize;\nuse serde_json::Value;\n\n#[derive(Debug, Clone, PartialEq, Serialize, Default)]\npub struct DescriptionsPatch {\n    patch: Vec<PatchEntry>,\n}\n\nimpl DescriptionsPatch {\n    pub fn from_json(j: &Value) -> Result<Vec<PatchEntry>, RestApiError> {\n        j.as_array()\n            .ok_or_else(|| RestApiError::MissingOrInvalidField {\n                field: \"DescriptionsPatch\".into(),\n                j: j.to_owned(),\n            })?\n            .iter()\n            .map(|x| serde_json::from_value(x.clone()).map_err(|e| e.into()))\n            .collect::<Result<Vec<PatchEntry>, RestApiError>>()\n    }\n\n    // TODO add?\n\n    /// Adds a command to replace the value of a language string.\n    pub fn replace<S1: Into<String>, S2: Into<String>>(&mut self, language: S1, value: S2) {\n        <Self as Patch>::replace(self, format!(\"/{}\", language.into()), value.into().into());\n    }\n\n    /// Adds a command to remove the value for the language.\n    pub fn remove<S: Into<String>>(&mut self, language: S) {\n        <Self as Patch>::remove(self, format!(\"/{}\", language.into()));\n    }\n}\n\nimpl Patch for DescriptionsPatch {\n    fn patch(&self) -> &Vec<PatchEntry> {\n        &self.patch\n    }\n\n    fn patch_mut(&mut self) -> &mut Vec<PatchEntry> {\n        &mut self.patch\n    }\n}\n\nimpl HttpMisc for DescriptionsPatch {\n    fn get_my_rest_api_path(&self, id: &EntityId) -> Result<String, RestApiError> {\n        Ok(format!(\n            \"/entities/{group}/{id}/descriptions\",\n            group = id.group()?\n        ))\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use serde_json::{json, Value};\n\n    #[test]\n    fn test_remove() {\n        let mut patch = DescriptionsPatch::default();\n        patch.remove(\"en\");\n        assert_eq!(\n            patch.patch,\n            vec![PatchEntry::new(\"remove\", \"/en\", Value::Null)]\n        );\n    }\n\n    #[test]\n    fn test_patch() {\n        let mut patch = DescriptionsPatch::default();\n        patch.replace(\"en\", \"Foo Bar\");\n        assert_eq!(\n            patch.patch,\n            vec![PatchEntry::new(\"replace\", \"/en\", json!(\"Foo Bar\"))]\n        );\n    }\n\n    #[test]\n    fn test_descriptions() {\n        let mut patch = DescriptionsPatch::default();\n        patch.replace(\"en\", \"Foo Bar\");\n        assert_eq!(\n            patch.patch,\n            vec![PatchEntry::new(\"replace\", \"/en\", json!(\"Foo Bar\"))]\n        );\n    }\n\n    #[test]\n    fn test_patch_fn() {\n        let mut patch = DescriptionsPatch::default();\n        patch.replace(\"en\", \"Foo Bar\");\n        assert_eq!(\n            *<DescriptionsPatch as Patch>::patch(&patch),\n            vec![PatchEntry::new(\"replace\", \"/en\", json!(\"Foo Bar\"))]\n        );\n    }\n\n    #[test]\n    fn test_from_json() {\n        let j = json!([\n            {\"op\": \"replace\", \"path\": \"/en\", \"value\": \"Foo Bar\"},\n            {\"op\": \"remove\", \"path\": \"/de\"}\n        ]);\n        let patch = DescriptionsPatch::from_json(&j).unwrap();\n        assert_eq!(\n            patch,\n            vec![\n                PatchEntry::new(\"replace\", \"/en\", json!(\"Foo Bar\")),\n                PatchEntry::new(\"remove\", \"/de\", Value::Null)\n            ]\n        );\n    }\n\n    #[test]\n    fn test_get_rest_api_path() {\n        let patch = DescriptionsPatch::default();\n        let id = EntityId::new(\"Q123\").unwrap();\n        assert_eq!(\n            patch.get_my_rest_api_path(&id).unwrap(),\n            \"/entities/items/Q123/descriptions\"\n        );\n    }\n}\n","traces":[{"line":11,"address":[],"length":0,"stats":{"Line":1}},{"line":12,"address":[],"length":0,"stats":{"Line":1}},{"line":13,"address":[],"length":0,"stats":{"Line":1}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":5}},{"line":25,"address":[],"length":0,"stats":{"Line":3}},{"line":26,"address":[],"length":0,"stats":{"Line":3}},{"line":30,"address":[],"length":0,"stats":{"Line":1}},{"line":31,"address":[],"length":0,"stats":{"Line":1}},{"line":36,"address":[],"length":0,"stats":{"Line":1}},{"line":37,"address":[],"length":0,"stats":{"Line":1}},{"line":40,"address":[],"length":0,"stats":{"Line":4}},{"line":41,"address":[],"length":0,"stats":{"Line":4}},{"line":46,"address":[],"length":0,"stats":{"Line":1}},{"line":47,"address":[],"length":0,"stats":{"Line":1}},{"line":48,"address":[],"length":0,"stats":{"Line":1}},{"line":49,"address":[],"length":0,"stats":{"Line":1}}],"covered":16,"coverable":18},{"path":["/","Users","magnusmanske","rust","wikibase_rest_api","src","edit_metadata.rs"],"content":"use crate::RevisionMatch;\n\n#[derive(Debug, Clone, Default, PartialEq)]\npub struct EditMetadata {\n    comment: Option<String>,\n    bot: bool,\n    minor: bool,\n    tags: Vec<String>,\n    revision_match: RevisionMatch,\n}\n\nimpl EditMetadata {\n    pub fn comment(&self) -> Option<String> {\n        self.comment.to_owned()\n    }\n\n    pub const fn bot(&self) -> bool {\n        self.bot\n    }\n\n    pub const fn minor(&self) -> bool {\n        self.minor\n    }\n\n    pub fn tags(&self) -> &[String] {\n        &self.tags\n    }\n\n    pub const fn revision_match(&self) -> &RevisionMatch {\n        &self.revision_match\n    }\n\n    pub fn set_comment(&mut self, comment: Option<String>) {\n        self.comment = comment;\n    }\n\n    pub const fn set_bot(&mut self, bot: bool) {\n        self.bot = bot;\n    }\n\n    pub const fn set_minor(&mut self, minor: bool) {\n        self.minor = minor;\n    }\n\n    pub fn set_tags(&mut self, tags: Vec<String>) {\n        self.tags = tags;\n    }\n\n    pub fn set_revision_match(&mut self, revision_match: RevisionMatch) {\n        self.revision_match = revision_match;\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_edit_metadata() {\n        let mut edit_metadata = EditMetadata::default();\n        assert_eq!(edit_metadata.comment(), None);\n        assert!(!edit_metadata.bot());\n        assert!(!edit_metadata.minor());\n        assert!(edit_metadata.tags().is_empty());\n\n        edit_metadata.set_comment(Some(\"Test\".to_string()));\n        assert_eq!(edit_metadata.comment(), Some(\"Test\".to_string()));\n\n        edit_metadata.set_bot(true);\n        assert!(edit_metadata.bot());\n\n        edit_metadata.set_minor(true);\n        assert!(edit_metadata.minor());\n\n        edit_metadata.set_tags(vec![\"Test\".to_string()]);\n        assert_eq!(edit_metadata.tags(), &[\"Test\".to_string()]);\n    }\n\n    #[test]\n    fn test_set_revision_match() {\n        let mut edit_metadata = EditMetadata::default();\n        let mut revision_match = RevisionMatch::default();\n        revision_match.set_modified_since_revisions(vec![1]);\n        edit_metadata.set_revision_match(revision_match.clone());\n        assert_eq!(edit_metadata.revision_match(), &revision_match);\n    }\n}\n","traces":[{"line":13,"address":[],"length":0,"stats":{"Line":20}},{"line":14,"address":[],"length":0,"stats":{"Line":20}},{"line":17,"address":[],"length":0,"stats":{"Line":20}},{"line":18,"address":[],"length":0,"stats":{"Line":20}},{"line":21,"address":[],"length":0,"stats":{"Line":2}},{"line":22,"address":[],"length":0,"stats":{"Line":2}},{"line":25,"address":[],"length":0,"stats":{"Line":20}},{"line":26,"address":[],"length":0,"stats":{"Line":20}},{"line":29,"address":[],"length":0,"stats":{"Line":16}},{"line":30,"address":[],"length":0,"stats":{"Line":16}},{"line":33,"address":[],"length":0,"stats":{"Line":1}},{"line":34,"address":[],"length":0,"stats":{"Line":1}},{"line":37,"address":[],"length":0,"stats":{"Line":1}},{"line":38,"address":[],"length":0,"stats":{"Line":1}},{"line":41,"address":[],"length":0,"stats":{"Line":1}},{"line":42,"address":[],"length":0,"stats":{"Line":1}},{"line":45,"address":[],"length":0,"stats":{"Line":1}},{"line":46,"address":[],"length":0,"stats":{"Line":1}},{"line":49,"address":[],"length":0,"stats":{"Line":1}},{"line":50,"address":[],"length":0,"stats":{"Line":1}}],"covered":20,"coverable":20},{"path":["/","Users","magnusmanske","rust","wikibase_rest_api","src","entity.rs"],"content":"use crate::{EditMetadata, EntityId, HeaderInfo, HttpMisc, RestApi, RestApiError, RevisionMatch};\nuse async_trait::async_trait;\nuse reqwest::{Request, Response};\nuse serde::ser::Serialize;\nuse serde_json::{json, Value};\nuse std::collections::HashMap;\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum EntityType {\n    Item,\n    Property,\n}\n\nimpl EntityType {\n    pub const fn type_name(&self) -> &str {\n        match self {\n            EntityType::Item => \"item\",\n            EntityType::Property => \"property\",\n        }\n    }\n\n    pub const fn group_name(&self) -> &str {\n        match self {\n            EntityType::Item => \"items\",\n            EntityType::Property => \"properties\",\n        }\n    }\n}\n\n#[async_trait]\npub trait Entity: Default + Sized + Serialize + HttpMisc {\n    fn id(&self) -> EntityId;\n    fn from_json_header_info(j: Value, header_info: HeaderInfo) -> Result<Self, RestApiError>;\n\n    fn from_json(j: Value) -> Result<Self, RestApiError> {\n        Self::from_json_header_info(j, HeaderInfo::default())\n    }\n\n    async fn get(id: EntityId, api: &RestApi) -> Result<Self, RestApiError> {\n        Self::get_match(id, api, RevisionMatch::default()).await\n    }\n\n    async fn generate_get_match_request(\n        id: EntityId,\n        api: &RestApi,\n        rm: RevisionMatch,\n    ) -> Result<Request, RestApiError> {\n        let path = format!(\"/entities/{group}/{id}\", group = id.group()?);\n        let mut request = api\n            .wikibase_request_builder(&path, HashMap::new(), reqwest::Method::GET)\n            .await?\n            .build()?;\n        rm.modify_headers(request.headers_mut())?;\n        Ok(request)\n    }\n\n    async fn get_match(\n        id: EntityId,\n        api: &RestApi,\n        rm: RevisionMatch,\n    ) -> Result<Self, RestApiError> {\n        let request = Self::generate_get_match_request(id, api, rm).await?;\n        let response = api.execute(request).await?;\n        if !response.status().is_success() {\n            return Err(RestApiError::from_response(response).await);\n        }\n        let hi = HeaderInfo::from_header(response.headers());\n        let j: Value = response.error_for_status()?.json().await?;\n        let ret = Self::from_json_header_info(j, hi)?;\n        Ok(ret)\n    }\n\n    async fn post(&self, api: &RestApi) -> Result<Self, RestApiError>;\n\n    async fn post_with_type(\n        &self,\n        entity_type: EntityType,\n        api: &RestApi,\n    ) -> Result<Self, RestApiError> {\n        self.post_with_type_and_metadata(entity_type, api, EditMetadata::default())\n            .await\n    }\n\n    async fn build_post_with_type_and_metadata_request(\n        &self,\n        entity_type: EntityType,\n        path: &str,\n        api: &RestApi,\n        em: EditMetadata,\n    ) -> Result<reqwest::Request, RestApiError> {\n        let mut request = api\n            .wikibase_request_builder(path, HashMap::new(), reqwest::Method::POST)\n            .await?\n            .build()?;\n        let mut j: Value = json!({entity_type.type_name(): self});\n        Self::add_metadata_to_json(&mut j, &em);\n        *request.body_mut() = Some(format!(\"{j}\").into());\n        Ok(request)\n    }\n\n    async fn check_post_with_type_and_metadata_response(\n        path: &str,\n        response: Response,\n    ) -> Result<Response, RestApiError> {\n        if response.status().is_success() {\n            return Ok(response);\n        }\n        let status_code = response.status();\n        if status_code == 404 {\n            return Err(RestApiError::NotImplementedInRestApi {\n                method: reqwest::Method::POST,\n                path: path.to_string(),\n            });\n        }\n        Err(RestApiError::from_response(response).await)\n    }\n\n    async fn post_with_type_and_metadata(\n        &self,\n        entity_type: EntityType,\n        api: &RestApi,\n        em: EditMetadata,\n    ) -> Result<Self, RestApiError> {\n        if self.id().is_some() {\n            return Err(RestApiError::HasId);\n        }\n        let path = format!(\"/entities/{group}\", group = entity_type.group_name());\n        let request = self\n            .build_post_with_type_and_metadata_request(entity_type, &path, api, em)\n            .await?;\n        let response = api.execute(request).await?;\n        let response = Self::check_post_with_type_and_metadata_response(&path, response).await?;\n\n        let j: Value = response.json().await?;\n        // TODO return entire entity? Check if it's the same as this one?\n        let ret = Self::from_json(j)?;\n        Ok(ret)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_entity_type() {\n        assert_eq!(EntityType::Item.type_name(), \"item\");\n        assert_eq!(EntityType::Property.type_name(), \"property\");\n        assert_eq!(EntityType::Item.group_name(), \"items\");\n        assert_eq!(EntityType::Property.group_name(), \"properties\");\n    }\n}\n","traces":[{"line":15,"address":[],"length":0,"stats":{"Line":5}},{"line":16,"address":[],"length":0,"stats":{"Line":5}},{"line":17,"address":[],"length":0,"stats":{"Line":3}},{"line":18,"address":[],"length":0,"stats":{"Line":2}},{"line":22,"address":[],"length":0,"stats":{"Line":8}},{"line":23,"address":[],"length":0,"stats":{"Line":8}},{"line":24,"address":[],"length":0,"stats":{"Line":5}},{"line":25,"address":[],"length":0,"stats":{"Line":3}},{"line":35,"address":[],"length":0,"stats":{"Line":6}},{"line":36,"address":[],"length":0,"stats":{"Line":6}},{"line":39,"address":[],"length":0,"stats":{"Line":11}},{"line":40,"address":[],"length":0,"stats":{"Line":11}},{"line":43,"address":[],"length":0,"stats":{"Line":11}},{"line":48,"address":[],"length":0,"stats":{"Line":22}},{"line":49,"address":[],"length":0,"stats":{"Line":11}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":11}},{"line":62,"address":[],"length":0,"stats":{"Line":22}},{"line":63,"address":[],"length":0,"stats":{"Line":11}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":2}},{"line":67,"address":[],"length":0,"stats":{"Line":9}},{"line":68,"address":[],"length":0,"stats":{"Line":27}},{"line":69,"address":[],"length":0,"stats":{"Line":9}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":5}},{"line":81,"address":[],"length":0,"stats":{"Line":5}},{"line":91,"address":[],"length":0,"stats":{"Line":6}},{"line":92,"address":[],"length":0,"stats":{"Line":3}},{"line":93,"address":[],"length":0,"stats":{"Line":3}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":3}},{"line":105,"address":[],"length":0,"stats":{"Line":3}},{"line":106,"address":[],"length":0,"stats":{"Line":2}},{"line":108,"address":[],"length":0,"stats":{"Line":1}},{"line":109,"address":[],"length":0,"stats":{"Line":1}},{"line":110,"address":[],"length":0,"stats":{"Line":1}},{"line":111,"address":[],"length":0,"stats":{"Line":1}},{"line":112,"address":[],"length":0,"stats":{"Line":1}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":5}},{"line":125,"address":[],"length":0,"stats":{"Line":2}},{"line":127,"address":[],"length":0,"stats":{"Line":3}},{"line":128,"address":[],"length":0,"stats":{"Line":3}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":3}},{"line":132,"address":[],"length":0,"stats":{"Line":3}},{"line":134,"address":[],"length":0,"stats":{"Line":2}},{"line":136,"address":[],"length":0,"stats":{"Line":2}},{"line":137,"address":[],"length":0,"stats":{"Line":0}}],"covered":43,"coverable":56},{"path":["/","Users","magnusmanske","rust","wikibase_rest_api","src","entity_container.rs"],"content":"use crate::{entity::Entity, EntityId, Item, Property, RestApi, RestApiError};\nuse futures::prelude::*;\nuse std::{collections::HashMap, sync::Arc};\nuse tokio::sync::RwLock;\n\nconst MAX_CONCURRENT_LOAD_DEFAULT: usize = 10;\n\n#[derive(Debug, Clone)]\npub struct EntityContainer {\n    api: Arc<RestApi>,\n    items: Arc<RwLock<HashMap<String, Item>>>,\n    properties: Arc<RwLock<HashMap<String, Property>>>,\n    max_concurrent_load: usize,\n}\n\nimpl EntityContainer {\n    /// Returns a new `EntityContainerBuilder` to configure a new `EntityContainer`.\n    pub fn builder() -> EntityContainerBuilder {\n        EntityContainerBuilder::default()\n    }\n\n    /// Loads the entities with the given `EntityId`s into the container.\n    pub async fn load(&self, entity_ids: &[EntityId]) -> Result<(), RestApiError> {\n        let mut items = self.items.write().await;\n        let item_ids = Self::get_items_to_load(&items, entity_ids);\n        self.load_items(&mut items, &item_ids).await?;\n        drop(items);\n\n        let mut properties = self.properties.write().await;\n        let property_ids = Self::get_properties_to_load(&properties, entity_ids);\n        self.load_properties(&mut properties, &property_ids).await?;\n        drop(properties);\n\n        Ok(())\n    }\n\n    fn get_items_to_load(items: &HashMap<String, Item>, entity_ids: &[EntityId]) -> Vec<String> {\n        entity_ids\n            .iter()\n            .filter_map(|id| match id {\n                EntityId::Item(id) => Some(id.to_owned()),\n                _ => None,\n            })\n            .filter(|id| !items.contains_key(id))\n            .collect()\n    }\n\n    async fn load_items(\n        &self,\n        items: &mut HashMap<String, Item>,\n        item_ids: &[String],\n    ) -> Result<(), RestApiError> {\n        if item_ids.is_empty() {\n            return Ok(());\n        }\n        let futures = item_ids\n            .iter()\n            .map(|id| Item::get(EntityId::item(id), &self.api))\n            .collect::<Vec<_>>();\n        let stream = futures::stream::iter(futures).buffer_unordered(self.max_concurrent_load);\n        let results = stream.collect::<Vec<_>>().await;\n        let results = results\n            .into_iter()\n            .collect::<Vec<Result<Item, RestApiError>>>();\n        for item in results.into_iter().flatten() {\n            let id = item.id().id()?.to_owned();\n            items.insert(id, item);\n        }\n        Ok(())\n    }\n\n    fn get_properties_to_load(\n        properties: &HashMap<String, Property>,\n        entity_ids: &[EntityId],\n    ) -> Vec<String> {\n        entity_ids\n            .iter()\n            .filter_map(|id| match id {\n                EntityId::Property(id) => Some(id.to_owned()),\n                _ => None,\n            })\n            .filter(|id| !properties.contains_key(id))\n            .collect()\n    }\n\n    async fn load_properties(\n        &self,\n        properties: &mut HashMap<String, Property>,\n        property_ids: &[String],\n    ) -> Result<(), RestApiError> {\n        if property_ids.is_empty() {\n            return Ok(());\n        }\n        let futures = property_ids\n            .iter()\n            .map(|id| Property::get(EntityId::property(id), &self.api))\n            .collect::<Vec<_>>();\n        let stream = futures::stream::iter(futures).buffer_unordered(self.max_concurrent_load);\n        let results = stream.collect::<Vec<_>>().await;\n        let results = results\n            .into_iter()\n            .collect::<Vec<Result<Property, RestApiError>>>();\n        for property in results.into_iter().flatten() {\n            let id = property.id().id()?.to_owned();\n            properties.insert(id, property);\n        }\n        Ok(())\n    }\n\n    /// Returns a reference to the items in the container.\n    pub fn items(&self) -> Arc<RwLock<HashMap<String, Item>>> {\n        self.items.clone()\n    }\n\n    /// Returns a reference to the properties in the container.\n    pub fn properties(&self) -> Arc<RwLock<HashMap<String, Property>>> {\n        self.properties.clone()\n    }\n}\n\n#[derive(Debug, Default)]\npub struct EntityContainerBuilder {\n    api: Option<Arc<RestApi>>,\n    max_concurrent_load: usize,\n}\n\nimpl EntityContainerBuilder {\n    /// Sets the `RestApi` to use for loading entities. **Mandatory**\n    pub fn api(mut self, api: Arc<RestApi>) -> Self {\n        self.api = Some(api);\n        self\n    }\n\n    /// Sets the maximum number of concurrent loads to perform. Default is 10.\n    pub const fn max_concurrent(mut self, max_concurrent_load: usize) -> Self {\n        self.max_concurrent_load = max_concurrent_load;\n        self\n    }\n\n    /// Builds a new `EntityContainer` with the configured options.\n    pub fn build(self) -> Result<EntityContainer, RestApiError> {\n        let api = self.api.ok_or_else(|| RestApiError::ApiNotSet)?;\n        let mut max_concurrent_load = self.max_concurrent_load;\n        if max_concurrent_load == 0 {\n            max_concurrent_load = MAX_CONCURRENT_LOAD_DEFAULT;\n        }\n        Ok(EntityContainer {\n            api,\n            items: Arc::new(RwLock::new(HashMap::new())),\n            properties: Arc::new(RwLock::new(HashMap::new())),\n            max_concurrent_load,\n        })\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::RestApi;\n    use serde_json::Value;\n    use wiremock::matchers::{method, path};\n    use wiremock::{Mock, MockServer, ResponseTemplate};\n\n    #[tokio::test]\n    #[cfg_attr(miri, ignore)]\n    async fn test_entity_container() {\n        // #lizard forgives the complexity\n        let q42_str = std::fs::read_to_string(\"test_data/Q42.json\").unwrap();\n        let q42: Value = serde_json::from_str(&q42_str).unwrap();\n        let q255_str = std::fs::read_to_string(\"test_data/Q255.json\").unwrap();\n        let q255: Value = serde_json::from_str(&q255_str).unwrap();\n        let p214_str = std::fs::read_to_string(\"test_data/P214.json\").unwrap();\n        let p214: Value = serde_json::from_str(&p214_str).unwrap();\n\n        let mock_server = MockServer::start().await;\n        Mock::given(method(\"GET\"))\n            .and(path(\"/w/rest.php/wikibase/v1/entities/items/Q42\"))\n            .respond_with(ResponseTemplate::new(200).set_body_json(&q42))\n            .mount(&mock_server)\n            .await;\n        Mock::given(method(\"GET\"))\n            .and(path(\"/w/rest.php/wikibase/v1/entities/items/Q255\"))\n            .respond_with(ResponseTemplate::new(200).set_body_json(&q255))\n            .mount(&mock_server)\n            .await;\n        Mock::given(method(\"GET\"))\n            .and(path(\"/w/rest.php/wikibase/v1/entities/properties/P214\"))\n            .respond_with(ResponseTemplate::new(200).set_body_json(&p214))\n            .mount(&mock_server)\n            .await;\n        let api = RestApi::builder(&(mock_server.uri() + \"/w/rest.php\"))\n            .unwrap()\n            .build();\n\n        let ec = EntityContainer::builder()\n            .api(Arc::new(api))\n            .build()\n            .unwrap();\n        ec.load(&[\n            EntityId::item(\"Q42\"),\n            EntityId::property(\"P214\"),\n            EntityId::item(\"Q255\"),\n        ])\n        .await\n        .unwrap();\n        assert!(ec.items().read().await.contains_key(\"Q42\"));\n        assert!(ec.items().read().await.contains_key(\"Q255\"));\n        assert!(ec.properties().read().await.contains_key(\"P214\"));\n        assert!(!ec.properties().read().await.contains_key(\"Q42\"));\n        assert!(!ec.items().read().await.contains_key(\"P214\"));\n    }\n\n    #[test]\n    #[cfg_attr(miri, ignore)] // TODO this should work in miri\n    fn test_max_concurrent() {\n        let api = Arc::new(\n            RestApi::builder(\"https://test.wikidata.org/w/rest.php\")\n                .unwrap()\n                .build(),\n        );\n        let ec = EntityContainer::builder()\n            .api(api.clone())\n            .max_concurrent(5)\n            .build()\n            .unwrap();\n        assert_eq!(ec.max_concurrent_load, 5);\n    }\n\n    #[test]\n    #[cfg_attr(miri, ignore)] // TODO this should work in miri\n    fn test_max_concurrent_default() {\n        let api = Arc::new(\n            RestApi::builder(\"https://test.wikidata.org/w/rest.php\")\n                .unwrap()\n                .build(),\n        );\n        let ec = EntityContainer::builder()\n            .api(api.clone())\n            .max_concurrent(0)\n            .build()\n            .unwrap();\n        assert_eq!(ec.max_concurrent_load, MAX_CONCURRENT_LOAD_DEFAULT);\n    }\n}\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":3}},{"line":19,"address":[],"length":0,"stats":{"Line":3}},{"line":23,"address":[],"length":0,"stats":{"Line":2}},{"line":24,"address":[],"length":0,"stats":{"Line":2}},{"line":25,"address":[],"length":0,"stats":{"Line":1}},{"line":26,"address":[],"length":0,"stats":{"Line":1}},{"line":27,"address":[],"length":0,"stats":{"Line":1}},{"line":29,"address":[],"length":0,"stats":{"Line":1}},{"line":30,"address":[],"length":0,"stats":{"Line":1}},{"line":31,"address":[],"length":0,"stats":{"Line":1}},{"line":32,"address":[],"length":0,"stats":{"Line":1}},{"line":34,"address":[],"length":0,"stats":{"Line":1}},{"line":37,"address":[],"length":0,"stats":{"Line":1}},{"line":38,"address":[],"length":0,"stats":{"Line":1}},{"line":40,"address":[],"length":0,"stats":{"Line":4}},{"line":41,"address":[],"length":0,"stats":{"Line":2}},{"line":42,"address":[],"length":0,"stats":{"Line":1}},{"line":44,"address":[],"length":0,"stats":{"Line":4}},{"line":48,"address":[],"length":0,"stats":{"Line":1}},{"line":53,"address":[],"length":0,"stats":{"Line":1}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":1}},{"line":58,"address":[],"length":0,"stats":{"Line":3}},{"line":61,"address":[],"length":0,"stats":{"Line":1}},{"line":62,"address":[],"length":0,"stats":{"Line":1}},{"line":65,"address":[],"length":0,"stats":{"Line":3}},{"line":66,"address":[],"length":0,"stats":{"Line":4}},{"line":69,"address":[],"length":0,"stats":{"Line":1}},{"line":72,"address":[],"length":0,"stats":{"Line":1}},{"line":76,"address":[],"length":0,"stats":{"Line":1}},{"line":78,"address":[],"length":0,"stats":{"Line":4}},{"line":79,"address":[],"length":0,"stats":{"Line":1}},{"line":80,"address":[],"length":0,"stats":{"Line":2}},{"line":82,"address":[],"length":0,"stats":{"Line":3}},{"line":86,"address":[],"length":0,"stats":{"Line":1}},{"line":91,"address":[],"length":0,"stats":{"Line":1}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":1}},{"line":96,"address":[],"length":0,"stats":{"Line":2}},{"line":99,"address":[],"length":0,"stats":{"Line":1}},{"line":100,"address":[],"length":0,"stats":{"Line":1}},{"line":103,"address":[],"length":0,"stats":{"Line":2}},{"line":104,"address":[],"length":0,"stats":{"Line":2}},{"line":107,"address":[],"length":0,"stats":{"Line":1}},{"line":111,"address":[],"length":0,"stats":{"Line":3}},{"line":112,"address":[],"length":0,"stats":{"Line":3}},{"line":116,"address":[],"length":0,"stats":{"Line":2}},{"line":117,"address":[],"length":0,"stats":{"Line":2}},{"line":129,"address":[],"length":0,"stats":{"Line":3}},{"line":130,"address":[],"length":0,"stats":{"Line":3}},{"line":131,"address":[],"length":0,"stats":{"Line":3}},{"line":135,"address":[],"length":0,"stats":{"Line":2}},{"line":136,"address":[],"length":0,"stats":{"Line":2}},{"line":137,"address":[],"length":0,"stats":{"Line":2}},{"line":141,"address":[],"length":0,"stats":{"Line":3}},{"line":142,"address":[],"length":0,"stats":{"Line":9}},{"line":144,"address":[],"length":0,"stats":{"Line":2}},{"line":145,"address":[],"length":0,"stats":{"Line":2}}],"covered":56,"coverable":58},{"path":["/","Users","magnusmanske","rust","wikibase_rest_api","src","entity_id.rs"],"content":"use std::fmt;\n\nuse crate::{config::WIKIDATA_CONFIG, Config, RestApiError};\n\n#[derive(Debug, Clone, Default, PartialEq)]\npub enum EntityId {\n    #[default]\n    None,\n    Item(String),\n    Property(String),\n}\n\nimpl EntityId {\n    /// Returns the ID of the entity.\n    pub const fn id(&self) -> Result<&String, RestApiError> {\n        match self {\n            EntityId::None => Err(RestApiError::IsNone),\n            EntityId::Item(id) => Ok(id),\n            EntityId::Property(id) => Ok(id),\n        }\n    }\n\n    /// Returns the group of the entity.\n    pub const fn group(&self) -> Result<&str, RestApiError> {\n        match self {\n            EntityId::Item(_) => Ok(\"items\"),\n            EntityId::Property(_) => Ok(\"properties\"),\n            _ => Err(RestApiError::IsNone),\n        }\n    }\n\n    /// Returns the entity type of the entity.\n    pub const fn entity_type(&self) -> Result<&str, RestApiError> {\n        match self {\n            EntityId::Item(_) => Ok(\"item\"),\n            EntityId::Property(_) => Ok(\"property\"),\n            _ => Err(RestApiError::IsNone),\n        }\n    }\n\n    /// Creates a new entity ID from a string, using the default Wikidata configuration.\n    pub fn new<S: Into<String>>(id: S) -> Result<EntityId, RestApiError> {\n        Self::new_from_config(id, &WIKIDATA_CONFIG)\n    }\n\n    /// Creates a new entity ID from a string, using a bespoke configuration.\n    pub fn new_from_config<S: Into<String>>(\n        id: S,\n        config: &Config,\n    ) -> Result<EntityId, RestApiError> {\n        let id = id.into();\n        if id.starts_with(config.item_letter()) {\n            Ok(EntityId::Item(id.to_string()))\n        } else if id.starts_with(config.property_letter()) {\n            Ok(EntityId::Property(id.to_string()))\n        } else {\n            Err(RestApiError::UnknownEntityLetter(id))\n        }\n    }\n\n    /// Returns an unset (None) entity ID.\n    pub const fn none() -> EntityId {\n        EntityId::None\n    }\n\n    /// Returns a new entity ID for an item.\n    pub fn item<S: Into<String>>(s: S) -> EntityId {\n        EntityId::Item(s.into())\n    }\n\n    /// Returns a new entity ID for a property.\n    pub fn property(s: &str) -> EntityId {\n        EntityId::Property(s.to_string())\n    }\n\n    /// Returns true if the entity ID is an item or a property.\n    pub fn is_some(&self) -> bool {\n        *self != EntityId::None\n    }\n\n    /// Returns true if the entity ID is unset (None).\n    pub fn is_none(&self) -> bool {\n        *self == EntityId::None\n    }\n}\n\nimpl From<EntityId> for String {\n    fn from(val: EntityId) -> Self {\n        match val {\n            EntityId::Item(id) => id.to_string(),\n            EntityId::Property(id) => id.to_string(),\n            EntityId::None => String::new(),\n        }\n    }\n}\n\nimpl fmt::Display for EntityId {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match self {\n            EntityId::Item(id) => write!(f, \"{}\", id),\n            EntityId::Property(id) => write!(f, \"{}\", id),\n            EntityId::None => Err(fmt::Error),\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_entity_id_item() {\n        let id = EntityId::item(\"Q123\");\n        assert_eq!(id, EntityId::item(\"Q123\"));\n    }\n\n    #[test]\n    fn test_entity_id_property() {\n        let id = EntityId::property(\"P123\");\n        assert_eq!(id, EntityId::property(\"P123\"));\n    }\n\n    #[test]\n    fn test_entity_id_none() {\n        let id = EntityId::none();\n        assert_eq!(id, EntityId::None);\n    }\n\n    #[test]\n    fn test_entity_id_item_is_some() {\n        let id = EntityId::item(\"Q123\");\n        assert!(id.is_some());\n    }\n\n    #[test]\n    fn test_entity_id_property_is_some() {\n        let id = EntityId::property(\"P123\");\n        assert!(id.is_some());\n    }\n\n    #[test]\n    fn test_entity_id_none_is_some() {\n        let id = EntityId::none();\n        assert!(!id.is_some());\n    }\n\n    #[test]\n    fn test_entity_id_item_is_none() {\n        let id = EntityId::item(\"Q123\");\n        assert!(!id.is_none());\n    }\n\n    #[test]\n    fn test_entity_id_property_is_none() {\n        let id = EntityId::property(\"P123\");\n        assert!(!id.is_none());\n    }\n\n    #[test]\n    fn test_entity_id_none_is_none() {\n        let id = EntityId::none();\n        assert!(id.is_none());\n    }\n\n    #[test]\n    fn test_entity_id_default() {\n        let id = EntityId::default();\n        assert_eq!(id, EntityId::None);\n    }\n\n    #[test]\n    fn test_entity_id_item_id() {\n        let id = EntityId::item(\"Q123\");\n        assert_eq!(id.id().unwrap(), \"Q123\");\n    }\n\n    #[test]\n    fn test_entity_id_property_id() {\n        let id = EntityId::property(\"P123\");\n        assert_eq!(id.id().unwrap(), \"P123\");\n    }\n\n    #[test]\n    fn test_entity_id_none_id() {\n        let id = EntityId::none();\n        assert!(id.id().is_err());\n    }\n\n    #[test]\n    fn test_entity_id_item_group() {\n        let id = EntityId::item(\"Q123\");\n        assert_eq!(id.group().unwrap(), \"items\");\n    }\n\n    #[test]\n    fn test_entity_id_property_group() {\n        let id = EntityId::property(\"P123\");\n        assert_eq!(id.group().unwrap(), \"properties\");\n    }\n\n    #[test]\n    fn test_entity_id_none_group() {\n        let id = EntityId::none();\n        assert!(id.group().is_err());\n    }\n\n    #[test]\n    fn test_entity_id_entity_item_type() {\n        let id = EntityId::item(\"Q123\");\n        assert_eq!(id.entity_type().unwrap(), \"item\");\n    }\n\n    #[test]\n    fn test_entity_id_entity_property_type() {\n        let id = EntityId::property(\"P123\");\n        assert_eq!(id.entity_type().unwrap(), \"property\");\n    }\n\n    #[test]\n    fn test_entity_id_entity_none_type() {\n        let id = EntityId::none();\n        assert!(id.entity_type().is_err());\n    }\n\n    #[test]\n    fn test_entity_id_item_new() {\n        let id = EntityId::new(\"Q123\").unwrap();\n        assert_eq!(id, EntityId::item(\"Q123\"));\n    }\n\n    #[test]\n    fn test_entity_id_property_new() {\n        let id = EntityId::new(\"P123\").unwrap();\n        assert_eq!(id, EntityId::property(\"P123\"));\n    }\n\n    #[test]\n    fn test_entity_id_none_new() {\n        let id = EntityId::new(\"X123\");\n        assert!(id.is_err());\n    }\n\n    #[test]\n    fn test_entity_id_new_from_config() {\n        let config = Config::new('A', 'B');\n        let id_a = EntityId::new_from_config(\"A123\", &config).unwrap();\n        assert_eq!(id_a, EntityId::item(\"A123\"));\n        let id_b = EntityId::new_from_config(\"B123\", &config).unwrap();\n        assert_eq!(id_b, EntityId::property(\"B123\"));\n        let id_x = EntityId::new_from_config(\"X123\", &config);\n        assert!(id_x.is_err());\n    }\n}\n","traces":[{"line":15,"address":[],"length":0,"stats":{"Line":6}},{"line":16,"address":[],"length":0,"stats":{"Line":6}},{"line":17,"address":[],"length":0,"stats":{"Line":1}},{"line":18,"address":[],"length":0,"stats":{"Line":3}},{"line":19,"address":[],"length":0,"stats":{"Line":2}},{"line":24,"address":[],"length":0,"stats":{"Line":48}},{"line":25,"address":[],"length":0,"stats":{"Line":48}},{"line":26,"address":[],"length":0,"stats":{"Line":43}},{"line":27,"address":[],"length":0,"stats":{"Line":4}},{"line":28,"address":[],"length":0,"stats":{"Line":1}},{"line":33,"address":[],"length":0,"stats":{"Line":3}},{"line":34,"address":[],"length":0,"stats":{"Line":3}},{"line":35,"address":[],"length":0,"stats":{"Line":1}},{"line":36,"address":[],"length":0,"stats":{"Line":1}},{"line":37,"address":[],"length":0,"stats":{"Line":1}},{"line":42,"address":[],"length":0,"stats":{"Line":16}},{"line":43,"address":[],"length":0,"stats":{"Line":16}},{"line":47,"address":[],"length":0,"stats":{"Line":19}},{"line":51,"address":[],"length":0,"stats":{"Line":19}},{"line":52,"address":[],"length":0,"stats":{"Line":19}},{"line":53,"address":[],"length":0,"stats":{"Line":14}},{"line":54,"address":[],"length":0,"stats":{"Line":5}},{"line":55,"address":[],"length":0,"stats":{"Line":3}},{"line":57,"address":[],"length":0,"stats":{"Line":2}},{"line":62,"address":[],"length":0,"stats":{"Line":6}},{"line":63,"address":[],"length":0,"stats":{"Line":6}},{"line":67,"address":[],"length":0,"stats":{"Line":42}},{"line":68,"address":[],"length":0,"stats":{"Line":42}},{"line":72,"address":[],"length":0,"stats":{"Line":21}},{"line":73,"address":[],"length":0,"stats":{"Line":21}},{"line":77,"address":[],"length":0,"stats":{"Line":24}},{"line":78,"address":[],"length":0,"stats":{"Line":24}},{"line":82,"address":[],"length":0,"stats":{"Line":3}},{"line":83,"address":[],"length":0,"stats":{"Line":3}},{"line":88,"address":[],"length":0,"stats":{"Line":5}},{"line":89,"address":[],"length":0,"stats":{"Line":5}},{"line":90,"address":[],"length":0,"stats":{"Line":2}},{"line":91,"address":[],"length":0,"stats":{"Line":3}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":46}},{"line":99,"address":[],"length":0,"stats":{"Line":46}},{"line":100,"address":[],"length":0,"stats":{"Line":43}},{"line":101,"address":[],"length":0,"stats":{"Line":3}},{"line":102,"address":[],"length":0,"stats":{"Line":0}}],"covered":42,"coverable":44},{"path":["/","Users","magnusmanske","rust","wikibase_rest_api","src","entity_patch.rs"],"content":"/// NOTE: THIS IS INCOMPLETE AND UNTESTED!\nuse crate::{\n    entity::Entity, patch_entry::PatchEntry, EditMetadata, EntityId, HttpMisc, Item, Property,\n    RestApi, RestApiError,\n};\nuse serde::Serialize;\nuse serde_json::json;\n\n#[derive(Debug, Clone, PartialEq, Serialize)]\nenum Mode {\n    Item,\n    Property,\n}\n\nimpl Mode {\n    const fn as_str(&self) -> &str {\n        match self {\n            Mode::Item => \"item\",\n            Mode::Property => \"property\",\n        }\n    }\n}\n\n#[derive(Debug, Clone, PartialEq, Serialize)]\npub struct EntityPatch {\n    patch: Vec<PatchEntry>,\n    mode: Mode,\n}\n\nimpl EntityPatch {\n    pub const fn item() -> Self {\n        Self {\n            patch: vec![],\n            mode: Mode::Item,\n        }\n    }\n\n    pub const fn property() -> Self {\n        Self {\n            patch: vec![],\n            mode: Mode::Property,\n        }\n    }\n    /* DO WE NEED THIS?\n       /// Generates a patch from JSON, presumably from `json_patch`\n       pub fn item_from_json(j: &Value) -> Result<Self, RestApiError> {\n           Ok(Self {\n               patch: Self::patch_from_json(j)?,\n               mode: Mode::Item,\n           })\n       }\n\n       /// Generates a patch from JSON, presumably from `json_patch`\n       pub fn property_from_json(j: &Value) -> Result<Self, RestApiError> {\n           Ok(Self {\n               patch: Self::patch_from_json(j)?,\n               mode: Mode::Property,\n           })\n       }\n\n       fn patch_from_json(j: &Value) -> Result<Vec<PatchEntry>, RestApiError> {\n           j.as_array()\n               .ok_or_else(|| RestApiError::MissingOrInvalidField {\n                   field: \"EntityPatch\".into(),\n                   j: j.to_owned(),\n               })?\n               .iter()\n               .map(|x| serde_json::from_value(x.clone()).map_err(|e| e.into()))\n               .collect::<Result<Vec<PatchEntry>, RestApiError>>()\n       }\n    */\n    /// Returns the patch entries\n    pub const fn patch(&self) -> &Vec<PatchEntry> {\n        &self.patch\n    }\n\n    /// Returns the mutable patch entries\n    pub const fn patch_mut(&mut self) -> &mut Vec<PatchEntry> {\n        &mut self.patch\n    }\n\n    // /// `path` is a JSON patch path, eg \"/enwiki/title\"\n    // pub fn add<S: Into<String>>(&mut self, path: S, value: Value) {\n    //     self.patch_mut()\n    //         .push(PatchEntry::new(\"add\", path.into(), value));\n    // }\n\n    // /// `path` is a JSON patch path, eg \"/enwiki/title\"\n    // pub fn replace<S: Into<String>>(&mut self, path: S, value: Value) {\n    //     self.patch_mut()\n    //         .push(PatchEntry::new(\"replace\", path.into(), value));\n    // }\n\n    // /// `path` is a JSON patch path, eg \"/enwiki/title\"\n    // pub fn remove<S: Into<String>>(&mut self, path: S) {\n    //     self.patch_mut()\n    //         .push(PatchEntry::new(\"remove\", path.into(), Value::Null));\n    // }\n\n    /// checks if the patch list is empty\n    pub fn is_empty(&self) -> bool {\n        self.patch().is_empty()\n    }\n\n    /// Applies the entire patch against the API\n    pub async fn apply_item(&self, id: &EntityId, api: &mut RestApi) -> Result<Item, RestApiError> {\n        self.apply_match_item(id, api, EditMetadata::default())\n            .await\n    }\n\n    pub async fn apply_property(\n        &self,\n        id: &EntityId,\n        api: &mut RestApi,\n    ) -> Result<Property, RestApiError> {\n        self.apply_match_property(id, api, EditMetadata::default())\n            .await\n    }\n\n    /// Applies the entire patch against the API\n    pub async fn apply_match_item(\n        &self,\n        id: &EntityId,\n        api: &mut RestApi,\n        em: EditMetadata,\n    ) -> Result<Item, RestApiError> {\n        let j0 = json!({\"patch\": self.patch()});\n        let request = self\n            .generate_json_request(id, reqwest::Method::PATCH, j0, api, &em)\n            .await?;\n        let response = api.execute(request).await?;\n        let (j1, header_info) = self.filter_response_error(response).await?;\n        Item::from_json_header_info(j1, header_info)\n    }\n\n    /// Applies the entire patch against the API, conditional on metadata\n    pub async fn apply_match_property(\n        // TODO\n        &self,\n        id: &EntityId,\n        api: &mut RestApi,\n        em: EditMetadata,\n    ) -> Result<Property, RestApiError> {\n        let j0 = json!({\"patch\": self.patch()});\n        let request = self\n            .generate_json_request(id, reqwest::Method::PATCH, j0, api, &em)\n            .await?;\n        let response = api.execute(request).await?;\n        let (j1, header_info) = self.filter_response_error(response).await?;\n        Property::from_json_header_info(j1, header_info)\n    }\n}\n\nimpl HttpMisc for EntityPatch {\n    fn get_my_rest_api_path(&self, id: &EntityId) -> Result<String, RestApiError> {\n        Ok(format!(\n            \"/entities/{group}/{id}/{mode}\",\n            group = id.group()?,\n            mode = self.mode.as_str()\n        ))\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use serde_json::json;\n\n    #[test]\n    fn test_mode() {\n        assert_eq!(Mode::Item.as_str(), \"item\");\n        assert_eq!(Mode::Property.as_str(), \"property\");\n    }\n\n    #[test]\n    fn test_get_rest_api_path() {\n        let patch = EntityPatch::item();\n        let id = EntityId::new(\"Q123\").unwrap();\n        assert_eq!(\n            patch.get_my_rest_api_path(&id).unwrap(),\n            \"/entities/items/Q123/item\"\n        );\n    }\n\n    #[test]\n    fn test_item() {\n        let patch = EntityPatch::item();\n        assert!(patch.is_empty());\n        assert_eq!(patch.mode, Mode::Item);\n    }\n\n    #[test]\n    fn test_property() {\n        let patch = EntityPatch::property();\n        assert!(patch.is_empty());\n        assert_eq!(patch.mode, Mode::Property);\n    }\n\n    #[test]\n    fn test_patch() {\n        let mut patch = EntityPatch::item();\n        assert!(patch.is_empty());\n        patch\n            .patch_mut()\n            .push(PatchEntry::new(\"add\", \"/enwiki/title\", json!(\"foo\")));\n        assert_eq!(patch.patch().len(), 1);\n    }\n\n    #[test]\n    fn test_is_empty() {\n        let mut patch = EntityPatch::item();\n        assert!(patch.is_empty());\n        patch\n            .patch_mut()\n            .push(PatchEntry::new(\"add\", \"/enwiki/title\", json!(\"foo\")));\n        assert!(!patch.is_empty());\n    }\n}\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":3}},{"line":17,"address":[],"length":0,"stats":{"Line":3}},{"line":18,"address":[],"length":0,"stats":{"Line":2}},{"line":19,"address":[],"length":0,"stats":{"Line":1}},{"line":31,"address":[],"length":0,"stats":{"Line":5}},{"line":33,"address":[],"length":0,"stats":{"Line":5}},{"line":38,"address":[],"length":0,"stats":{"Line":1}},{"line":40,"address":[],"length":0,"stats":{"Line":1}},{"line":73,"address":[],"length":0,"stats":{"Line":7}},{"line":74,"address":[],"length":0,"stats":{"Line":7}},{"line":78,"address":[],"length":0,"stats":{"Line":7}},{"line":79,"address":[],"length":0,"stats":{"Line":7}},{"line":101,"address":[],"length":0,"stats":{"Line":5}},{"line":102,"address":[],"length":0,"stats":{"Line":5}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":1}},{"line":156,"address":[],"length":0,"stats":{"Line":1}},{"line":157,"address":[],"length":0,"stats":{"Line":1}},{"line":158,"address":[],"length":0,"stats":{"Line":1}}],"covered":18,"coverable":40},{"path":["/","Users","magnusmanske","rust","wikibase_rest_api","src","error.rs"],"content":"use reqwest::header::InvalidHeaderValue;\nuse serde::Deserialize;\nuse serde_json::{json, Value};\nuse std::{\n    collections::HashMap,\n    fmt::{self, Display, Formatter},\n};\nuse thiserror::Error;\n\n#[derive(Debug, Clone, Deserialize, Default, PartialEq)]\npub struct RestApiErrorPayload {\n    code: String,\n    message: String,\n    #[serde(default)]\n    context: HashMap<String, Value>,\n}\n\nimpl RestApiErrorPayload {\n    pub fn code(&self) -> &str {\n        &self.code\n    }\n\n    pub fn message(&self) -> &str {\n        &self.message\n    }\n\n    pub const fn context(&self) -> &HashMap<String, Value> {\n        &self.context\n    }\n}\n\nimpl Display for RestApiErrorPayload {\n    fn fmt(&self, f: &mut Formatter) -> fmt::Result {\n        write!(\n            f,\n            \"{}: {} / {}\",\n            self.code,\n            self.message,\n            json!(self.context)\n        )\n    }\n}\n\n#[derive(Error, Debug)]\npub enum RestApiError {\n    #[error(\"ApiError: {status} {status_text} / {payload:?}\")]\n    ApiError {\n        status: reqwest::StatusCode,\n        status_text: String,\n        payload: RestApiErrorPayload,\n    },\n    #[error(\"Client ID required\")]\n    ClientIdRequired,\n    #[error(\"Client secret required\")]\n    ClientSecretRequired,\n    #[error(\"Refresh token required\")]\n    RefreshTokenRequired,\n    #[error(\"Access token required\")]\n    AccessTokenRequired,\n    #[error(\"Reqwest Error: {0}\")]\n    Reqwest(reqwest::Error),\n    #[error(\"Invalid header value: {0}\")]\n    InvalidHeaderValue(InvalidHeaderValue),\n    #[error(\"Method {method} not implemented for path {path} in REST API\")]\n    NotImplementedInRestApi {\n        method: reqwest::Method,\n        path: String,\n    },\n    #[error(\"Unexpected response: {0}\")]\n    UnexpectedResponse(Value),\n    #[error(\"Missing ID\")]\n    MissingId,\n    #[error(\"ID already set\")]\n    HasId,\n    #[error(\"Missing field {field}: {j}\")]\n    MissingOrInvalidField { field: String, j: Value },\n    #[error(\"Wrong type for {field}: {j}\")]\n    WrongType { field: String, j: Value },\n    #[error(\"Entity ID is None\")]\n    IsNone,\n    #[error(\"Unrecognized entity ID letter: {0}\")]\n    UnknownEntityLetter(String),\n    #[error(\"Unknown value: {0}\")]\n    UnknownValue(String),\n    #[error(\"Unknown data type: {0}\")]\n    UnknownDataType(String),\n    #[error(\"Serde JSON error: {0}\")]\n    SerdeJson(serde_json::Error),\n    #[error(\"Unknown statement rank: {0}\")]\n    UnknownStatementRank(String),\n    #[error(\"API not set\")]\n    ApiNotSet,\n    #[error(\"Empty value: {0}\")]\n    EmptyValue(String),\n    #[error(\"Unsupported method: {0}\")]\n    UnsupportedMethod(reqwest::Method),\n    #[error(\"REST API URL is invalid: {0}\")]\n    RestApiUrlInvalid(String),\n    #[error(\"Invalid precision\")]\n    InvalidPrecision,\n    #[error(\"Missing results field in response\")]\n    MissingResults,\n}\n\nimpl From<reqwest::Error> for RestApiError {\n    fn from(e: reqwest::Error) -> Self {\n        Self::Reqwest(e)\n    }\n}\n\nimpl From<InvalidHeaderValue> for RestApiError {\n    fn from(e: InvalidHeaderValue) -> Self {\n        Self::InvalidHeaderValue(e)\n    }\n}\n\nimpl From<serde_json::Error> for RestApiError {\n    fn from(e: serde_json::Error) -> Self {\n        Self::SerdeJson(e)\n    }\n}\n\nimpl RestApiError {\n    pub async fn from_response(response: reqwest::Response) -> Self {\n        let status = response.status();\n        let status_text = status.canonical_reason().unwrap_or_default().to_owned();\n        let payload = response\n            .json()\n            .await\n            .unwrap_or(RestApiErrorPayload::default());\n        RestApiError::ApiError {\n            status,\n            status_text,\n            payload,\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::HeaderValue;\n    use serde_json::json;\n\n    #[test]\n    fn test_rest_api_error_payload() {\n        let payload = RestApiErrorPayload {\n            code: \"code\".to_owned(),\n            message: \"message\".to_owned(),\n            context: [(\"key\".to_owned(), json!(\"value\"))]\n                .iter()\n                .cloned()\n                .collect(),\n        };\n        assert_eq!(payload.code(), \"code\");\n        assert_eq!(payload.message(), \"message\");\n        assert_eq!(payload.context().get(\"key\").unwrap(), &json!(\"value\"));\n    }\n\n    #[test]\n    fn test_rest_api_error_display() {\n        let payload = RestApiErrorPayload {\n            code: \"code\".to_owned(),\n            message: \"message\".to_owned(),\n            context: [(\"key\".to_owned(), json!(\"value\"))]\n                .iter()\n                .cloned()\n                .collect(),\n        };\n        let error = RestApiError::ApiError {\n            status: reqwest::StatusCode::BAD_REQUEST,\n            status_text: \"Bad Request\".to_owned(),\n            payload,\n        };\n        assert_eq!(\n            error.to_string(),\n            \"ApiError: 400 Bad Request Bad Request / RestApiErrorPayload { code: \\\"code\\\", message: \\\"message\\\", context: {\\\"key\\\": String(\\\"value\\\")} }\"\n        );\n    }\n\n    #[tokio::test]\n    #[cfg_attr(miri, ignore)]\n    async fn test_error_reqwest() {\n        let error = reqwest::get(\"not a url\").await.unwrap_err();\n        let rest_api_error: RestApiError = error.into();\n        assert_eq!(rest_api_error.to_string(), \"Reqwest Error: builder error\");\n    }\n\n    #[test]\n    fn test_invalid_header_value() {\n        let error = HeaderValue::from_str(\"\\u{0}\").unwrap_err();\n        let rest_api_error: RestApiError = error.into();\n        assert_eq!(\n            rest_api_error.to_string(),\n            \"Invalid header value: failed to parse header value\"\n        );\n    }\n\n    #[test]\n    fn test_payload_code() {\n        let payload = RestApiErrorPayload {\n            code: \"code\".to_owned(),\n            message: \"message\".to_owned(),\n            context: HashMap::new(),\n        };\n        assert_eq!(payload.code(), \"code\");\n    }\n\n    #[test]\n    fn test_payload_message() {\n        let payload = RestApiErrorPayload {\n            code: \"code\".to_owned(),\n            message: \"message\".to_owned(),\n            context: HashMap::new(),\n        };\n        assert_eq!(payload.message(), \"message\");\n    }\n\n    #[test]\n    fn test_payload_context() {\n        let payload = RestApiErrorPayload {\n            code: \"code\".to_owned(),\n            message: \"message\".to_owned(),\n            context: [(\"key\".to_owned(), json!(\"value\"))]\n                .iter()\n                .cloned()\n                .collect(),\n        };\n        assert_eq!(payload.context().get(\"key\").unwrap(), &json!(\"value\"));\n    }\n\n    #[test]\n    fn test_payload_fmt() {\n        let payload = RestApiErrorPayload {\n            code: \"code\".to_owned(),\n            message: \"message\".to_owned(),\n            context: [(\"key\".to_owned(), json!(\"value\"))]\n                .iter()\n                .cloned()\n                .collect(),\n        };\n        let s = format!(\"{payload}\");\n        assert_eq!(s, \"code: message / {\\\"key\\\":\\\"value\\\"}\");\n    }\n\n    #[test]\n    fn test_from_serde_json_error() {\n        let error = serde_json::from_str::<Value>(\"{\").unwrap_err();\n        let rest_api_error: RestApiError = error.into();\n        assert_eq!(\n            rest_api_error.to_string(),\n            \"Serde JSON error: EOF while parsing an object at line 1 column 1\"\n        );\n    }\n}\n","traces":[{"line":19,"address":[],"length":0,"stats":{"Line":4}},{"line":20,"address":[],"length":0,"stats":{"Line":4}},{"line":23,"address":[],"length":0,"stats":{"Line":4}},{"line":24,"address":[],"length":0,"stats":{"Line":4}},{"line":27,"address":[],"length":0,"stats":{"Line":4}},{"line":28,"address":[],"length":0,"stats":{"Line":4}},{"line":33,"address":[],"length":0,"stats":{"Line":1}},{"line":34,"address":[],"length":0,"stats":{"Line":1}},{"line":35,"address":[],"length":0,"stats":{"Line":1}},{"line":37,"address":[],"length":0,"stats":{"Line":1}},{"line":38,"address":[],"length":0,"stats":{"Line":1}},{"line":39,"address":[],"length":0,"stats":{"Line":1}},{"line":106,"address":[],"length":0,"stats":{"Line":2}},{"line":107,"address":[],"length":0,"stats":{"Line":2}},{"line":112,"address":[],"length":0,"stats":{"Line":1}},{"line":113,"address":[],"length":0,"stats":{"Line":1}},{"line":118,"address":[],"length":0,"stats":{"Line":1}},{"line":119,"address":[],"length":0,"stats":{"Line":1}},{"line":124,"address":[],"length":0,"stats":{"Line":6}},{"line":125,"address":[],"length":0,"stats":{"Line":3}},{"line":126,"address":[],"length":0,"stats":{"Line":3}},{"line":127,"address":[],"length":0,"stats":{"Line":6}},{"line":129,"address":[],"length":0,"stats":{"Line":3}}],"covered":23,"coverable":23},{"path":["/","Users","magnusmanske","rust","wikibase_rest_api","src","get_put_delete.rs"],"content":"use crate::{prelude::RestApiError, EditMetadata, EntityId, HeaderInfo, RestApi, RevisionMatch};\nuse async_trait::async_trait;\nuse reqwest::Request;\nuse serde_json::{json, Value};\nuse std::collections::HashMap;\n\n#[async_trait]\npub trait HttpMisc {\n    fn get_my_rest_api_path(&self, id: &EntityId) -> Result<String, RestApiError> {\n        Self::get_rest_api_path(id)\n    }\n\n    fn get_rest_api_path(id: &EntityId) -> Result<String, RestApiError> {\n        panic!(\n            \"{}::get_rest_api_path is not implemented but was used for {id}\",\n            std::any::type_name::<Self>()\n        );\n    }\n\n    fn add_metadata_to_json(j: &mut Value, em: &EditMetadata) {\n        if j.get(\"tags\").is_none() {\n            j[\"tags\"] = json!(em.tags());\n        }\n        if j.get(\"bot\").is_none() {\n            j[\"bot\"] = json!(em.bot());\n        }\n        if j.get(\"comment\").is_none() {\n            j[\"comment\"] = json!(em.comment().unwrap_or_default());\n        }\n    }\n\n    async fn get_match_internal(\n        api: &RestApi,\n        path: &str,\n        rm: RevisionMatch,\n    ) -> Result<(Value, HeaderInfo), RestApiError> {\n        let mut request = api\n            .wikibase_request_builder(path, HashMap::new(), reqwest::Method::GET)\n            .await?\n            .build()?;\n        rm.modify_headers(request.headers_mut())?;\n        Self::api_execute(api, request).await\n    }\n\n    async fn api_execute(\n        api: &RestApi,\n        request: Request,\n    ) -> Result<(Value, HeaderInfo), RestApiError> {\n        let response = api.execute(request).await?;\n        let header_info = HeaderInfo::from_header(response.headers());\n        let j = response.error_for_status()?.json().await?;\n        Ok((j, header_info))\n    }\n\n    async fn run_json_query(\n        &self,\n        id: &EntityId,\n        method: reqwest::Method,\n        j: Value,\n        api: &mut RestApi,\n        em: &EditMetadata,\n    ) -> Result<(Value, HeaderInfo), RestApiError> {\n        let request = self.generate_json_request(id, method, j, api, em).await?;\n        let response = api.execute(request).await?;\n        self.filter_response_error(response).await\n    }\n\n    async fn generate_json_request(\n        &self,\n        id: &EntityId,\n        method: reqwest::Method,\n        mut j: Value,\n        api: &mut RestApi,\n        em: &EditMetadata,\n    ) -> Result<reqwest::Request, RestApiError> {\n        Self::add_metadata_to_json(&mut j, em);\n        let path = self.get_my_rest_api_path(id)?;\n        let content_type = match method {\n            reqwest::Method::PATCH => \"application/json-patch+json\",\n            _ => \"application/json\",\n        }\n        .parse()?;\n        let mut request = api\n            .wikibase_request_builder(&path, HashMap::new(), method)\n            .await?\n            .build()?;\n        request\n            .headers_mut()\n            .insert(reqwest::header::CONTENT_TYPE, content_type);\n        em.revision_match().modify_headers(request.headers_mut())?;\n        *request.body_mut() = Some(format!(\"{j}\").into());\n        Ok(request)\n    }\n\n    async fn filter_response_error(\n        &self,\n        response: reqwest::Response,\n    ) -> Result<(Value, HeaderInfo), RestApiError> {\n        if !response.status().is_success() {\n            return Err(RestApiError::from_response(response).await);\n        }\n        let header_info = HeaderInfo::from_header(response.headers());\n        let j: Value = response.error_for_status()?.json().await?;\n        Ok((j, header_info))\n    }\n}\n\n/// A trait implementing a HTTP GET operation.\n#[async_trait]\npub trait HttpGet: Sized + HttpMisc {\n    async fn get_match(\n        id: &EntityId,\n        part_id: &str,\n        api: &RestApi,\n        rm: RevisionMatch,\n    ) -> Result<Self, RestApiError>;\n\n    async fn get(id: &EntityId, part_id: &str, api: &RestApi) -> Result<Self, RestApiError> {\n        Self::get_match(id, part_id, api, RevisionMatch::default()).await\n    }\n}\n\n/// A trait implementing a HTTP PUT operation.\n#[async_trait]\npub trait HttpPut: Sized + HttpMisc {\n    async fn put_meta(\n        &self,\n        id: &EntityId,\n        api: &mut RestApi,\n        em: EditMetadata,\n    ) -> Result<Self, RestApiError>;\n\n    async fn put(&self, id: &EntityId, api: &mut RestApi) -> Result<Self, RestApiError> {\n        self.put_meta(id, api, EditMetadata::default()).await\n    }\n}\n\n/// A trait implementing a HTTP DELETE operation.\n#[async_trait]\npub trait HttpDelete: Sized + HttpMisc {\n    async fn delete_meta(\n        &self,\n        id: &EntityId,\n        api: &mut RestApi,\n        em: EditMetadata,\n    ) -> Result<(), RestApiError>;\n\n    async fn delete(&self, id: &EntityId, api: &mut RestApi) -> Result<(), RestApiError> {\n        self.delete_meta(id, api, EditMetadata::default()).await\n    }\n}\n\n#[async_trait]\npub trait HttpGetEntity: Sized + HttpMisc {\n    async fn get_match(\n        id: &EntityId,\n        api: &RestApi,\n        rm: RevisionMatch,\n    ) -> Result<Self, RestApiError>\n    where\n        Self: Sized;\n\n    async fn get(id: &EntityId, api: &RestApi) -> Result<Self, RestApiError>\n    where\n        Self: Sized,\n    {\n        Self::get_match(id, api, RevisionMatch::default()).await\n    }\n}\n\n#[async_trait]\npub trait HttpGetEntityWithFallback: Sized + HttpMisc {\n    async fn get_match_with_fallback(\n        id: &EntityId,\n        language: &str,\n        api: &RestApi,\n        rm: RevisionMatch,\n    ) -> Result<Self, RestApiError>;\n\n    async fn get_with_fallback(\n        id: &EntityId,\n        language: &str,\n        api: &RestApi,\n    ) -> Result<Self, RestApiError>\n    where\n        Self: Sized,\n    {\n        Self::get_match_with_fallback(id, language, api, RevisionMatch::default()).await\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::Sitelinks;\n\n    use super::*;\n\n    #[tokio::test]\n    #[cfg_attr(miri, ignore)]\n    async fn test_filter_response_error() {\n        let sl = Sitelinks::default();\n        let response = reqwest::Response::from(http::Response::new(\"body text\"));\n        let result = sl.filter_response_error(response).await;\n        assert!(result.is_err());\n    }\n\n    #[tokio::test]\n    #[cfg_attr(miri, ignore)]\n    async fn test_filter_response_error2() {\n        let sl = Sitelinks::default();\n        let response = reqwest::Response::from(\n            http::Response::builder()\n                .status(400)\n                .body(r#\"{\"code\":\"foo\",\"message\":\"bar\"}\"#)\n                .unwrap(),\n        );\n        let result = sl.filter_response_error(response).await;\n        assert!(result.is_err());\n        assert_eq!(\n            result.unwrap_err().to_string(),\n            \"ApiError: 400 Bad Request Bad Request / RestApiErrorPayload { code: \\\"foo\\\", message: \\\"bar\\\", context: {} }\"\n        );\n    }\n}\n","traces":[{"line":9,"address":[],"length":0,"stats":{"Line":3}},{"line":10,"address":[],"length":0,"stats":{"Line":3}},{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":18}},{"line":21,"address":[],"length":0,"stats":{"Line":36}},{"line":22,"address":[],"length":0,"stats":{"Line":18}},{"line":24,"address":[],"length":0,"stats":{"Line":36}},{"line":25,"address":[],"length":0,"stats":{"Line":18}},{"line":27,"address":[],"length":0,"stats":{"Line":36}},{"line":28,"address":[],"length":0,"stats":{"Line":18}},{"line":37,"address":[],"length":0,"stats":{"Line":18}},{"line":38,"address":[],"length":0,"stats":{"Line":9}},{"line":39,"address":[],"length":0,"stats":{"Line":9}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":9}},{"line":45,"address":[],"length":0,"stats":{"Line":13}},{"line":49,"address":[],"length":0,"stats":{"Line":26}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":26}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":14}},{"line":64,"address":[],"length":0,"stats":{"Line":7}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":15}},{"line":77,"address":[],"length":0,"stats":{"Line":30}},{"line":78,"address":[],"length":0,"stats":{"Line":15}},{"line":79,"address":[],"length":0,"stats":{"Line":4}},{"line":80,"address":[],"length":0,"stats":{"Line":11}},{"line":83,"address":[],"length":0,"stats":{"Line":15}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":15}},{"line":92,"address":[],"length":0,"stats":{"Line":15}},{"line":99,"address":[],"length":0,"stats":{"Line":14}},{"line":100,"address":[],"length":0,"stats":{"Line":1}},{"line":102,"address":[],"length":0,"stats":{"Line":13}},{"line":103,"address":[],"length":0,"stats":{"Line":39}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":6}},{"line":119,"address":[],"length":0,"stats":{"Line":6}},{"line":133,"address":[],"length":0,"stats":{"Line":3}},{"line":134,"address":[],"length":0,"stats":{"Line":3}},{"line":148,"address":[],"length":0,"stats":{"Line":3}},{"line":149,"address":[],"length":0,"stats":{"Line":3}},{"line":167,"address":[],"length":0,"stats":{"Line":6}},{"line":188,"address":[],"length":0,"stats":{"Line":2}}],"covered":38,"coverable":52},{"path":["/","Users","magnusmanske","rust","wikibase_rest_api","src","header_info.rs"],"content":"#[derive(Debug, Clone, Default, PartialEq, Copy)]\npub struct HeaderInfo {\n    revision_id: Option<u64>,\n    last_modified: Option<chrono::DateTime<chrono::Utc>>,\n}\n\nimpl HeaderInfo {\n    /// Constructs a new `HeaderInfo` object from a `HeaderMap` (from a `reqwest::Response`).\n    pub fn from_header(header: &reqwest::header::HeaderMap) -> Self {\n        let revision_id = header\n            .get(\"ETag\")\n            .and_then(|v| v.to_str().ok())\n            .and_then(|s| s.replace('\"', \"\").parse::<u64>().ok());\n        let last_modified = header\n            .get(\"Last-Modified\")\n            .and_then(|v| v.to_str().ok())\n            .and_then(|s| chrono::DateTime::parse_from_rfc2822(s).ok())\n            .map(|dt| dt.to_utc());\n        Self {\n            revision_id,\n            last_modified,\n        }\n    }\n\n    /// Returns the revision ID.\n    pub const fn revision_id(&self) -> Option<u64> {\n        self.revision_id\n    }\n\n    /// Returns the last modified date.\n    pub const fn last_modified(&self) -> Option<&chrono::DateTime<chrono::Utc>> {\n        self.last_modified.as_ref()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::HeaderValue;\n    use reqwest::header::HeaderMap;\n\n    #[test]\n    fn test_header_info() {\n        let mut headers = HeaderMap::new();\n        headers.insert(\"ETag\", HeaderValue::from_str(\"1234567890\").unwrap());\n        headers.insert(\n            \"Last-Modified\",\n            HeaderValue::from_str(\"Wed, 21 Oct 2015 07:28:00 GMT\").unwrap(),\n        );\n        let hi = HeaderInfo::from_header(&headers);\n        assert_eq!(hi.revision_id(), Some(1234567890));\n        assert_eq!(\n            hi.last_modified().unwrap().to_rfc2822(),\n            \"Wed, 21 Oct 2015 07:28:00 +0000\"\n        );\n    }\n}\n","traces":[{"line":9,"address":[],"length":0,"stats":{"Line":42}},{"line":10,"address":[],"length":0,"stats":{"Line":42}},{"line":12,"address":[],"length":0,"stats":{"Line":92}},{"line":13,"address":[],"length":0,"stats":{"Line":92}},{"line":14,"address":[],"length":0,"stats":{"Line":42}},{"line":16,"address":[],"length":0,"stats":{"Line":86}},{"line":17,"address":[],"length":0,"stats":{"Line":86}},{"line":18,"address":[],"length":0,"stats":{"Line":86}},{"line":26,"address":[],"length":0,"stats":{"Line":2}},{"line":27,"address":[],"length":0,"stats":{"Line":2}},{"line":31,"address":[],"length":0,"stats":{"Line":1}},{"line":32,"address":[],"length":0,"stats":{"Line":1}}],"covered":12,"coverable":12},{"path":["/","Users","magnusmanske","rust","wikibase_rest_api","src","item.rs"],"content":"use crate::{\n    aliases::Aliases,\n    aliases_in_language::AliasesInLanguage,\n    descriptions::Descriptions,\n    entity::{Entity, EntityType},\n    entity_patch::EntityPatch,\n    labels::Labels,\n    sitelinks::Sitelinks,\n    statements::Statements,\n    EntityId, FromJson, HeaderInfo, HttpMisc, Patch, RestApi, RestApiError,\n};\nuse async_trait::async_trait;\nuse derivative::Derivative;\nuse serde::ser::{Serialize, SerializeStruct, Serializer};\nuse serde_json::Value;\n\n#[derive(Derivative, Debug, Clone, Default)]\n#[derivative(PartialEq)]\npub struct Item {\n    id: EntityId,\n    labels: Labels,\n    descriptions: Descriptions,\n    aliases: Aliases,\n    sitelinks: Sitelinks,\n    statements: Statements,\n    #[derivative(PartialEq = \"ignore\")]\n    header_info: HeaderInfo,\n}\n\nimpl HttpMisc for Item {\n    fn get_my_rest_api_path(&self, id: &EntityId) -> Result<String, RestApiError> {\n        Ok(format!(\"/entities/{}/{id}\", id.group()?))\n    }\n}\n\n#[async_trait]\nimpl Entity for Item {\n    fn id(&self) -> EntityId {\n        self.id.to_owned()\n    }\n\n    fn from_json_header_info(j: Value, header_info: HeaderInfo) -> Result<Self, RestApiError> {\n        let id = j[\"id\"]\n            .as_str()\n            .ok_or(RestApiError::MissingOrInvalidField {\n                field: \"id\".into(),\n                j: j.to_owned(),\n            })?\n            .to_string();\n        Ok(Self {\n            id: EntityId::Item(id),\n            labels: Labels::from_json(&j[\"labels\"])?,\n            descriptions: Descriptions::from_json(&j[\"descriptions\"])?,\n            aliases: Aliases::from_json(&j[\"aliases\"])?,\n            sitelinks: Sitelinks::from_json(&j[\"sitelinks\"])?,\n            statements: Statements::from_json(&j[\"statements\"])?,\n            header_info,\n        })\n    }\n\n    async fn post(&self, api: &RestApi) -> Result<Self, RestApiError> {\n        self.post_with_type(EntityType::Item, api).await\n    }\n}\n\nimpl Serialize for Item {\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: Serializer,\n    {\n        // #lizard forgives the complexity\n        let mut fields = 5;\n        if self.id.is_some() {\n            fields += 1;\n        }\n        if self.labels.is_empty() {\n            fields -= 1;\n        }\n        if self.descriptions.is_empty() {\n            fields -= 1;\n        }\n        if self.aliases.is_empty() {\n            fields -= 1;\n        }\n        if self.sitelinks.is_empty() {\n            fields -= 1;\n        }\n        if self.statements.is_empty() {\n            fields -= 1;\n        }\n        let mut s = serializer.serialize_struct(\"Item\", fields)?;\n        if self.id.is_some() {\n            let id: String = self.id.to_owned().into();\n            s.serialize_field(\"id\", &id)?;\n        }\n        if !self.labels.is_empty() {\n            s.serialize_field(\"labels\", &self.labels)?;\n        }\n        if !self.descriptions.is_empty() {\n            s.serialize_field(\"descriptions\", &self.descriptions)?;\n        }\n        if !self.aliases.is_empty() {\n            s.serialize_field(\"aliases\", &self.aliases)?;\n        }\n        if !self.sitelinks.is_empty() {\n            s.serialize_field(\"sitelinks\", &self.sitelinks)?;\n        }\n        if !self.statements.is_empty() {\n            s.serialize_field(\"statements\", &self.statements)?;\n        }\n        s.end()\n    }\n}\n\nimpl Item {\n    /// Returns the statements of the item.\n    pub const fn statements(&self) -> &Statements {\n        &self.statements\n    }\n\n    /// Returns the statements of the item (mutable).\n    pub const fn statements_mut(&mut self) -> &mut Statements {\n        &mut self.statements\n    }\n\n    /// Returns the labels of the item.\n    pub const fn labels(&self) -> &Labels {\n        &self.labels\n    }\n\n    /// Returns the labels of the item (mutable).\n    pub const fn labels_mut(&mut self) -> &mut Labels {\n        &mut self.labels\n    }\n\n    /// Returns the descriptions of the item.\n    pub const fn descriptions(&self) -> &Descriptions {\n        &self.descriptions\n    }\n\n    /// Returns the descriptions of the item (mutable).\n    pub const fn descriptions_mut(&mut self) -> &mut Descriptions {\n        &mut self.descriptions\n    }\n\n    /// Returns the aliases of the item.\n    pub const fn aliases(&self) -> &Aliases {\n        &self.aliases\n    }\n\n    /// Returns the aliases of the item (mutable).\n    pub const fn aliases_mut(&mut self) -> &mut Aliases {\n        &mut self.aliases\n    }\n\n    /// Returns the aliases of the item as an `Aliases` object.\n    pub fn as_aliases<S: Into<String>>(&self, lang: S) -> AliasesInLanguage {\n        let lang: String = lang.into();\n        let v: Vec<String> = self\n            .aliases\n            .get_lang(&lang)\n            .iter()\n            .map(|x| x.to_string())\n            .collect();\n        AliasesInLanguage::new(lang, v)\n    }\n\n    /// Returns the sitelinks of the item.\n    pub const fn sitelinks(&self) -> &Sitelinks {\n        &self.sitelinks\n    }\n\n    /// Returns the sitelinks of the item (mutable).\n    pub const fn sitelinks_mut(&mut self) -> &mut Sitelinks {\n        &mut self.sitelinks\n    }\n\n    /// Returns the header information of the item.\n    pub const fn header_info(&self) -> &HeaderInfo {\n        &self.header_info\n    }\n\n    /// Generates a patch to transform `other` into `self`\n    pub fn patch(&self, other: &Self) -> Result<EntityPatch, RestApiError> {\n        let labels_patch = self.labels.patch(other.labels())?;\n        let descriptions_patch = self.descriptions.patch(other.descriptions())?;\n        let aliases_patch = self.aliases.patch(other.aliases())?;\n        let sitelinks_patch = self.sitelinks.patch(other.sitelinks())?;\n        let statements_patch = self.statements.patch(other.statements())?;\n\n        let mut ret = EntityPatch::item();\n        ret.patch_mut().extend(labels_patch.patch().to_owned());\n        ret.patch_mut()\n            .extend(descriptions_patch.patch().to_owned());\n        ret.patch_mut().extend(aliases_patch.patch().to_owned());\n        ret.patch_mut().extend(sitelinks_patch.patch().to_owned());\n        ret.patch_mut().extend(statements_patch.patch().to_owned());\n\n        Ok(ret)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::language_strings::LanguageStrings;\n    use crate::{LanguageString, RestApi, Sitelink, Statement};\n    use serde_json::json;\n    use wiremock::matchers::{body_partial_json, method, path};\n    use wiremock::{Mock, MockServer, ResponseTemplate};\n\n    async fn get_test_item(id: &str) -> Result<Item, RestApiError> {\n        let v = std::fs::read_to_string(\"test_data/Q42.json\").unwrap();\n        let v: Value = serde_json::from_str(&v).unwrap();\n\n        let mock_server = MockServer::start().await;\n        Mock::given(method(\"GET\"))\n            .and(path(\"/w/rest.php/wikibase/v1/entities/items/Q42\"))\n            .respond_with(ResponseTemplate::new(200).set_body_json(&v))\n            .mount(&mock_server)\n            .await;\n        Mock::given(method(\"GET\"))\n            .and(path(\"/w/rest.php/wikibase/v1/entities/items/Q0\"))\n            .respond_with(ResponseTemplate::new(400).set_body_json(\n                json!({\"code\": \"invalid-item-id\",\"message\": \"Not a valid item ID: Q0\"}),\n            ))\n            .mount(&mock_server)\n            .await;\n        Mock::given(method(\"GET\"))\n            .and(path(\"/w/rest.php/wikibase/v1/entities/items/Q6\"))\n            .respond_with(ResponseTemplate::new(404).set_body_json(json!({\"code\": \"item-not-found\",\"message\": \"Could not find an item with the ID: Q6\"})))\n            .mount(&mock_server).await;\n        let api = RestApi::builder(&(mock_server.uri() + \"/w/rest.php\"))\n            .unwrap()\n            .build();\n\n        Item::get(EntityId::item(id), &api).await\n    }\n\n    #[tokio::test]\n    #[cfg_attr(miri, ignore)]\n    async fn test_item_get() {\n        let item = get_test_item(\"Q42\").await.unwrap();\n        assert_eq!(item.id(), EntityId::item(\"Q42\"));\n        assert!(item.labels.has_language(\"en\"));\n        assert_eq!(item.labels().get_lang(\"en\").unwrap(), \"Douglas Adams\");\n        assert!(item\n            .aliases()\n            .get_lang(\"en\")\n            .contains(&\"Douglas NoÃ«l Adams\"));\n        assert!(item.descriptions.has_language(\"en\"));\n        assert!(item.aliases.has_language(\"en\"));\n        assert!(item.sitelinks.get_wiki(\"enwiki\").is_some());\n        assert!(!item.statements.is_empty());\n    }\n\n    #[tokio::test]\n    #[cfg_attr(miri, ignore)]\n    async fn test_item_post() {\n        let mut item = get_test_item(\"Q42\").await.unwrap();\n        let v = item.to_owned();\n\n        let mock_server = MockServer::start().await;\n        Mock::given(method(\"POST\"))\n            .and(path(\"/w/rest.php/wikibase/v1/entities/items\"))\n            .and(body_partial_json(\n                json!({\"item\": {\"labels\": {\"en\": item.labels().get_lang(\"en\")}}}),\n            ))\n            .respond_with(ResponseTemplate::new(200).set_body_json(&v))\n            .mount(&mock_server)\n            .await;\n        let api = RestApi::builder(&(mock_server.uri() + \"/w/rest.php\"))\n            .unwrap()\n            .build();\n\n        // Check that an error is returned when trying to post an item that already has an ID\n        let r0 = item.post(&api).await;\n        assert_eq!(r0.err().unwrap().to_string(), \"ID already set\");\n\n        // Clear the ID and try again\n        item.id = EntityId::None;\n        let r1 = item.post(&api).await.unwrap();\n        assert_eq!(r1.id(), v.id());\n    }\n\n    #[tokio::test]\n    #[cfg_attr(miri, ignore)]\n    async fn test_item_post_404() {\n        let item = Item::default();\n        let mock_server = MockServer::start().await;\n        let api = RestApi::builder(&(mock_server.uri() + \"/w/rest.php\"))\n            .unwrap()\n            .build();\n        let r = item.post(&api).await;\n        assert_eq!(\n            r.err().unwrap().to_string(),\n            \"Method POST not implemented for path /entities/items in REST API\"\n        );\n    }\n\n    #[tokio::test]\n    #[cfg_attr(miri, ignore)]\n    async fn test_invalid_item() {\n        let item = get_test_item(\"Q0\").await;\n        // assert_eq!(item.err().unwrap().to_string(), \"invalid-item-id\");\n        let err = item.err().unwrap();\n        match err {\n            RestApiError::ApiError {\n                status,\n                status_text,\n                payload,\n            } => {\n                assert_eq!(status, 400);\n                assert_eq!(status_text, \"Bad Request\");\n                assert_eq!(payload.code(), \"invalid-item-id\");\n                assert_eq!(payload.message(), \"Not a valid item ID: Q0\");\n                assert_eq!(payload.context().len(), 0);\n            }\n            _ => panic!(\"Wrong error type\"),\n        }\n    }\n\n    #[tokio::test]\n    #[cfg_attr(miri, ignore)]\n    async fn test_deleted_item() {\n        let item = get_test_item(\"Q6\").await;\n        let err = item.err().unwrap();\n        match err {\n            RestApiError::ApiError {\n                status,\n                status_text,\n                payload,\n            } => {\n                assert_eq!(status, 404);\n                assert_eq!(status_text, \"Not Found\");\n                assert_eq!(payload.code(), \"item-not-found\");\n                assert_eq!(payload.message(), \"Could not find an item with the ID: Q6\");\n                assert_eq!(payload.context().len(), 0);\n            }\n            _ => panic!(\"Wrong error type\"),\n        }\n    }\n\n    #[tokio::test]\n    #[cfg_attr(miri, ignore)]\n    async fn test_json_serialize() {\n        let item = get_test_item(\"Q42\").await.unwrap();\n        let j = serde_json::to_string(&item).unwrap(); // Convert item to JSON text\n        let v: Value = serde_json::from_str(&j).unwrap(); // Convert to JSON value\n        let item_from_json = Item::from_json(v).unwrap(); // Convert back to Item\n        assert_eq!(item, item_from_json); // Check if the reconstituted item is identical to the original\n    }\n\n    #[test]\n    fn test_labels() {\n        let mut item = Item::default();\n        assert_eq!(item.labels().len(), 0);\n        item.labels_mut().insert(LanguageString::new(\"en\", \"label\"));\n        assert_eq!(item.labels().len(), 1);\n    }\n\n    #[test]\n    fn test_descriptions() {\n        let mut item = Item::default();\n        assert_eq!(item.descriptions().len(), 0);\n        item.descriptions_mut()\n            .insert(LanguageString::new(\"en\", \"description\"));\n        assert_eq!(item.descriptions().len(), 1);\n    }\n\n    #[test]\n    fn test_aliases() {\n        let mut item = Item::default();\n        assert_eq!(item.aliases().len(), 0);\n        item.aliases_mut()\n            .insert(LanguageString::new(\"en\", \"alias\"));\n        assert_eq!(item.aliases().len(), 1);\n    }\n\n    #[test]\n    fn test_as_aliases() {\n        let mut item = Item::default();\n        item.aliases_mut()\n            .insert(LanguageString::new(\"en\", \"alias\"));\n        let aliases = item.as_aliases(\"en\");\n        assert_eq!(aliases.len(), 1);\n    }\n\n    #[test]\n    fn test_statements() {\n        let mut item = Item::default();\n        assert_eq!(item.statements().len(), 0);\n        item.statements_mut()\n            .insert(Statement::new_string(\"P31\", \"Q42\"));\n        assert_eq!(item.statements().len(), 1);\n    }\n\n    #[test]\n    fn test_sitelinks() {\n        let mut item = Item::default();\n        assert_eq!(item.sitelinks().len(), 0);\n        item.sitelinks_mut()\n            .set_wiki(Sitelink::new(\"enwiki\", \"Q42\"));\n        assert_eq!(item.sitelinks().len(), 1);\n    }\n\n    #[test]\n    fn test_header_info() {\n        let hi = HeaderInfo::default();\n        let item = Item::default();\n        assert_eq!(item.header_info(), &hi);\n    }\n\n    #[test]\n    fn test_get_rest_api_path() {\n        let item = Item::default();\n        let id = EntityId::item(\"Q42\");\n        let path = item.get_my_rest_api_path(&id).unwrap();\n        assert_eq!(path, \"/entities/items/Q42\");\n    }\n\n    #[test]\n    fn test_patch() {\n        let mut item1 = Item::default();\n        let mut item2 = Item::default();\n        item1\n            .labels_mut()\n            .insert(LanguageString::new(\"en\", \"label\"));\n        item2\n            .labels_mut()\n            .insert(LanguageString::new(\"en\", \"label2\"));\n        let patch = item1.patch(&item2).unwrap();\n        assert_eq!(patch.patch().len(), 1);\n    }\n}\n","traces":[{"line":31,"address":[],"length":0,"stats":{"Line":1}},{"line":32,"address":[],"length":0,"stats":{"Line":2}},{"line":38,"address":[],"length":0,"stats":{"Line":8}},{"line":39,"address":[],"length":0,"stats":{"Line":8}},{"line":42,"address":[],"length":0,"stats":{"Line":9}},{"line":43,"address":[],"length":0,"stats":{"Line":18}},{"line":45,"address":[],"length":0,"stats":{"Line":9}},{"line":46,"address":[],"length":0,"stats":{"Line":9}},{"line":47,"address":[],"length":0,"stats":{"Line":9}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":9}},{"line":54,"address":[],"length":0,"stats":{"Line":9}},{"line":55,"address":[],"length":0,"stats":{"Line":9}},{"line":56,"address":[],"length":0,"stats":{"Line":9}},{"line":57,"address":[],"length":0,"stats":{"Line":9}},{"line":61,"address":[],"length":0,"stats":{"Line":3}},{"line":62,"address":[],"length":0,"stats":{"Line":3}},{"line":67,"address":[],"length":0,"stats":{"Line":4}},{"line":72,"address":[],"length":0,"stats":{"Line":4}},{"line":73,"address":[],"length":0,"stats":{"Line":6}},{"line":74,"address":[],"length":0,"stats":{"Line":2}},{"line":76,"address":[],"length":0,"stats":{"Line":5}},{"line":77,"address":[],"length":0,"stats":{"Line":1}},{"line":79,"address":[],"length":0,"stats":{"Line":5}},{"line":80,"address":[],"length":0,"stats":{"Line":1}},{"line":82,"address":[],"length":0,"stats":{"Line":5}},{"line":83,"address":[],"length":0,"stats":{"Line":1}},{"line":85,"address":[],"length":0,"stats":{"Line":5}},{"line":86,"address":[],"length":0,"stats":{"Line":1}},{"line":88,"address":[],"length":0,"stats":{"Line":5}},{"line":89,"address":[],"length":0,"stats":{"Line":1}},{"line":91,"address":[],"length":0,"stats":{"Line":8}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":2}},{"line":94,"address":[],"length":0,"stats":{"Line":2}},{"line":96,"address":[],"length":0,"stats":{"Line":4}},{"line":97,"address":[],"length":0,"stats":{"Line":3}},{"line":99,"address":[],"length":0,"stats":{"Line":4}},{"line":100,"address":[],"length":0,"stats":{"Line":3}},{"line":102,"address":[],"length":0,"stats":{"Line":4}},{"line":103,"address":[],"length":0,"stats":{"Line":3}},{"line":105,"address":[],"length":0,"stats":{"Line":4}},{"line":106,"address":[],"length":0,"stats":{"Line":3}},{"line":108,"address":[],"length":0,"stats":{"Line":4}},{"line":109,"address":[],"length":0,"stats":{"Line":3}},{"line":111,"address":[],"length":0,"stats":{"Line":4}},{"line":117,"address":[],"length":0,"stats":{"Line":5}},{"line":118,"address":[],"length":0,"stats":{"Line":5}},{"line":122,"address":[],"length":0,"stats":{"Line":1}},{"line":123,"address":[],"length":0,"stats":{"Line":1}},{"line":127,"address":[],"length":0,"stats":{"Line":5}},{"line":128,"address":[],"length":0,"stats":{"Line":5}},{"line":132,"address":[],"length":0,"stats":{"Line":3}},{"line":133,"address":[],"length":0,"stats":{"Line":3}},{"line":137,"address":[],"length":0,"stats":{"Line":3}},{"line":138,"address":[],"length":0,"stats":{"Line":3}},{"line":142,"address":[],"length":0,"stats":{"Line":1}},{"line":143,"address":[],"length":0,"stats":{"Line":1}},{"line":147,"address":[],"length":0,"stats":{"Line":4}},{"line":148,"address":[],"length":0,"stats":{"Line":4}},{"line":152,"address":[],"length":0,"stats":{"Line":2}},{"line":153,"address":[],"length":0,"stats":{"Line":2}},{"line":157,"address":[],"length":0,"stats":{"Line":1}},{"line":158,"address":[],"length":0,"stats":{"Line":1}},{"line":159,"address":[],"length":0,"stats":{"Line":1}},{"line":160,"address":[],"length":0,"stats":{"Line":1}},{"line":161,"address":[],"length":0,"stats":{"Line":1}},{"line":163,"address":[],"length":0,"stats":{"Line":3}},{"line":165,"address":[],"length":0,"stats":{"Line":1}},{"line":169,"address":[],"length":0,"stats":{"Line":3}},{"line":170,"address":[],"length":0,"stats":{"Line":3}},{"line":174,"address":[],"length":0,"stats":{"Line":1}},{"line":175,"address":[],"length":0,"stats":{"Line":1}},{"line":179,"address":[],"length":0,"stats":{"Line":1}},{"line":180,"address":[],"length":0,"stats":{"Line":1}},{"line":184,"address":[],"length":0,"stats":{"Line":1}},{"line":185,"address":[],"length":0,"stats":{"Line":2}},{"line":186,"address":[],"length":0,"stats":{"Line":1}},{"line":187,"address":[],"length":0,"stats":{"Line":1}},{"line":188,"address":[],"length":0,"stats":{"Line":1}},{"line":189,"address":[],"length":0,"stats":{"Line":1}}],"covered":79,"coverable":81},{"path":["/","Users","magnusmanske","rust","wikibase_rest_api","src","label.rs"],"content":"use crate::{\n    EditMetadata, EntityId, HeaderInfo, HttpDelete, HttpGet, HttpGetEntityWithFallback, HttpMisc,\n    HttpPut, LanguageString, RestApi, RestApiError, RevisionMatch,\n};\nuse async_trait::async_trait;\nuse derivative::Derivative;\nuse reqwest::Request;\nuse serde_json::json;\nuse std::collections::HashMap;\nuse std::ops::Deref;\n\n#[derive(Derivative, Debug, Clone)]\n#[derivative(PartialEq)]\npub struct Label {\n    ls: LanguageString,\n    #[derivative(PartialEq = \"ignore\")]\n    header_info: HeaderInfo,\n}\n\nimpl Label {\n    /// Constructs a new `Label` object from a language code and a label.\n    pub fn new<S1: Into<String>, S2: Into<String>>(language: S1, value: S2) -> Label {\n        Self {\n            ls: LanguageString::new(language, value),\n            header_info: HeaderInfo::default(),\n        }\n    }\n\n    async fn generate_get_match_request(\n        id: &EntityId,\n        language: &str,\n        api: &RestApi,\n        rm: RevisionMatch,\n        mode: &str,\n    ) -> Result<Request, RestApiError> {\n        let path = format!(\n            \"/entities/{group}/{id}/{mode}/{language}\",\n            group = id.group()?\n        );\n        let mut request = api\n            .wikibase_request_builder(&path, HashMap::new(), reqwest::Method::GET)\n            .await?\n            .build()?;\n        rm.modify_headers(request.headers_mut())?;\n        Ok(request)\n    }\n}\n\nimpl Deref for Label {\n    type Target = LanguageString;\n\n    fn deref(&self) -> &Self::Target {\n        &self.ls\n    }\n}\n\nimpl From<LanguageString> for Label {\n    fn from(ls: LanguageString) -> Self {\n        Self {\n            ls,\n            header_info: HeaderInfo::default(),\n        }\n    }\n}\n\nimpl From<Label> for LanguageString {\n    fn from(val: Label) -> Self {\n        val.ls\n    }\n}\n\nimpl HttpMisc for Label {\n    fn get_my_rest_api_path(&self, id: &EntityId) -> Result<String, RestApiError> {\n        Ok(format!(\n            \"/entities/{group}/{id}/labels/{language}\",\n            group = id.group()?,\n            language = self.ls.language()\n        ))\n    }\n}\n\n#[async_trait]\nimpl HttpGetEntityWithFallback for Label {\n    async fn get_match_with_fallback(\n        id: &EntityId,\n        language: &str,\n        api: &RestApi,\n        rm: RevisionMatch,\n    ) -> Result<Self, RestApiError> {\n        let request = Self::generate_get_match_request(\n            id,\n            language,\n            api,\n            rm,\n            \"labels_with_language_fallback\",\n        )\n        .await?;\n        let (j, header_info) = Self::api_execute(api, request).await?;\n        let s = j\n            .as_str()\n            .ok_or_else(|| RestApiError::MissingOrInvalidField {\n                field: \"Label\".into(),\n                j: j.to_owned(),\n            })?;\n        Ok(Self {\n            ls: LanguageString::new(language, s),\n            header_info,\n        })\n    }\n}\n\n#[async_trait]\nimpl HttpGet for Label {\n    async fn get_match(\n        id: &EntityId,\n        language: &str,\n        api: &RestApi,\n        rm: RevisionMatch,\n    ) -> Result<Self, RestApiError> {\n        let request = Self::generate_get_match_request(id, language, api, rm, \"labels\").await?;\n        let (j, header_info) = Self::api_execute(api, request).await?;\n        let s = j\n            .as_str()\n            .ok_or_else(|| RestApiError::MissingOrInvalidField {\n                field: \"Label\".into(),\n                j: j.to_owned(),\n            })?;\n        Ok(Self {\n            ls: LanguageString::new(language, s),\n            header_info,\n        })\n    }\n}\n\n#[async_trait]\nimpl HttpDelete for Label {\n    async fn delete_meta(\n        &self,\n        id: &EntityId,\n        api: &mut RestApi,\n        em: EditMetadata,\n    ) -> Result<(), RestApiError> {\n        let j = json!({});\n        let (j, _header_info) = self\n            .run_json_query(id, reqwest::Method::DELETE, j, api, &em)\n            .await?;\n        match j.as_str() {\n            Some(\"Label deleted\") => Ok(()),\n            Some(\"Description deleted\") => Ok(()),\n            _ => Err(RestApiError::UnexpectedResponse(j)),\n        }\n    }\n}\n\n#[async_trait]\nimpl HttpPut for Label {\n    async fn put_meta(\n        &self,\n        id: &EntityId,\n        api: &mut RestApi,\n        em: EditMetadata,\n    ) -> Result<Self, RestApiError> {\n        let j = json!({\"label\": self.ls.value()});\n        let (j, header_info) = self\n            .run_json_query(id, reqwest::Method::PUT, j, api, &em)\n            .await?;\n        let value = j\n            .as_str()\n            .ok_or_else(|| RestApiError::MissingOrInvalidField {\n                field: \"Label\".into(),\n                j: j.to_owned(),\n            })?;\n        let mut ret = Self::new(self.language(), value);\n        ret.header_info = header_info;\n        Ok(ret)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use wiremock::matchers::{bearer_token, body_partial_json, method, path};\n    use wiremock::{Mock, MockServer, ResponseTemplate};\n\n    #[tokio::test]\n    #[cfg_attr(miri, ignore)]\n    async fn test_labels_get_match_with_fallback() {\n        let id = \"Q42\";\n        let mock_path = format!(\n            \"/w/rest.php/wikibase/v1/entities/items/{id}/labels_with_language_fallback/foo\"\n        );\n        let mock_server = MockServer::start().await;\n        Mock::given(method(\"GET\"))\n            .and(path(&mock_path))\n            .respond_with(ResponseTemplate::new(200).set_body_json(json!(\"Douglas Adams\")))\n            .mount(&mock_server)\n            .await;\n        let api = RestApi::builder(&(mock_server.uri() + \"/w/rest.php\"))\n            .unwrap()\n            .build();\n\n        let id = EntityId::item(id);\n        let label = Label::get_with_fallback(&id, \"foo\", &api).await.unwrap();\n        assert_eq!(label.language(), \"foo\");\n        assert_eq!(label.value(), \"Douglas Adams\");\n    }\n\n    #[tokio::test]\n    #[cfg_attr(miri, ignore)]\n    async fn test_label_get() {\n        let id = \"Q42\";\n        let mock_path = format!(\"/w/rest.php/wikibase/v1/entities/items/{id}/labels/en\");\n        let mock_server = MockServer::start().await;\n        Mock::given(method(\"GET\"))\n            .and(path(&mock_path))\n            .respond_with(ResponseTemplate::new(200).set_body_json(json!(\"Douglas Adams\")))\n            .mount(&mock_server)\n            .await;\n        let api = RestApi::builder(&(mock_server.uri() + \"/w/rest.php\"))\n            .unwrap()\n            .build();\n\n        let id = EntityId::item(id);\n        let label = Label::get(&id, \"en\", &api).await.unwrap();\n        assert_eq!(label.language(), \"en\");\n        assert_eq!(label.value(), \"Douglas Adams\");\n    }\n\n    #[tokio::test]\n    #[cfg_attr(miri, ignore)]\n    async fn test_label_put() {\n        let label = \"Foo bar\";\n        let id = \"Q42\";\n        let mock_path = format!(\"/w/rest.php/wikibase/v1/entities/items/{id}/labels/en\");\n        let mock_server = MockServer::start().await;\n        let token = \"FAKE_TOKEN\";\n        Mock::given(body_partial_json(json!({\"label\": label})))\n            .and(method(\"PUT\"))\n            .and(path(&mock_path))\n            .and(bearer_token(token))\n            .respond_with(ResponseTemplate::new(200).set_body_json(json!(label)))\n            .mount(&mock_server)\n            .await;\n        let mut api = RestApi::builder(&(mock_server.uri() + \"/w/rest.php\"))\n            .unwrap()\n            .with_access_token(token)\n            .build();\n\n        let id = EntityId::item(id);\n        let new_label = Label::new(\"en\", label);\n        let return_label = new_label.put(&id, &mut api).await.unwrap();\n        assert_eq!(return_label.language(), \"en\");\n        assert_eq!(return_label.value(), label);\n    }\n\n    #[tokio::test]\n    #[cfg_attr(miri, ignore)]\n    async fn test_label_delete() {\n        let id = \"Q42\";\n        let mock_path = format!(\"/w/rest.php/wikibase/v1/entities/items/{id}/labels/en\");\n        let mock_server = MockServer::start().await;\n        let token = \"FAKE_TOKEN\";\n        Mock::given(method(\"DELETE\"))\n            .and(path(&mock_path))\n            .and(bearer_token(token))\n            .respond_with(ResponseTemplate::new(200).set_body_json(json!(\"Label deleted\")))\n            .mount(&mock_server)\n            .await;\n        let mut api = RestApi::builder(&(mock_server.uri() + \"/w/rest.php\"))\n            .unwrap()\n            .with_access_token(token)\n            .build();\n\n        let id = EntityId::item(id);\n        let label = Label::new(\"en\", \"\");\n        let result = label.delete(&id, &mut api).await;\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_into_language_string() {\n        let label = Label::new(\"en\", \"Foo bar\");\n        let ls: LanguageString = label.into();\n        assert_eq!(ls.language(), \"en\");\n        assert_eq!(ls.value(), \"Foo bar\");\n    }\n\n    #[test]\n    fn test_from_language_string() {\n        let ls = LanguageString::new(\"en\", \"Foo bar\");\n        let label = Label::from(ls);\n        assert_eq!(label.language(), \"en\");\n        assert_eq!(label.value(), \"Foo bar\");\n    }\n}\n","traces":[{"line":22,"address":[],"length":0,"stats":{"Line":4}},{"line":24,"address":[],"length":0,"stats":{"Line":4}},{"line":25,"address":[],"length":0,"stats":{"Line":4}},{"line":29,"address":[],"length":0,"stats":{"Line":2}},{"line":36,"address":[],"length":0,"stats":{"Line":2}},{"line":38,"address":[],"length":0,"stats":{"Line":2}},{"line":40,"address":[],"length":0,"stats":{"Line":2}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":2}},{"line":52,"address":[],"length":0,"stats":{"Line":9}},{"line":53,"address":[],"length":0,"stats":{"Line":9}},{"line":58,"address":[],"length":0,"stats":{"Line":1}},{"line":61,"address":[],"length":0,"stats":{"Line":1}},{"line":67,"address":[],"length":0,"stats":{"Line":1}},{"line":68,"address":[],"length":0,"stats":{"Line":1}},{"line":73,"address":[],"length":0,"stats":{"Line":2}},{"line":74,"address":[],"length":0,"stats":{"Line":2}},{"line":75,"address":[],"length":0,"stats":{"Line":2}},{"line":76,"address":[],"length":0,"stats":{"Line":2}},{"line":91,"address":[],"length":0,"stats":{"Line":1}},{"line":92,"address":[],"length":0,"stats":{"Line":1}},{"line":93,"address":[],"length":0,"stats":{"Line":1}},{"line":94,"address":[],"length":0,"stats":{"Line":1}},{"line":97,"address":[],"length":0,"stats":{"Line":1}},{"line":98,"address":[],"length":0,"stats":{"Line":1}},{"line":99,"address":[],"length":0,"stats":{"Line":1}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":2}},{"line":121,"address":[],"length":0,"stats":{"Line":1}},{"line":122,"address":[],"length":0,"stats":{"Line":1}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":1}},{"line":144,"address":[],"length":0,"stats":{"Line":2}},{"line":145,"address":[],"length":0,"stats":{"Line":1}},{"line":146,"address":[],"length":0,"stats":{"Line":1}},{"line":148,"address":[],"length":0,"stats":{"Line":2}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":1}},{"line":164,"address":[],"length":0,"stats":{"Line":2}},{"line":165,"address":[],"length":0,"stats":{"Line":1}},{"line":166,"address":[],"length":0,"stats":{"Line":1}},{"line":167,"address":[],"length":0,"stats":{"Line":1}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}}],"covered":38,"coverable":51},{"path":["/","Users","magnusmanske","rust","wikibase_rest_api","src","labels.rs"],"content":"use crate::{\n    language_strings_patch::LanguageStringsPatch, prelude::LanguageStrings, EntityId, FromJson,\n    HeaderInfo, HttpGetEntity, HttpMisc, LanguageString, RestApi, RestApiError, RevisionMatch,\n};\nuse async_trait::async_trait;\nuse derivative::Derivative;\nuse serde::ser::{Serialize, SerializeMap};\nuse serde_json::{json, Value};\nuse std::collections::HashMap;\n\n#[derive(Derivative, Debug, Clone, Default)]\n#[derivative(PartialEq)]\npub struct Labels {\n    ls: HashMap<String, String>,\n    #[derivative(PartialEq = \"ignore\")]\n    header_info: HeaderInfo,\n}\n\nimpl Labels {\n    /// Returns the value for a language\n    pub fn get_lang<S: Into<String>>(&self, language: S) -> Option<&str> {\n        self.ls.get(&language.into()).map(|s| s.as_str())\n    }\n\n    /// Returns the number of labels/languages\n    pub fn len(&self) -> usize {\n        self.ls.len()\n    }\n\n    /// Returns true if there are no labels/languages\n    pub fn is_empty(&self) -> bool {\n        self.ls.is_empty()\n    }\n\n    /// Generates a patch to transform `other` into `self`\n    pub fn patch(&self, other: &Self) -> Result<LanguageStringsPatch, RestApiError> {\n        let patch = json_patch::diff(&json!(&other), &json!(&self));\n        let patch = LanguageStringsPatch::labels_from_json(&json!(patch))?;\n        Ok(patch)\n    }\n}\n\nimpl HttpMisc for Labels {\n    fn get_my_rest_api_path(&self, id: &EntityId) -> Result<String, RestApiError> {\n        Ok(format!(\n            \"/entities/{group}/{id}/labels\",\n            group = id.group()?\n        ))\n    }\n}\n\n#[async_trait]\nimpl HttpGetEntity for Labels {\n    async fn get_match(\n        id: &EntityId,\n        api: &RestApi,\n        rm: RevisionMatch,\n    ) -> Result<Self, RestApiError> {\n        let path = format!(\"/entities/{group}/{id}/labels\", group = id.group()?);\n        let (j, header_info) = Self::get_match_internal(api, &path, rm).await?;\n        Self::from_json_header_info(&j, header_info)\n    }\n}\n\nimpl FromJson for Labels {\n    fn header_info(&self) -> &HeaderInfo {\n        &self.header_info\n    }\n\n    fn from_json_header_info(j: &Value, header_info: HeaderInfo) -> Result<Self, RestApiError> {\n        let ls = j\n            .as_object()\n            .ok_or_else(|| RestApiError::WrongType {\n                field: \"Labels\".to_string(),\n                j: j.to_owned(),\n            })?\n            .iter()\n            .map(|(language, value)| {\n                let value = value\n                    .as_str()\n                    .ok_or_else(|| RestApiError::MissingOrInvalidField {\n                        field: \"Labels\".into(),\n                        j: value.to_owned(),\n                    })?;\n                Ok((language.to_owned(), value.to_string()))\n            })\n            .collect::<Result<HashMap<String, String>, RestApiError>>()?;\n        let ret = Self { ls, header_info };\n        Ok(ret)\n    }\n}\n\nimpl LanguageStrings for Labels {\n    fn has_language<S: Into<String>>(&self, language: S) -> bool {\n        self.ls.contains_key(&language.into())\n    }\n\n    fn insert(&mut self, ls: LanguageString) {\n        self.ls\n            .insert(ls.language().to_string(), ls.value().to_string());\n    }\n}\n\nimpl Serialize for Labels {\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: serde::Serializer,\n    {\n        let mut s = serializer.serialize_map(Some(self.ls.len()))?;\n        for (language, ls) in &self.ls {\n            s.serialize_entry(language, ls)?;\n        }\n        s.end()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use serde_json::json;\n    use wiremock::matchers::{method, path};\n    use wiremock::{Mock, MockServer, ResponseTemplate};\n\n    #[test]\n    fn test_language_strings_single() {\n        let j = json!({\n            \"en\": \"Hello\",\n            \"de\": \"Hallo\",\n        });\n        let ls = Labels::from_json(&j).unwrap();\n        assert_eq!(ls.get_lang(\"en\"), Some(\"Hello\"));\n        assert_eq!(ls.get_lang(\"de\"), Some(\"Hallo\"));\n        assert_eq!(ls.get_lang(\"fr\"), None);\n    }\n\n    #[test]\n    fn test_language_strings_insert() {\n        let mut ls = Labels::default();\n        ls.insert(LanguageString::new(\"en\", \"Hello\"));\n        ls.insert(LanguageString::new(\"de\", \"Hallo\"));\n        ls.insert(LanguageString::new(\"en\", \"Hi\"));\n        assert_eq!(ls.get_lang(\"en\"), Some(\"Hi\"));\n        assert_eq!(ls.get_lang(\"de\"), Some(\"Hallo\"));\n    }\n\n    #[tokio::test]\n    #[cfg_attr(miri, ignore)]\n    async fn test_language_strings_single_get() {\n        let v = std::fs::read_to_string(\"test_data/Q42.json\").unwrap();\n        let v: Value = serde_json::from_str(&v).unwrap();\n\n        let mock_path = \"/w/rest.php/wikibase/v1/entities/items/Q42/labels\";\n        let mock_server = MockServer::start().await;\n        Mock::given(method(\"GET\"))\n            .and(path(mock_path))\n            .respond_with(ResponseTemplate::new(200).set_body_json(&v[\"labels\"]))\n            .mount(&mock_server)\n            .await;\n        let api = RestApi::builder(&(mock_server.uri() + \"/w/rest.php\"))\n            .unwrap()\n            .build();\n\n        let id = EntityId::new(\"Q42\").unwrap();\n        let ls = Labels::get(&id, &api).await.unwrap();\n        assert_eq!(ls.get_lang(\"en\"), Some(\"Douglas Adams\"));\n    }\n\n    #[test]\n    fn test_patch_labels() {\n        let mut l1 = Labels::default();\n        l1.insert(LanguageString::new(\"en\", \"Foo\"));\n        l1.insert(LanguageString::new(\"de\", \"Bar\"));\n        let mut l2 = l1.clone();\n        l2.insert(LanguageString::new(\"en\", \"Baz\"));\n\n        let patch = l2.patch(&l1).unwrap();\n        let patch_json = json!(patch);\n        assert_eq!(\n            patch_json,\n            json!({\"mode\":\"Labels\",\"patch\":[{\"op\":\"replace\",\"path\":\"/en\",\"value\":\"Baz\"}]})\n        );\n    }\n\n    #[test]\n    fn test_get_rest_api_path() {\n        let l = Labels::default();\n        let id = EntityId::new(\"Q42\").unwrap();\n        assert_eq!(\n            l.get_my_rest_api_path(&id).unwrap(),\n            \"/entities/items/Q42/labels\"\n        );\n    }\n\n    #[test]\n    fn test_header_info_single() {\n        let l = Labels::default();\n        assert_eq!(l.header_info(), &HeaderInfo::default());\n    }\n\n    #[test]\n    fn test_serialize() {\n        let mut l = Labels::default();\n        l.insert(LanguageString::new(\"en\", \"Foo\"));\n        l.insert(LanguageString::new(\"de\", \"Bar\"));\n        let s = serde_json::to_string(&l).unwrap();\n        assert!(s.contains(r#\"\"en\":\"Foo\"\"#));\n        assert!(s.contains(r#\"\"de\":\"Bar\"\"#));\n    }\n}\n","traces":[{"line":21,"address":[],"length":0,"stats":{"Line":11}},{"line":22,"address":[],"length":0,"stats":{"Line":32}},{"line":26,"address":[],"length":0,"stats":{"Line":4}},{"line":27,"address":[],"length":0,"stats":{"Line":4}},{"line":31,"address":[],"length":0,"stats":{"Line":16}},{"line":32,"address":[],"length":0,"stats":{"Line":16}},{"line":36,"address":[],"length":0,"stats":{"Line":2}},{"line":37,"address":[],"length":0,"stats":{"Line":2}},{"line":38,"address":[],"length":0,"stats":{"Line":4}},{"line":44,"address":[],"length":0,"stats":{"Line":1}},{"line":45,"address":[],"length":0,"stats":{"Line":1}},{"line":46,"address":[],"length":0,"stats":{"Line":1}},{"line":47,"address":[],"length":0,"stats":{"Line":1}},{"line":59,"address":[],"length":0,"stats":{"Line":2}},{"line":60,"address":[],"length":0,"stats":{"Line":1}},{"line":66,"address":[],"length":0,"stats":{"Line":1}},{"line":67,"address":[],"length":0,"stats":{"Line":1}},{"line":70,"address":[],"length":0,"stats":{"Line":18}},{"line":71,"address":[],"length":0,"stats":{"Line":36}},{"line":73,"address":[],"length":0,"stats":{"Line":18}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":2810}},{"line":79,"address":[],"length":0,"stats":{"Line":5584}},{"line":80,"address":[],"length":0,"stats":{"Line":2792}},{"line":81,"address":[],"length":0,"stats":{"Line":2792}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":1}},{"line":95,"address":[],"length":0,"stats":{"Line":1}},{"line":98,"address":[],"length":0,"stats":{"Line":13}},{"line":99,"address":[],"length":0,"stats":{"Line":13}},{"line":100,"address":[],"length":0,"stats":{"Line":13}},{"line":105,"address":[],"length":0,"stats":{"Line":12}},{"line":109,"address":[],"length":0,"stats":{"Line":24}},{"line":110,"address":[],"length":0,"stats":{"Line":1980}},{"line":111,"address":[],"length":0,"stats":{"Line":984}},{"line":113,"address":[],"length":0,"stats":{"Line":12}}],"covered":34,"coverable":38},{"path":["/","Users","magnusmanske","rust","wikibase_rest_api","src","labels_patch.rs"],"content":"use crate::{patch_entry::PatchEntry, EntityId, HttpMisc, Patch, RestApiError};\nuse serde::Serialize;\nuse serde_json::Value;\n\n#[derive(Debug, Clone, PartialEq, Serialize, Default)]\npub struct LabelsPatch {\n    patch: Vec<PatchEntry>,\n}\n\nimpl LabelsPatch {\n    pub fn from_json(j: &Value) -> Result<Vec<PatchEntry>, RestApiError> {\n        j.as_array()\n            .ok_or_else(|| RestApiError::MissingOrInvalidField {\n                field: \"LabelsPatch\".into(),\n                j: j.to_owned(),\n            })?\n            .iter()\n            .map(|x| serde_json::from_value(x.clone()).map_err(|e| e.into()))\n            .collect::<Result<Vec<PatchEntry>, RestApiError>>()\n    }\n\n    // TODO add?\n\n    /// Adds a command to replace the value of a language string.\n    pub fn replace<S1: Into<String>, S2: Into<String>>(&mut self, language: S1, value: S2) {\n        <Self as Patch>::replace(self, format!(\"/{}\", language.into()), value.into().into());\n    }\n\n    /// Adds a command to remove the value for the language.\n    pub fn remove<S: Into<String>>(&mut self, language: S) {\n        <Self as Patch>::remove(self, format!(\"/{}\", language.into()));\n    }\n}\n\nimpl Patch for LabelsPatch {\n    fn patch(&self) -> &Vec<PatchEntry> {\n        &self.patch\n    }\n\n    fn patch_mut(&mut self) -> &mut Vec<PatchEntry> {\n        &mut self.patch\n    }\n}\n\nimpl HttpMisc for LabelsPatch {\n    fn get_my_rest_api_path(&self, id: &EntityId) -> Result<String, RestApiError> {\n        Ok(format!(\n            \"/entities/{group}/{id}/labels\",\n            group = id.group()?\n        ))\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use serde_json::{json, Value};\n\n    #[test]\n    fn test_remove() {\n        let mut patch = LabelsPatch::default();\n        patch.remove(\"en\");\n        assert_eq!(\n            patch.patch,\n            vec![PatchEntry::new(\"remove\", \"/en\", Value::Null)]\n        );\n    }\n\n    #[test]\n    fn test_patch() {\n        let mut patch = LabelsPatch::default();\n        patch.replace(\"en\", \"Foo Bar\");\n        assert_eq!(\n            patch.patch,\n            vec![PatchEntry::new(\"replace\", \"/en\", json!(\"Foo Bar\"))]\n        );\n    }\n\n    #[test]\n    fn test_patch_fn() {\n        let mut patch = LabelsPatch::default();\n        patch.replace(\"en\", \"Foo Bar\");\n        assert_eq!(\n            *<LabelsPatch as Patch>::patch(&patch),\n            vec![PatchEntry::new(\"replace\", \"/en\", json!(\"Foo Bar\"))]\n        );\n    }\n\n    #[test]\n    fn test_from_json() {\n        let j = json!([\n            {\"op\": \"replace\", \"path\": \"/en\", \"value\": \"Foo Bar\"},\n            {\"op\": \"remove\", \"path\": \"/de\"}\n        ]);\n        let patch = LabelsPatch::from_json(&j).unwrap();\n        assert_eq!(\n            patch,\n            vec![\n                PatchEntry::new(\"replace\", \"/en\", json!(\"Foo Bar\")),\n                PatchEntry::new(\"remove\", \"/de\", Value::Null)\n            ]\n        );\n    }\n\n    #[test]\n    fn test_get_rest_api_path_items() {\n        let patch = LabelsPatch::default();\n        let id = EntityId::new(\"Q12345\").unwrap();\n        assert_eq!(\n            patch.get_my_rest_api_path(&id).unwrap(),\n            \"/entities/items/Q12345/labels\"\n        );\n    }\n\n    #[test]\n    fn test_get_rest_api_path_properties() {\n        let patch = LabelsPatch::default();\n        let id = EntityId::new(\"P123\").unwrap();\n        assert_eq!(\n            patch.get_my_rest_api_path(&id).unwrap(),\n            \"/entities/properties/P123/labels\"\n        );\n    }\n}\n","traces":[{"line":11,"address":[],"length":0,"stats":{"Line":1}},{"line":12,"address":[],"length":0,"stats":{"Line":1}},{"line":13,"address":[],"length":0,"stats":{"Line":1}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":5}},{"line":25,"address":[],"length":0,"stats":{"Line":2}},{"line":26,"address":[],"length":0,"stats":{"Line":2}},{"line":30,"address":[],"length":0,"stats":{"Line":1}},{"line":31,"address":[],"length":0,"stats":{"Line":1}},{"line":36,"address":[],"length":0,"stats":{"Line":1}},{"line":37,"address":[],"length":0,"stats":{"Line":1}},{"line":40,"address":[],"length":0,"stats":{"Line":3}},{"line":41,"address":[],"length":0,"stats":{"Line":3}},{"line":46,"address":[],"length":0,"stats":{"Line":2}},{"line":47,"address":[],"length":0,"stats":{"Line":2}},{"line":48,"address":[],"length":0,"stats":{"Line":2}},{"line":49,"address":[],"length":0,"stats":{"Line":2}}],"covered":16,"coverable":18},{"path":["/","Users","magnusmanske","rust","wikibase_rest_api","src","language_string.rs"],"content":"use nutype::nutype;\nuse serde::{Deserialize, Serialize};\n\n#[nutype(\n    sanitize(trim, lowercase),\n    validate(regex = \"^[a-z]{2}[a-z0-9-]*$\"),\n    derive(Debug, Display, Clone, PartialEq)\n)]\npub struct Language(String);\n\n#[derive(Debug, Clone, Default, PartialEq, Serialize, Deserialize)]\npub struct LanguageString {\n    language: String,\n    value: String,\n}\n\nimpl LanguageString {\n    /// Constructs a new `LanguageString` object from a language code and a string.\n    pub fn new<S1: Into<String>, S2: Into<String>>(language: S1, value: S2) -> LanguageString {\n        LanguageString {\n            language: language.into(),\n            value: value.into(),\n        }\n    }\n\n    /// Returns the language code of the language string.\n    pub const fn language(&self) -> &String {\n        &self.language\n    }\n\n    /// Returns the value (test) of the language string.\n    pub const fn value(&self) -> &String {\n        &self.value\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_language_string() {\n        let s = LanguageString::new(\"en\", \"Hello\");\n        assert_eq!(s.language(), \"en\");\n        assert_eq!(s.value(), \"Hello\");\n    }\n\n    #[test]\n    fn test_language_string_serialize() {\n        let s = LanguageString::new(\"en\", \"Hello\");\n        let json = serde_json::to_string(&s).unwrap();\n        assert_eq!(json, r#\"{\"language\":\"en\",\"value\":\"Hello\"}\"#);\n    }\n}\n","traces":[{"line":19,"address":[],"length":0,"stats":{"Line":58}},{"line":21,"address":[],"length":0,"stats":{"Line":58}},{"line":22,"address":[],"length":0,"stats":{"Line":58}},{"line":27,"address":[],"length":0,"stats":{"Line":59}},{"line":28,"address":[],"length":0,"stats":{"Line":59}},{"line":32,"address":[],"length":0,"stats":{"Line":72}},{"line":33,"address":[],"length":0,"stats":{"Line":72}}],"covered":7,"coverable":7},{"path":["/","Users","magnusmanske","rust","wikibase_rest_api","src","language_strings.rs"],"content":"use crate::LanguageString;\n\npub trait LanguageStrings {\n    fn insert(&mut self, ls: LanguageString);\n    fn has_language<S: Into<String>>(&self, language: S) -> bool;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","magnusmanske","rust","wikibase_rest_api","src","language_strings_patch.rs"],"content":"use crate::{\n    descriptions::Descriptions, labels::Labels, patch_entry::PatchEntry, EditMetadata, EntityId,\n    FromJson, HttpMisc, Patch, PatchApply, RestApi, RestApiError,\n};\nuse async_trait::async_trait;\nuse serde::Serialize;\nuse serde_json::{json, Value};\n\n#[derive(Debug, Clone, PartialEq, Serialize)]\nenum Mode {\n    Labels,\n    Descriptions,\n}\n\nimpl Mode {\n    const fn as_str(&self) -> &str {\n        match self {\n            Mode::Labels => \"labels\",\n            Mode::Descriptions => \"descriptions\",\n        }\n    }\n}\n\n#[derive(Debug, Clone, PartialEq, Serialize)]\npub struct LanguageStringsPatch {\n    patch: Vec<PatchEntry>,\n    mode: Mode,\n}\n\nimpl LanguageStringsPatch {\n    pub const fn labels() -> Self {\n        Self {\n            patch: vec![],\n            mode: Mode::Labels,\n        }\n    }\n\n    pub const fn descriptions() -> Self {\n        Self {\n            patch: vec![],\n            mode: Mode::Descriptions,\n        }\n    }\n\n    /// Generates a patch from JSON, presumably from `json_patch`\n    pub fn labels_from_json(j: &Value) -> Result<Self, RestApiError> {\n        Ok(Self {\n            patch: Self::from_json(j)?,\n            mode: Mode::Labels,\n        })\n    }\n\n    /// Generates a patch from JSON, presumably from `json_patch`\n    pub fn descriptions_from_json(j: &Value) -> Result<Self, RestApiError> {\n        Ok(Self {\n            patch: Self::from_json(j)?,\n            mode: Mode::Descriptions,\n        })\n    }\n\n    fn from_json(j: &Value) -> Result<Vec<PatchEntry>, RestApiError> {\n        j.as_array()\n            .ok_or_else(|| RestApiError::MissingOrInvalidField {\n                field: \"LanguageStringsPatch\".into(),\n                j: j.to_owned(),\n            })?\n            .iter()\n            .map(|x| serde_json::from_value(x.clone()).map_err(|e| e.into()))\n            .collect::<Result<Vec<PatchEntry>, RestApiError>>()\n    }\n\n    // TODO add?\n\n    /// Adds a command to replace the value of a language string.\n    /// TODO Labels?\n    pub fn replace<S1: Into<String>, S2: Into<String>>(&mut self, language: S1, value: S2) {\n        <Self as Patch>::replace(self, format!(\"/{}\", language.into()), value.into().into());\n    }\n\n    /// Adds a command to remove the value for the language.\n    /// TODO Labels?\n    pub fn remove<S: Into<String>>(&mut self, language: S) {\n        <Self as Patch>::remove(self, format!(\"/{}\", language.into()));\n    }\n}\n\nimpl Patch for LanguageStringsPatch {\n    fn patch(&self) -> &Vec<PatchEntry> {\n        &self.patch\n    }\n\n    fn patch_mut(&mut self) -> &mut Vec<PatchEntry> {\n        &mut self.patch\n    }\n}\n\n#[async_trait]\nimpl PatchApply<Labels> for LanguageStringsPatch {\n    async fn apply_match(\n        &self,\n        id: &EntityId,\n        api: &mut RestApi,\n        em: EditMetadata,\n    ) -> Result<Labels, RestApiError> {\n        let j0 = json!({\"patch\": self.patch});\n        let request = self\n            .generate_json_request(id, reqwest::Method::PATCH, j0, api, &em)\n            .await?;\n        let response = api.execute(request).await?;\n        let (j, header_info) = self.filter_response_error(response).await?;\n        Ok(Labels::from_json_header_info(&j, header_info)?)\n    }\n}\n\n#[async_trait]\nimpl PatchApply<Descriptions> for LanguageStringsPatch {\n    async fn apply_match(\n        &self,\n        id: &EntityId,\n        api: &mut RestApi,\n        em: EditMetadata,\n    ) -> Result<Descriptions, RestApiError> {\n        let j0 = json!({\"patch\": self.patch});\n        let request = self\n            .generate_json_request(id, reqwest::Method::PATCH, j0, api, &em)\n            .await?;\n        let response = api.execute(request).await?;\n        let (j, header_info) = self.filter_response_error(response).await?;\n        Ok(Descriptions::from_json_header_info(&j, header_info)?)\n    }\n}\n\nimpl HttpMisc for LanguageStringsPatch {\n    fn get_my_rest_api_path(&self, id: &EntityId) -> Result<String, RestApiError> {\n        Ok(format!(\n            \"/entities/{group}/{id}/{mode}\",\n            group = id.group()?,\n            mode = self.mode.as_str()\n        ))\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use serde_json::Value;\n    use wiremock::matchers::{bearer_token, body_partial_json, header, method, path};\n    use wiremock::{Mock, MockServer, ResponseTemplate};\n\n    #[tokio::test]\n    #[cfg_attr(miri, ignore)]\n    async fn test_language_strings_single_patch() {\n        let id = \"Q42\";\n        let page_title = \"Foo Bar\";\n        let v = std::fs::read_to_string(\"test_data/Q42.json\").unwrap();\n        let v: Value = serde_json::from_str(&v).unwrap();\n        let mut new_label = v[\"labels\"].clone();\n        new_label[\"en\"] = json!(page_title);\n\n        let mock_path = format!(\"/w/rest.php/wikibase/v1/entities/items/{id}/labels\");\n        let mock_server = MockServer::start().await;\n        let token = \"FAKE_TOKEN\";\n        Mock::given(body_partial_json(\n            json!({\"patch\":[{\"op\": \"replace\",\"path\": \"/en\",\"value\": page_title}]}),\n        ))\n        .and(method(\"PATCH\"))\n        .and(path(&mock_path))\n        .and(bearer_token(token))\n        .and(header(\"content-type\", \"application/json-patch+json\"))\n        .respond_with(\n            ResponseTemplate::new(200)\n                .insert_header(\"ETag\", \"12345\")\n                .set_body_json(new_label),\n        )\n        .mount(&mock_server)\n        .await;\n        let mut api = RestApi::builder(&(mock_server.uri() + \"/w/rest.php\"))\n            .unwrap()\n            .with_access_token(token)\n            .build();\n\n        // Apply patch and check API response\n        let id = EntityId::new(id).unwrap();\n        let mut patch = LanguageStringsPatch::labels();\n        patch.replace(\"en\", page_title);\n        let ls: Labels = patch.apply(&id, &mut api).await.unwrap();\n        assert_eq!(ls.get_lang(\"en\").unwrap(), page_title);\n    }\n\n    #[test]\n    fn test_remove() {\n        let mut patch = LanguageStringsPatch::labels();\n        patch.remove(\"en\");\n        assert_eq!(\n            patch.patch,\n            vec![PatchEntry::new(\"remove\", \"/en\", Value::Null)]\n        );\n    }\n\n    #[test]\n    fn test_patch() {\n        let mut patch = LanguageStringsPatch::labels();\n        patch.replace(\"en\", \"Foo Bar\");\n        assert_eq!(\n            patch.patch,\n            vec![PatchEntry::new(\"replace\", \"/en\", json!(\"Foo Bar\"))]\n        );\n    }\n\n    #[test]\n    fn test_descriptions() {\n        let mut patch = LanguageStringsPatch::descriptions();\n        patch.replace(\"en\", \"Foo Bar\");\n        assert_eq!(\n            patch.patch,\n            vec![PatchEntry::new(\"replace\", \"/en\", json!(\"Foo Bar\"))]\n        );\n    }\n\n    #[test]\n    fn test_mode_as_str() {\n        assert_eq!(Mode::Labels.as_str(), \"labels\");\n        assert_eq!(Mode::Descriptions.as_str(), \"descriptions\");\n    }\n\n    #[test]\n    fn test_patch_fn() {\n        let mut patch = LanguageStringsPatch::labels();\n        patch.replace(\"en\", \"Foo Bar\");\n        assert_eq!(\n            *<LanguageStringsPatch as Patch>::patch(&patch),\n            vec![PatchEntry::new(\"replace\", \"/en\", json!(\"Foo Bar\"))]\n        );\n    }\n\n    #[test]\n    fn test_from_json() {\n        let j = json!([\n            {\"op\": \"replace\", \"path\": \"/en\", \"value\": \"Foo Bar\"},\n            {\"op\": \"remove\", \"path\": \"/de\"}\n        ]);\n        let patch = LanguageStringsPatch::from_json(&j).unwrap();\n        assert_eq!(\n            patch,\n            vec![\n                PatchEntry::new(\"replace\", \"/en\", json!(\"Foo Bar\")),\n                PatchEntry::new(\"remove\", \"/de\", Value::Null)\n            ]\n        );\n    }\n}\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":3}},{"line":17,"address":[],"length":0,"stats":{"Line":3}},{"line":18,"address":[],"length":0,"stats":{"Line":2}},{"line":19,"address":[],"length":0,"stats":{"Line":1}},{"line":31,"address":[],"length":0,"stats":{"Line":4}},{"line":33,"address":[],"length":0,"stats":{"Line":4}},{"line":38,"address":[],"length":0,"stats":{"Line":1}},{"line":40,"address":[],"length":0,"stats":{"Line":1}},{"line":46,"address":[],"length":0,"stats":{"Line":2}},{"line":47,"address":[],"length":0,"stats":{"Line":2}},{"line":48,"address":[],"length":0,"stats":{"Line":2}},{"line":49,"address":[],"length":0,"stats":{"Line":2}},{"line":54,"address":[],"length":0,"stats":{"Line":2}},{"line":55,"address":[],"length":0,"stats":{"Line":2}},{"line":56,"address":[],"length":0,"stats":{"Line":2}},{"line":57,"address":[],"length":0,"stats":{"Line":2}},{"line":61,"address":[],"length":0,"stats":{"Line":5}},{"line":62,"address":[],"length":0,"stats":{"Line":5}},{"line":63,"address":[],"length":0,"stats":{"Line":5}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":15}},{"line":76,"address":[],"length":0,"stats":{"Line":4}},{"line":77,"address":[],"length":0,"stats":{"Line":4}},{"line":82,"address":[],"length":0,"stats":{"Line":1}},{"line":83,"address":[],"length":0,"stats":{"Line":1}},{"line":88,"address":[],"length":0,"stats":{"Line":3}},{"line":89,"address":[],"length":0,"stats":{"Line":3}},{"line":92,"address":[],"length":0,"stats":{"Line":5}},{"line":93,"address":[],"length":0,"stats":{"Line":5}},{"line":105,"address":[],"length":0,"stats":{"Line":1}},{"line":106,"address":[],"length":0,"stats":{"Line":2}},{"line":107,"address":[],"length":0,"stats":{"Line":1}},{"line":108,"address":[],"length":0,"stats":{"Line":1}},{"line":109,"address":[],"length":0,"stats":{"Line":1}},{"line":110,"address":[],"length":0,"stats":{"Line":1}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":1}},{"line":135,"address":[],"length":0,"stats":{"Line":1}},{"line":136,"address":[],"length":0,"stats":{"Line":1}},{"line":137,"address":[],"length":0,"stats":{"Line":1}}],"covered":38,"coverable":48},{"path":["/","Users","magnusmanske","rust","wikibase_rest_api","src","lib.rs"],"content":"#![forbid(unsafe_code)]\n#![warn(\n    clippy::cognitive_complexity,\n    clippy::dbg_macro,\n    clippy::debug_assert_with_mut_call,\n    clippy::doc_link_with_quotes,\n    clippy::doc_markdown,\n    clippy::empty_line_after_outer_attr,\n    clippy::empty_structs_with_brackets,\n    clippy::float_cmp,\n    clippy::float_cmp_const,\n    clippy::float_equality_without_abs,\n    keyword_idents,\n    // clippy::missing_const_for_fn, // Wrong calls by clippy\n    missing_copy_implementations,\n    missing_debug_implementations,\n    // clippy::missing_errors_doc,\n    clippy::missing_panics_doc,\n    clippy::mod_module_files,\n    non_ascii_idents,\n    noop_method_call,\n    clippy::option_if_let_else,\n    clippy::print_stderr,\n    clippy::print_stdout,\n    clippy::semicolon_if_nothing_returned,\n    clippy::unseparated_literal_suffix,\n    clippy::shadow_unrelated,\n    clippy::similar_names,\n    clippy::suspicious_operation_groupings,\n    unused_crate_dependencies,\n    unused_extern_crates,\n    unused_import_braces,\n    clippy::unused_self,\n    clippy::use_debug,\n    clippy::used_underscore_binding,\n    clippy::useless_let_if_seq,\n    clippy::wildcard_dependencies,\n    clippy::wildcard_imports\n)]\n\n//! **Wikibase REST API** is a Rust library for interacting with the\n//! [Wikibase REST API](https://www.wikidata.org/wiki/Wikidata:REST_API)\n//! for [Wikibase](https://www.mediawiki.org/wiki/Wikibase) instances.\n//! It provides a set of types and methods for interacting with the API,\n//! and implements all the [API endpoints](https://doc.wikimedia.org/Wikibase/master/js/rest-api/).\n\npub mod aliases;\npub mod aliases_in_language;\npub mod aliases_patch;\npub mod bearer_token;\npub mod config;\npub mod data_type;\npub mod description;\npub mod descriptions;\npub mod descriptions_patch;\npub mod edit_metadata;\npub mod entity;\npub mod entity_container;\npub mod entity_id;\npub mod entity_patch;\npub mod error;\npub mod get_put_delete;\npub mod header_info;\npub mod item;\npub mod label;\npub mod labels;\npub mod labels_patch;\npub mod language_string;\npub mod language_strings;\npub mod language_strings_patch;\npub mod patch;\npub mod patch_entry;\npub mod prelude;\npub mod property;\npub mod property_value;\npub mod reference;\npub mod rest_api;\npub mod rest_api_builder;\npub mod revision_match;\npub mod search;\npub mod sitelink;\npub mod sitelinks;\npub mod sitelinks_patch;\npub mod statement;\npub mod statement_patch;\npub mod statement_rank;\npub mod statement_value;\npub mod statement_value_content;\npub mod statements;\npub mod statements_patch;\n\npub use config::Config;\npub use data_type::DataType;\npub use edit_metadata::EditMetadata;\npub use entity_id::EntityId;\npub use error::RestApiError;\npub use get_put_delete::*;\npub use header_info::HeaderInfo;\npub use item::Item;\npub use language_string::{Language, LanguageString};\npub use patch::*;\npub use property::Property;\npub use reference::Reference;\npub use rest_api::RestApi;\npub use revision_match::RevisionMatch;\npub use sitelink::Sitelink;\npub use sitelinks::Sitelinks;\npub use statement::Statement;\npub use statement_rank::StatementRank;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","magnusmanske","rust","wikibase_rest_api","src","patch.rs"],"content":"use crate::{\n    patch_entry::PatchEntry, EditMetadata, EntityId, HeaderInfo, HttpMisc, RestApi, RestApiError,\n};\nuse async_trait::async_trait;\nuse serde_json::{json, Value};\n\n#[async_trait]\npub trait Patch: Sized {\n    /// Returns the patch entries\n    fn patch(&self) -> &Vec<PatchEntry>;\n\n    /// Returns the mutable patch entries\n    fn patch_mut(&mut self) -> &mut Vec<PatchEntry>;\n\n    /// `path` is a JSON patch path, eg \"/enwiki/title\"\n    fn add<S: Into<String>>(&mut self, path: S, value: Value) {\n        self.patch_mut()\n            .push(PatchEntry::new(\"add\", path.into(), value));\n    }\n\n    /// `path` is a JSON patch path, eg \"/enwiki/title\"\n    fn replace<S: Into<String>>(&mut self, path: S, value: Value) {\n        self.patch_mut()\n            .push(PatchEntry::new(\"replace\", path.into(), value));\n    }\n\n    /// `path` is a JSON patch path, eg \"/enwiki/title\"\n    fn remove<S: Into<String>>(&mut self, path: S) {\n        self.patch_mut()\n            .push(PatchEntry::new(\"remove\", path.into(), Value::Null));\n    }\n\n    /// checks if the patch list is empty\n    fn is_empty(&self) -> bool {\n        self.patch().is_empty()\n    }\n}\n\n#[async_trait]\npub trait PatchApply<T: FromJson>: HttpMisc + Patch {\n    /// Applies the entire patch against the API\n    async fn apply(&self, id: &EntityId, api: &mut RestApi) -> Result<T, RestApiError> {\n        self.apply_match(id, api, EditMetadata::default()).await\n    }\n\n    /// Applies the entire patch against the API, conditional on metadata\n    async fn apply_match(\n        &self,\n        id: &EntityId,\n        api: &mut RestApi,\n        em: EditMetadata,\n    ) -> Result<T, RestApiError> {\n        let j0 = json!({\"patch\": self.patch()});\n        let request = self\n            .generate_json_request(id, reqwest::Method::PATCH, j0, api, &em)\n            .await?;\n        let response = api.execute(request).await?;\n        let (j1, header_info) = self.filter_response_error(response).await?;\n        Ok(T::from_json_header_info(&j1, header_info)?)\n    }\n}\n\npub trait FromJson: Sized {\n    fn from_json_header_info(j: &Value, header_info: HeaderInfo) -> Result<Self, RestApiError>;\n    fn header_info(&self) -> &HeaderInfo;\n\n    fn from_json(j: &Value) -> Result<Self, RestApiError> {\n        Self::from_json_header_info(j, HeaderInfo::default())\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::aliases_patch::AliasesPatch;\n\n    use super::*;\n\n    #[test]\n    fn test_add() {\n        let mut p = AliasesPatch::default();\n        p.add(\"en\", json!(\"foo\"));\n        assert_eq!(\n            p.patch(),\n            &vec![PatchEntry::new(\"add\", \"en\", json!(\"foo\")),]\n        );\n    }\n\n    #[test]\n    fn test_replace() {\n        let mut p = AliasesPatch::default();\n        p.replace(\"en\", 0, \"foo\");\n        assert_eq!(\n            p.patch(),\n            &vec![PatchEntry::new(\"replace\", \"/en/0\", json!(\"foo\")),]\n        );\n    }\n\n    #[test]\n    fn test_remove() {\n        let mut p = AliasesPatch::default();\n        p.remove(\"en\", 1);\n        assert_eq!(\n            p.patch(),\n            &vec![PatchEntry::new(\"remove\", \"/en/1\", Value::Null),]\n        );\n    }\n\n    #[test]\n    fn test_is_empty() {\n        let p = AliasesPatch::default();\n        assert!(p.is_empty());\n    }\n}\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":3}},{"line":17,"address":[],"length":0,"stats":{"Line":3}},{"line":18,"address":[],"length":0,"stats":{"Line":3}},{"line":22,"address":[],"length":0,"stats":{"Line":15}},{"line":23,"address":[],"length":0,"stats":{"Line":15}},{"line":24,"address":[],"length":0,"stats":{"Line":15}},{"line":28,"address":[],"length":0,"stats":{"Line":5}},{"line":29,"address":[],"length":0,"stats":{"Line":5}},{"line":30,"address":[],"length":0,"stats":{"Line":5}},{"line":34,"address":[],"length":0,"stats":{"Line":1}},{"line":35,"address":[],"length":0,"stats":{"Line":1}},{"line":42,"address":[],"length":0,"stats":{"Line":3}},{"line":43,"address":[],"length":0,"stats":{"Line":3}},{"line":53,"address":[],"length":0,"stats":{"Line":1}},{"line":54,"address":[],"length":0,"stats":{"Line":2}},{"line":55,"address":[],"length":0,"stats":{"Line":1}},{"line":56,"address":[],"length":0,"stats":{"Line":1}},{"line":57,"address":[],"length":0,"stats":{"Line":1}},{"line":58,"address":[],"length":0,"stats":{"Line":1}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":3754}},{"line":68,"address":[],"length":0,"stats":{"Line":3754}}],"covered":21,"coverable":22},{"path":["/","Users","magnusmanske","rust","wikibase_rest_api","src","patch_entry.rs"],"content":"use serde::{Deserialize, Serialize};\nuse serde_json::Value;\n\n#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, Default)]\npub struct PatchEntry {\n    op: String,\n    path: String,\n    #[serde(default)]\n    #[serde(skip_serializing_if = \"Value::is_null\")]\n    value: Value,\n}\n\nimpl PatchEntry {\n    /// Constructs a new `PatchEntry` object from an operation, a path, and a value.\n    pub fn new<S1: Into<String>, S2: Into<String>>(op: S1, path: S2, value: Value) -> Self {\n        Self {\n            op: op.into(),\n            path: path.into(),\n            value,\n        }\n    }\n\n    /// Returns the operation.\n    pub fn op(&self) -> &str {\n        &self.op\n    }\n\n    /// Returns the path.\n    pub fn path(&self) -> &str {\n        &self.path\n    }\n\n    /// Returns the value.\n    pub const fn value(&self) -> &Value {\n        &self.value\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use serde_json::json;\n\n    #[test]\n    fn test_patch_entry() {\n        let pe = PatchEntry::new(\"replace\", \"/enwiki/title\", json!(\"Foo Bar\"));\n        assert_eq!(pe.op, \"replace\");\n        assert_eq!(pe.path, \"/enwiki/title\");\n        assert_eq!(pe.value, json!(\"Foo Bar\"));\n    }\n\n    #[test]\n    fn test_patch_entry_default() {\n        let pe = PatchEntry::default();\n        assert_eq!(pe.op, \"\");\n        assert_eq!(pe.path, \"\");\n        assert_eq!(pe.value, Value::Null);\n    }\n\n    #[test]\n    fn test_patch_entry_methods() {\n        let pe = PatchEntry::new(\"replace\", \"/enwiki/title\", json!(\"Foo Bar\"));\n        assert_eq!(pe.op(), \"replace\");\n        assert_eq!(pe.path(), \"/enwiki/title\");\n        assert_eq!(pe.value(), &json!(\"Foo Bar\"));\n    }\n}\n","traces":[{"line":15,"address":[],"length":0,"stats":{"Line":50}},{"line":17,"address":[],"length":0,"stats":{"Line":50}},{"line":18,"address":[],"length":0,"stats":{"Line":50}},{"line":24,"address":[],"length":0,"stats":{"Line":3}},{"line":25,"address":[],"length":0,"stats":{"Line":3}},{"line":29,"address":[],"length":0,"stats":{"Line":1}},{"line":30,"address":[],"length":0,"stats":{"Line":1}},{"line":34,"address":[],"length":0,"stats":{"Line":1}},{"line":35,"address":[],"length":0,"stats":{"Line":1}}],"covered":9,"coverable":9},{"path":["/","Users","magnusmanske","rust","wikibase_rest_api","src","prelude.rs"],"content":"// Traits\npub use crate::entity::Entity;\npub use crate::get_put_delete::*;\npub use crate::language_strings::LanguageStrings;\n\n// Structs and enums\npub use crate::aliases_in_language::AliasesInLanguage;\npub use crate::description::Description;\npub use crate::edit_metadata::EditMetadata;\npub use crate::entity_container::*;\npub use crate::entity_id::EntityId;\npub use crate::error::RestApiError;\npub use crate::item::Item;\npub use crate::label::Label;\npub use crate::language_string::{Language, LanguageString};\npub use crate::property::Property;\npub use crate::property_value::PropertyType;\npub use crate::rest_api::RestApi;\npub use crate::rest_api_builder::RestApiBuilder;\npub use crate::search::{Search, SearchLimit, SearchResult};\npub use crate::sitelink::Sitelink;\npub use crate::sitelinks::Sitelinks;\npub use crate::statement::Statement;\npub use crate::statement_value::StatementValue;\npub use crate::statement_value_content::{\n    StatementValueContent, TimePrecision, GREGORIAN_CALENDAR, JULIAN_CALENDAR,\n};\npub use crate::statements::Statements;\npub use crate::Patch;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","magnusmanske","rust","wikibase_rest_api","src","property.rs"],"content":"use crate::{\n    aliases::Aliases,\n    aliases_in_language::AliasesInLanguage,\n    descriptions::Descriptions,\n    entity::{Entity, EntityType},\n    entity_patch::EntityPatch,\n    labels::Labels,\n    statements::Statements,\n    EntityId, FromJson, HeaderInfo, HttpMisc, RestApi, RestApiError,\n};\nuse async_trait::async_trait;\nuse derivative::Derivative;\nuse serde::ser::{Serialize, SerializeStruct, Serializer};\nuse serde_json::Value;\n\n#[derive(Derivative, Debug, Clone, Default)]\n#[derivative(PartialEq)]\npub struct Property {\n    id: EntityId,\n    labels: Labels,\n    descriptions: Descriptions,\n    aliases: Aliases,\n    statements: Statements,\n    #[derivative(PartialEq = \"ignore\")]\n    header_info: HeaderInfo,\n}\n\nimpl HttpMisc for Property {\n    fn get_my_rest_api_path(&self, id: &EntityId) -> Result<String, RestApiError> {\n        Ok(format!(\"/entities/{}/{id}\", id.group()?))\n    }\n}\n\n#[async_trait]\nimpl Entity for Property {\n    fn id(&self) -> EntityId {\n        self.id.to_owned()\n    }\n\n    fn from_json_header_info(j: Value, header_info: HeaderInfo) -> Result<Self, RestApiError> {\n        let id = j[\"id\"]\n            .as_str()\n            .ok_or(RestApiError::MissingOrInvalidField {\n                field: \"id\".to_string(),\n                j: j.clone(),\n            })?;\n        Ok(Self {\n            id: EntityId::property(id),\n            labels: Labels::from_json(&j[\"labels\"])?,\n            descriptions: Descriptions::from_json(&j[\"descriptions\"])?,\n            aliases: Aliases::from_json(&j[\"aliases\"])?,\n            statements: Statements::from_json(&j[\"statements\"])?,\n            header_info,\n        })\n    }\n\n    async fn post(&self, api: &RestApi) -> Result<Self, RestApiError> {\n        self.post_with_type(EntityType::Property, api).await\n    }\n}\n\nimpl Serialize for Property {\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: Serializer,\n    {\n        // #lizard forgives the complexity\n        let mut fields = 5;\n        if self.id.is_some() {\n            fields += 1;\n        }\n        if self.labels.is_empty() {\n            fields -= 1;\n        }\n        if self.descriptions.is_empty() {\n            fields -= 1;\n        }\n        if self.aliases.is_empty() {\n            fields -= 1;\n        }\n        if self.statements.is_empty() {\n            fields -= 1;\n        }\n        let mut s = serializer.serialize_struct(\"Property\", fields)?;\n        if self.id.is_some() {\n            let id: String = self.id.to_owned().into();\n            s.serialize_field(\"id\", &id)?;\n        }\n        if !self.labels.is_empty() {\n            s.serialize_field(\"labels\", &self.labels)?;\n        }\n        if !self.descriptions.is_empty() {\n            s.serialize_field(\"descriptions\", &self.descriptions)?;\n        }\n        if !self.aliases.is_empty() {\n            s.serialize_field(\"aliases\", &self.aliases)?;\n        }\n        if !self.statements.is_empty() {\n            s.serialize_field(\"statements\", &self.statements)?;\n        }\n        s.end()\n    }\n}\n\nimpl Property {\n    /// Returns the statements of the property\n    pub const fn statements(&self) -> &Statements {\n        &self.statements\n    }\n\n    /// Returns the statements of the property, mutable\n    pub const fn statements_mut(&mut self) -> &mut Statements {\n        &mut self.statements\n    }\n\n    /// Returns the labels of the property\n    pub const fn labels(&self) -> &Labels {\n        &self.labels\n    }\n\n    /// Returns the labels of the property, mutable\n    pub fn labels_mut(&mut self) -> &mut Labels {\n        &mut self.labels\n    }\n\n    /// Returns the descriptions of the property\n    pub const fn descriptions(&self) -> &Descriptions {\n        &self.descriptions\n    }\n\n    /// Returns the descriptions of the property, mutable\n    pub const fn descriptions_mut(&mut self) -> &mut Descriptions {\n        &mut self.descriptions\n    }\n\n    /// Returns the aliases of the property\n    pub const fn aliases(&self) -> &Aliases {\n        &self.aliases\n    }\n\n    /// Returns the aliases of the property, mutable\n    pub fn aliases_mut(&mut self) -> &mut Aliases {\n        &mut self.aliases\n    }\n\n    /// Returns the aliases of the property for a specific language, as an `Aliases` object\n    pub fn as_aliases<S: Into<String>>(&self, lang: S) -> AliasesInLanguage {\n        let lang: String = lang.into();\n        let v: Vec<String> = self\n            .aliases\n            .get_lang(&lang)\n            .iter()\n            .map(|x| x.to_string())\n            .collect();\n        AliasesInLanguage::new(lang, v)\n    }\n\n    /// Returns the header info of the property\n    pub const fn header_info(&self) -> &HeaderInfo {\n        &self.header_info\n    }\n\n    /// Generates a patch to transform `other` into `self`\n    pub fn patch(&self, _other: &Self) -> Result<EntityPatch, RestApiError> {\n        todo!()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::language_strings::LanguageStrings;\n    use crate::{LanguageString, RestApi, Statement};\n    use serde_json::json;\n    use wiremock::matchers::{body_partial_json, method, path};\n    use wiremock::{Mock, MockServer, ResponseTemplate};\n\n    #[tokio::test]\n    #[cfg_attr(miri, ignore)]\n    async fn test_property_get_and_json_serialize() {\n        let p214 = std::fs::read_to_string(\"test_data/P214.json\").unwrap();\n        let v214: Value = serde_json::from_str(&p214).unwrap();\n\n        let mock_path = \"/w/rest.php/wikibase/v1/entities/properties/P214\";\n        let mock_server = MockServer::start().await;\n        Mock::given(method(\"GET\"))\n            .and(path(mock_path))\n            .respond_with(ResponseTemplate::new(200).set_body_json(&v214))\n            .mount(&mock_server)\n            .await;\n        let api = RestApi::builder(&(mock_server.uri() + \"/w/rest.php\"))\n            .unwrap()\n            .build();\n\n        let property = Property::get(EntityId::property(\"P214\"), &api)\n            .await\n            .unwrap();\n        let j = serde_json::to_string(&property).unwrap(); // Convert property to JSON text\n        let v: Value = serde_json::from_str(&j).unwrap(); // Convert to JSON value\n        let property_from_json = Property::from_json(v).unwrap(); // Convert back to property\n        assert_eq!(property, property_from_json); // Check if the reconstituted property is identical to the original\n    }\n\n    #[test]\n    fn test_id() {\n        let id = EntityId::property(\"P214\");\n        let property = Property {\n            id: id.to_owned(),\n            ..Default::default()\n        };\n        assert_eq!(property.id(), id);\n    }\n\n    #[test]\n    fn test_statements() {\n        let mut property = Property::default();\n        assert_eq!(property.statements().len(), 0);\n        property\n            .statements_mut()\n            .insert(Statement::new_string(\"P31\", \"Q42\"));\n        assert_eq!(property.statements().len(), 1);\n    }\n\n    #[test]\n    fn test_labels() {\n        let mut property = Property::default();\n        assert_eq!(property.labels().len(), 0);\n        property\n            .labels_mut()\n            .insert(LanguageString::new(\"en\", \"label\"));\n        assert_eq!(property.labels().len(), 1);\n    }\n\n    #[test]\n    fn test_descriptions() {\n        let mut property = Property::default();\n        assert_eq!(property.descriptions().len(), 0);\n        property\n            .descriptions_mut()\n            .insert(LanguageString::new(\"en\", \"description\"));\n        assert_eq!(property.descriptions().len(), 1);\n    }\n\n    #[test]\n    fn test_aliases() {\n        let mut property = Property::default();\n        assert_eq!(property.aliases().len(), 0);\n        property\n            .aliases_mut()\n            .insert(LanguageString::new(\"en\", \"alias\"));\n        assert_eq!(property.aliases().len(), 1);\n    }\n\n    #[test]\n    fn test_as_aliases() {\n        let mut property = Property::default();\n        property\n            .aliases_mut()\n            .insert(LanguageString::new(\"en\", \"alias\"));\n        let aliases = property.as_aliases(\"en\");\n        assert_eq!(aliases.len(), 1);\n    }\n\n    #[test]\n    fn test_header_info() {\n        let header_info = HeaderInfo::default();\n        let property = Property {\n            header_info: header_info.to_owned(),\n            ..Default::default()\n        };\n        assert_eq!(property.header_info(), &header_info);\n    }\n\n    #[test]\n    fn test_serialize() {\n        let mut property = Property {\n            id: EntityId::property(\"P214\"),\n            ..Default::default()\n        };\n        property\n            .labels_mut()\n            .insert(LanguageString::new(\"en\", \"label\"));\n        property\n            .descriptions_mut()\n            .insert(LanguageString::new(\"en\", \"description\"));\n        property\n            .aliases_mut()\n            .insert(LanguageString::new(\"en\", \"alias\"));\n        let j = serde_json::to_string(&property).unwrap();\n        let v: Value = serde_json::from_str(&j).unwrap();\n        assert_eq!(v[\"id\"], \"P214\");\n        assert_eq!(v[\"labels\"][\"en\"], \"label\");\n        assert_eq!(v[\"descriptions\"][\"en\"], \"description\");\n        assert_eq!(v[\"aliases\"][\"en\"][0], \"alias\");\n    }\n\n    #[test]\n    fn test_from_json() {\n        let v = json!({\n            \"id\": \"P214\",\n            \"labels\": {\"en\": \"label\"},\n            \"descriptions\": {\"en\": \"description\"},\n            \"aliases\": {\"en\": [\"alias\"]},\n            \"statements\": {},\n        });\n        let property = Property::from_json(v).unwrap();\n        assert_eq!(property.id(), EntityId::property(\"P214\"));\n        assert_eq!(property.labels().get_lang(\"en\").unwrap(), \"label\");\n        assert_eq!(\n            property.descriptions().get_lang(\"en\").unwrap(),\n            \"description\"\n        );\n        assert_eq!(property.aliases().get_lang(\"en\"), &[\"alias\"]);\n    }\n\n    #[tokio::test]\n    #[cfg_attr(miri, ignore)]\n    async fn test_item_post() {\n        let j214 = std::fs::read_to_string(\"test_data/P214.json\").unwrap();\n        let v214: Value = serde_json::from_str(&j214).unwrap();\n        let mut property = Property::from_json(v214).unwrap();\n        let v = property.to_owned();\n\n        let mock_server = MockServer::start().await;\n        Mock::given(method(\"POST\"))\n            .and(path(\"/w/rest.php/wikibase/v1/entities/properties\"))\n            .and(body_partial_json(\n                json!({\"property\": {\"labels\": {\"en\": property.labels().get_lang(\"en\")}}}),\n            ))\n            .respond_with(ResponseTemplate::new(200).set_body_json(&v))\n            .mount(&mock_server)\n            .await;\n        let api = RestApi::builder(&(mock_server.uri() + \"/w/rest.php\"))\n            .unwrap()\n            .build();\n\n        // Check that an error is returned when trying to post an item that already has an ID\n        let r0 = property.post(&api).await;\n        assert_eq!(r0.err().unwrap().to_string(), \"ID already set\");\n\n        // Clear the ID and try again\n        property.id = EntityId::None;\n        let r1 = property.post(&api).await.unwrap();\n        assert_eq!(r1.id(), v.id());\n    }\n}\n","traces":[{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":7}},{"line":37,"address":[],"length":0,"stats":{"Line":7}},{"line":40,"address":[],"length":0,"stats":{"Line":6}},{"line":41,"address":[],"length":0,"stats":{"Line":12}},{"line":43,"address":[],"length":0,"stats":{"Line":6}},{"line":44,"address":[],"length":0,"stats":{"Line":6}},{"line":45,"address":[],"length":0,"stats":{"Line":6}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":6}},{"line":51,"address":[],"length":0,"stats":{"Line":6}},{"line":52,"address":[],"length":0,"stats":{"Line":6}},{"line":53,"address":[],"length":0,"stats":{"Line":6}},{"line":57,"address":[],"length":0,"stats":{"Line":2}},{"line":58,"address":[],"length":0,"stats":{"Line":2}},{"line":63,"address":[],"length":0,"stats":{"Line":4}},{"line":68,"address":[],"length":0,"stats":{"Line":4}},{"line":69,"address":[],"length":0,"stats":{"Line":7}},{"line":70,"address":[],"length":0,"stats":{"Line":3}},{"line":72,"address":[],"length":0,"stats":{"Line":4}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":4}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":4}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":5}},{"line":82,"address":[],"length":0,"stats":{"Line":1}},{"line":84,"address":[],"length":0,"stats":{"Line":8}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":3}},{"line":87,"address":[],"length":0,"stats":{"Line":3}},{"line":89,"address":[],"length":0,"stats":{"Line":4}},{"line":90,"address":[],"length":0,"stats":{"Line":4}},{"line":92,"address":[],"length":0,"stats":{"Line":4}},{"line":93,"address":[],"length":0,"stats":{"Line":4}},{"line":95,"address":[],"length":0,"stats":{"Line":4}},{"line":96,"address":[],"length":0,"stats":{"Line":4}},{"line":98,"address":[],"length":0,"stats":{"Line":4}},{"line":99,"address":[],"length":0,"stats":{"Line":3}},{"line":101,"address":[],"length":0,"stats":{"Line":4}},{"line":107,"address":[],"length":0,"stats":{"Line":2}},{"line":108,"address":[],"length":0,"stats":{"Line":2}},{"line":112,"address":[],"length":0,"stats":{"Line":1}},{"line":113,"address":[],"length":0,"stats":{"Line":1}},{"line":117,"address":[],"length":0,"stats":{"Line":4}},{"line":118,"address":[],"length":0,"stats":{"Line":4}},{"line":122,"address":[],"length":0,"stats":{"Line":2}},{"line":123,"address":[],"length":0,"stats":{"Line":2}},{"line":127,"address":[],"length":0,"stats":{"Line":3}},{"line":128,"address":[],"length":0,"stats":{"Line":3}},{"line":132,"address":[],"length":0,"stats":{"Line":2}},{"line":133,"address":[],"length":0,"stats":{"Line":2}},{"line":137,"address":[],"length":0,"stats":{"Line":3}},{"line":138,"address":[],"length":0,"stats":{"Line":3}},{"line":142,"address":[],"length":0,"stats":{"Line":3}},{"line":143,"address":[],"length":0,"stats":{"Line":3}},{"line":147,"address":[],"length":0,"stats":{"Line":1}},{"line":148,"address":[],"length":0,"stats":{"Line":1}},{"line":149,"address":[],"length":0,"stats":{"Line":1}},{"line":150,"address":[],"length":0,"stats":{"Line":1}},{"line":151,"address":[],"length":0,"stats":{"Line":1}},{"line":153,"address":[],"length":0,"stats":{"Line":3}},{"line":155,"address":[],"length":0,"stats":{"Line":1}},{"line":159,"address":[],"length":0,"stats":{"Line":1}},{"line":160,"address":[],"length":0,"stats":{"Line":1}},{"line":164,"address":[],"length":0,"stats":{"Line":0}}],"covered":59,"coverable":67},{"path":["/","Users","magnusmanske","rust","wikibase_rest_api","src","property_value.rs"],"content":"use serde::ser::{Serialize, SerializeStruct, Serializer};\nuse serde_json::Value;\n\nuse crate::{statement_value::StatementValue, DataType, RestApiError};\n\n#[derive(Debug, Clone, PartialEq, Default)]\npub struct PropertyType {\n    id: String,\n    datatype: Option<DataType>,\n}\n\nimpl PropertyType {\n    /// Creates a new `PropertyType` object from an ID and a `DataType`.\n    pub fn new<S: Into<String>>(id: S, datatype: Option<DataType>) -> Self {\n        Self {\n            id: id.into(),\n            datatype,\n        }\n    }\n\n    /// Creates a new `PropertyType` object from a JSON object.\n    /// # Errors\n    /// Returns an error if the JSON object does not contain the required fields.\n    pub fn from_json(j: &Value) -> Result<Self, RestApiError> {\n        let datatype_text =\n            j[\"data_type\"]\n                .as_str()\n                .ok_or_else(|| RestApiError::MissingOrInvalidField {\n                    field: \"data_type\".into(),\n                    j: j.to_owned(),\n                })?;\n        let datatype = DataType::new(datatype_text).ok();\n        Ok(Self {\n            id: j[\"id\"]\n                .as_str()\n                .ok_or_else(|| RestApiError::MissingOrInvalidField {\n                    field: \"id\".into(),\n                    j: j.to_owned(),\n                })?\n                .to_string(),\n            datatype,\n        })\n    }\n\n    /// Creates a new `PropertyType` object from an ID, with a default `DataType::WikibaseItem`.\n    pub fn property<S: Into<String>>(id: S) -> Self {\n        Self {\n            id: id.into(),\n            datatype: None,\n        }\n    }\n\n    /// Returns the ID of the `PropertyType`.\n    pub fn id(&self) -> &str {\n        &self.id\n    }\n\n    /// Returns the `DataType` of the `PropertyType`.\n    pub const fn datatype(&self) -> &Option<DataType> {\n        &self.datatype\n    }\n}\n\nimpl Serialize for PropertyType {\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: Serializer,\n    {\n        let num = 1 + if self.datatype.is_some() { 1 } else { 0 };\n        let mut s = serializer.serialize_struct(\"PropertyType\", num)?;\n        s.serialize_field(\"id\", &self.id)?;\n        if let Some(datatype) = &self.datatype {\n            s.serialize_field(\"data_type\", datatype.as_str())?;\n        }\n        s.end()\n    }\n}\n\n/// Implement the From trait for &str to `PropertyType`, for convenience assignments.\nimpl From<&str> for PropertyType {\n    fn from(s: &str) -> Self {\n        Self::property(s)\n    }\n}\n\n#[derive(Debug, Clone, PartialEq)]\npub struct PropertyValue {\n    property: PropertyType,\n    value: StatementValue,\n}\n\nimpl PropertyValue {\n    pub const fn new(property: PropertyType, value: StatementValue) -> Self {\n        Self { property, value }\n    }\n\n    pub const fn property(&self) -> &PropertyType {\n        &self.property\n    }\n\n    pub const fn value(&self) -> &StatementValue {\n        &self.value\n    }\n}\n\nimpl Serialize for PropertyValue {\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: Serializer,\n    {\n        let mut s = serializer.serialize_struct(\"PropertyValue\", 2)?;\n        s.serialize_field(\"property\", &self.property)?;\n        s.serialize_field(\"value\", &self.value)?;\n        s.end()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::statement_value_content::StatementValueContent;\n\n    use super::*;\n\n    #[test]\n    fn test_property_type() {\n        let j = serde_json::json!({\n            \"id\": \"P123\",\n            \"data_type\": \"string\",\n        });\n        let p = PropertyType::from_json(&j).unwrap();\n        assert_eq!(p.id(), \"P123\");\n        assert_eq!(p.datatype(), &Some(DataType::String));\n    }\n\n    #[test]\n    fn test_property_value() {\n        let j = serde_json::json!({\n            \"id\": \"P123\",\n            \"data_type\": \"string\",\n        });\n        let p = PropertyType::from_json(&j).unwrap();\n        let v = StatementValueContent::String(\"Hello\".to_string());\n        let pv = PropertyValue::new(p, v.into());\n        assert_eq!(pv.property().id(), \"P123\");\n        assert_eq!(pv.property().datatype(), &Some(DataType::String));\n        assert_eq!(\n            pv.value(),\n            &StatementValue::Value(StatementValueContent::String(\"Hello\".to_string()))\n        );\n    }\n\n    #[test]\n    fn test_property_type_serialize() {\n        let j = serde_json::json!({\n            \"id\": \"P123\",\n            \"data_type\": \"string\",\n        });\n        let p = PropertyType::from_json(&j).unwrap();\n        let json = serde_json::to_string(&p).unwrap();\n        assert_eq!(json, r#\"{\"id\":\"P123\",\"data_type\":\"string\"}\"#);\n    }\n\n    #[test]\n    fn test_property_type_serialize_faulty_data_type() {\n        let j = serde_json::json!({\n            \"id\": \"P123\",\n            \"data_type\": 567,\n        });\n        let pt = PropertyType::from_json(&j);\n        assert!(pt.is_err());\n    }\n\n    #[test]\n    fn test_property_type_serialize_faulty_id() {\n        let j = serde_json::json!({\n            \"id\": 123,\n            \"data_type\": \"string\",\n        });\n        let pt = PropertyType::from_json(&j);\n        assert!(pt.is_err());\n    }\n}\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":7}},{"line":16,"address":[],"length":0,"stats":{"Line":7}},{"line":24,"address":[],"length":0,"stats":{"Line":9814}},{"line":25,"address":[],"length":0,"stats":{"Line":9813}},{"line":26,"address":[],"length":0,"stats":{"Line":9814}},{"line":28,"address":[],"length":0,"stats":{"Line":9815}},{"line":29,"address":[],"length":0,"stats":{"Line":1}},{"line":30,"address":[],"length":0,"stats":{"Line":1}},{"line":36,"address":[],"length":0,"stats":{"Line":1}},{"line":37,"address":[],"length":0,"stats":{"Line":1}},{"line":38,"address":[],"length":0,"stats":{"Line":1}},{"line":40,"address":[],"length":0,"stats":{"Line":9812}},{"line":41,"address":[],"length":0,"stats":{"Line":9812}},{"line":46,"address":[],"length":0,"stats":{"Line":20}},{"line":48,"address":[],"length":0,"stats":{"Line":20}},{"line":54,"address":[],"length":0,"stats":{"Line":20}},{"line":55,"address":[],"length":0,"stats":{"Line":20}},{"line":59,"address":[],"length":0,"stats":{"Line":2}},{"line":60,"address":[],"length":0,"stats":{"Line":2}},{"line":65,"address":[],"length":0,"stats":{"Line":3113}},{"line":69,"address":[],"length":0,"stats":{"Line":9339}},{"line":70,"address":[],"length":0,"stats":{"Line":6226}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":6220}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":3113}},{"line":81,"address":[],"length":0,"stats":{"Line":13}},{"line":82,"address":[],"length":0,"stats":{"Line":13}},{"line":93,"address":[],"length":0,"stats":{"Line":6117}},{"line":97,"address":[],"length":0,"stats":{"Line":2}},{"line":98,"address":[],"length":0,"stats":{"Line":2}},{"line":101,"address":[],"length":0,"stats":{"Line":2}},{"line":102,"address":[],"length":0,"stats":{"Line":2}},{"line":107,"address":[],"length":0,"stats":{"Line":2010}},{"line":111,"address":[],"length":0,"stats":{"Line":4020}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":2010}},{"line":114,"address":[],"length":0,"stats":{"Line":2010}}],"covered":35,"coverable":38},{"path":["/","Users","magnusmanske","rust","wikibase_rest_api","src","reference.rs"],"content":"use crate::{\n    property_value::{PropertyType, PropertyValue},\n    statement_value::StatementValue,\n    RestApiError,\n};\nuse serde::ser::{Serialize, SerializeStruct, Serializer};\nuse serde_json::Value;\n\n#[derive(Debug, Clone, PartialEq, Default)]\npub struct Reference {\n    parts: Vec<PropertyValue>,\n    hash: String,\n}\n\nimpl Reference {\n    /// Creates a new Reference object from a JSON structure\n    /// # Errors\n    /// Returns an error if the JSON structure is missing a required field or if a field is invalid\n    pub fn from_json(j: &Value) -> Result<Self, RestApiError> {\n        // #lizard forgives the complexity\n        let hash = j[\"hash\"]\n            .as_str()\n            .ok_or_else(|| RestApiError::MissingOrInvalidField {\n                field: \"hash\".into(),\n                j: j.to_owned(),\n            })?\n            .to_string();\n        let parts = j[\"parts\"]\n            .as_array()\n            .ok_or_else(|| RestApiError::MissingOrInvalidField {\n                field: \"parts\".into(),\n                j: j.to_owned(),\n            })?\n            .iter() // TODO was par_iter but miri doesn't like rayon...\n            .map(|part| {\n                let property = PropertyType::from_json(&part[\"property\"])?;\n                let value = StatementValue::from_json(&part[\"value\"])?;\n                Ok(PropertyValue::new(property, value))\n            })\n            .collect::<Result<Vec<PropertyValue>, RestApiError>>()?;\n        Ok(Reference { parts, hash })\n    }\n\n    /// Returns the parts of the reference\n    pub fn parts(&self) -> &[PropertyValue] {\n        &self.parts\n    }\n\n    /// Returns the hash of the reference\n    pub fn hash(&self) -> &str {\n        &self.hash\n    }\n\n    pub const fn parts_mut(&mut self) -> &mut Vec<PropertyValue> {\n        &mut self.parts\n    }\n}\n\nimpl Serialize for Reference {\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: Serializer,\n    {\n        let mut s = serializer.serialize_struct(\"Reference\", 2)?;\n        s.serialize_field(\"hash\", &self.hash)?;\n        s.serialize_field(\"parts\", &self.parts)?;\n        s.end()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_parts() {\n        let reference = Reference {\n            parts: vec![PropertyValue::new(\n                PropertyType::new(\"P123\", None),\n                StatementValue::new_string(\"test\"),\n            )],\n            hash: \"hash\".to_string(),\n        };\n        assert_eq!(\n            reference.parts(),\n            &[PropertyValue::new(\n                PropertyType::new(\"P123\", None),\n                StatementValue::new_string(\"test\")\n            )]\n        );\n    }\n\n    #[test]\n    fn test_from_json_err() {\n        let json = r#\"{\"hash\":\"hash\",\"parts\":12345}\"#;\n        assert!(Reference::from_json(&serde_json::from_str(json).unwrap()).is_err());\n    }\n\n    #[test]\n    fn test_parts_mut() {\n        let mut reference = Reference {\n            parts: vec![PropertyValue::new(\n                PropertyType::new(\"P123\", None),\n                StatementValue::new_string(\"test\"),\n            )],\n            hash: \"hash\".to_string(),\n        };\n        reference.parts_mut().push(PropertyValue::new(\n            PropertyType::new(\"P456\", None),\n            StatementValue::new_string(\"test\"),\n        ));\n        assert_eq!(\n            reference.parts(),\n            &[\n                PropertyValue::new(\n                    PropertyType::new(\"P123\", None),\n                    StatementValue::new_string(\"test\")\n                ),\n                PropertyValue::new(\n                    PropertyType::new(\"P456\", None),\n                    StatementValue::new_string(\"test\")\n                )\n            ]\n        );\n    }\n\n    #[test]\n    fn test_hash() {\n        let reference = Reference {\n            parts: vec![PropertyValue::new(\n                PropertyType::new(\"P123\", None),\n                StatementValue::new_string(\"test\"),\n            )],\n            hash: \"hash\".to_string(),\n        };\n        assert_eq!(reference.hash(), \"hash\");\n    }\n}\n","traces":[{"line":19,"address":[],"length":0,"stats":{"Line":1594}},{"line":21,"address":[],"length":0,"stats":{"Line":3187}},{"line":23,"address":[],"length":0,"stats":{"Line":1595}},{"line":24,"address":[],"length":0,"stats":{"Line":1}},{"line":25,"address":[],"length":0,"stats":{"Line":1}},{"line":28,"address":[],"length":0,"stats":{"Line":1592}},{"line":30,"address":[],"length":0,"stats":{"Line":1}},{"line":31,"address":[],"length":0,"stats":{"Line":1}},{"line":32,"address":[],"length":0,"stats":{"Line":1}},{"line":35,"address":[],"length":0,"stats":{"Line":6105}},{"line":36,"address":[],"length":0,"stats":{"Line":9026}},{"line":37,"address":[],"length":0,"stats":{"Line":4513}},{"line":45,"address":[],"length":0,"stats":{"Line":2}},{"line":46,"address":[],"length":0,"stats":{"Line":2}},{"line":50,"address":[],"length":0,"stats":{"Line":1}},{"line":51,"address":[],"length":0,"stats":{"Line":1}},{"line":54,"address":[],"length":0,"stats":{"Line":1}},{"line":55,"address":[],"length":0,"stats":{"Line":1}},{"line":60,"address":[],"length":0,"stats":{"Line":471}},{"line":64,"address":[],"length":0,"stats":{"Line":942}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":471}},{"line":67,"address":[],"length":0,"stats":{"Line":471}}],"covered":22,"coverable":23},{"path":["/","Users","magnusmanske","rust","wikibase_rest_api","src","rest_api.rs"],"content":"use crate::{bearer_token::BearerToken, rest_api_builder::RestApiBuilder, RestApiError};\nuse reqwest::header::HeaderMap;\nuse std::{collections::HashMap, sync::Arc};\nuse tokio::sync::RwLock;\n\n#[derive(Debug, Clone)]\npub struct RestApi {\n    client: reqwest::Client,\n    user_agent: String,\n    api_url: String,\n    api_version: u8,\n    pub token: Arc<RwLock<BearerToken>>,\n}\n\nimpl RestApi {\n    /// Returns a `RestApiBuilder`. Wrapper around `RestApiBuilder::new()`.\n    pub fn builder<S: Into<String>>(api_url: S) -> Result<RestApiBuilder, RestApiError> {\n        RestApiBuilder::new(api_url)\n    }\n\n    /// Returns the user agent\n    pub fn user_agent(&self) -> &str {\n        &self.user_agent\n    }\n\n    /// Returns the API version\n    pub const fn api_version(&self) -> u8 {\n        self.api_version\n    }\n\n    /// Returns a `RequestBuilder` for a Wikibase REST API request\n    /// # Errors\n    /// Returns an error if the headers cannot be created\n    pub async fn wikibase_request_builder<S: Into<String>>(\n        &self,\n        path: S,\n        params: HashMap<String, String>,\n        method: reqwest::Method,\n    ) -> Result<reqwest::RequestBuilder, RestApiError> {\n        let mut headers = self.headers().await?;\n        headers.insert(reqwest::header::ACCEPT, \"application/json\".parse()?);\n        match method {\n            reqwest::Method::GET => {}\n            reqwest::Method::PATCH => {\n                headers.insert(\n                    reqwest::header::CONTENT_TYPE,\n                    reqwest::header::HeaderValue::from_static(\"json-patch+json\"),\n                );\n            }\n            _ => {\n                headers.insert(\n                    reqwest::header::CONTENT_TYPE,\n                    reqwest::header::HeaderValue::from_static(\"application/json\"),\n                );\n            }\n        }\n        let wikibase_path = format!(\"{}{}\", self.wikibase_root(), path.into());\n        self.request_builder(&wikibase_path, headers, params, method)\n    }\n\n    /// Returns a `RestApi` instance for Wikidata\n    pub fn wikidata() -> Result<RestApi, RestApiError> {\n        Ok(RestApi::builder(\"https://www.wikidata.org/w/rest.php\")?.build())\n    }\n\n    /// Executes a `reqwest::Request`, and returns a `reqwest::Response`.\n    /// # Errors\n    /// Returns an error if the request cannot be executed\n    pub async fn execute(\n        &self,\n        request: reqwest::Request,\n    ) -> Result<reqwest::Response, RestApiError> {\n        self.token.write().await.check(self, &request).await?;\n        let response = self.client.execute(request).await?;\n        Ok(response)\n    }\n\n    /// Returns the `OpenAPI` JSON for the Wikibase REST API\n    pub async fn get_openapi_json(&self) -> Result<serde_json::Value, RestApiError> {\n        let request = self\n            .wikibase_request_builder(\"/openapi.json\", HashMap::new(), reqwest::Method::GET)\n            .await?\n            .build()?;\n        let response = self.execute(request).await?;\n        let json = response.json().await?;\n        Ok(json)\n    }\n\n    /// Returns the API URL\n    pub fn api_url(&self) -> &str {\n        &self.api_url\n    }\n\n    /// Returns the `reqwest::Client`\n    pub const fn client(&self) -> &reqwest::Client {\n        &self.client\n    }\n\n    /// Creates a new `RestApi` instance.\n    /// Only available internally, use `RestApi::builder()` instead.\n    pub(crate) const fn new(\n        client: reqwest::Client,\n        user_agent: String,\n        api_url: String,\n        api_version: u8,\n        token: Arc<RwLock<BearerToken>>,\n    ) -> Self {\n        Self {\n            client,\n            user_agent,\n            api_url,\n            api_version,\n            token,\n        }\n    }\n\n    /// Returns a `HeaderMap` with the user agent and `OAuth2` bearer token (if present).\n    /// Only available internally.\n    pub(crate) async fn headers_from_token(\n        &self,\n        token: &BearerToken,\n    ) -> Result<HeaderMap, RestApiError> {\n        let mut headers = HeaderMap::new();\n        headers.insert(reqwest::header::USER_AGENT, self.user_agent.parse()?);\n        if let Some(access_token) = &token.get() {\n            headers.insert(\n                reqwest::header::AUTHORIZATION,\n                format!(\"Bearer {}\", access_token).parse()?,\n            );\n        }\n        Ok(headers)\n    }\n\n    pub fn token(&self) -> Arc<RwLock<BearerToken>> {\n        self.token.clone()\n    }\n\n    /// Returns the root path for the Wikibase REST API, based on the version number\n    fn wikibase_root(&self) -> String {\n        format!(\"/wikibase/v{}\", self.api_version)\n    }\n\n    /// Builds a `reqwest::RequestBuilder` from the method, client, path, and parameters\n    fn request_builder<S: Into<String>>(\n        &self,\n        path: S,\n        headers: HeaderMap,\n        params: HashMap<String, String>,\n        method: reqwest::Method,\n    ) -> Result<reqwest::RequestBuilder, RestApiError> {\n        let url = format!(\"{}{}\", self.api_url, path.into());\n        Ok(match method {\n            reqwest::Method::GET => self.client.get(url).headers(headers).query(&params),\n            reqwest::Method::POST => self.client.post(url).headers(headers).form(&params),\n            reqwest::Method::PATCH => self.client.patch(url).headers(headers).form(&params),\n            reqwest::Method::PUT => self.client.put(url).headers(headers).form(&params),\n            reqwest::Method::DELETE => self.client.delete(url).headers(headers).form(&params),\n            _ => return Err(RestApiError::UnsupportedMethod(method)),\n        })\n    }\n\n    /// Returns a `HeaderMap` with the user agent and `OAuth2` bearer token (if present)\n    async fn headers(&self) -> Result<HeaderMap, RestApiError> {\n        let token = self.token.read().await;\n        self.headers_from_token(&token).await\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use wiremock::matchers::{method, path};\n    use wiremock::{Mock, MockServer, ResponseTemplate};\n\n    #[tokio::test]\n    #[cfg_attr(miri, ignore)]\n    async fn test_get_openapi_json() {\n        let expected_json = std::fs::read_to_string(\"test_data/openapi.json\").unwrap();\n        let expected_json: serde_json::Value = serde_json::from_str(&expected_json).unwrap();\n        let mock_path = \"/w/rest.php/wikibase/v1/openapi.json\";\n        let mock_server = MockServer::start().await;\n        Mock::given(method(\"GET\"))\n            .and(path(mock_path))\n            .respond_with(ResponseTemplate::new(200).set_body_json(expected_json.clone()))\n            .mount(&mock_server)\n            .await;\n        let api = RestApi::builder(&(mock_server.uri() + \"/w/rest.php\"))\n            .unwrap()\n            .build();\n\n        let json = api.get_openapi_json().await.unwrap();\n        assert_eq!(json, expected_json);\n    }\n\n    #[test]\n    #[cfg_attr(miri, ignore)] // TODO this should work in miri\n    fn test_client() {\n        let client = reqwest::Client::new();\n        let api = RestApi::builder(\"https://test.wikidata.org/w/rest.php\")\n            .unwrap()\n            .with_client(client.clone())\n            .build();\n        assert_eq!(format!(\"{:?}\", api.client), format!(\"{:?}\", client));\n    }\n}\n","traces":[{"line":17,"address":[],"length":0,"stats":{"Line":57}},{"line":18,"address":[],"length":0,"stats":{"Line":57}},{"line":22,"address":[],"length":0,"stats":{"Line":2}},{"line":23,"address":[],"length":0,"stats":{"Line":2}},{"line":27,"address":[],"length":0,"stats":{"Line":2}},{"line":28,"address":[],"length":0,"stats":{"Line":2}},{"line":34,"address":[],"length":0,"stats":{"Line":49}},{"line":40,"address":[],"length":0,"stats":{"Line":98}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":49}},{"line":43,"address":[],"length":0,"stats":{"Line":31}},{"line":44,"address":[],"length":0,"stats":{"Line":4}},{"line":45,"address":[],"length":0,"stats":{"Line":4}},{"line":46,"address":[],"length":0,"stats":{"Line":4}},{"line":47,"address":[],"length":0,"stats":{"Line":4}},{"line":50,"address":[],"length":0,"stats":{"Line":14}},{"line":51,"address":[],"length":0,"stats":{"Line":14}},{"line":52,"address":[],"length":0,"stats":{"Line":14}},{"line":53,"address":[],"length":0,"stats":{"Line":14}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":49}},{"line":73,"address":[],"length":0,"stats":{"Line":98}},{"line":74,"address":[],"length":0,"stats":{"Line":98}},{"line":79,"address":[],"length":0,"stats":{"Line":2}},{"line":80,"address":[],"length":0,"stats":{"Line":2}},{"line":81,"address":[],"length":0,"stats":{"Line":1}},{"line":82,"address":[],"length":0,"stats":{"Line":1}},{"line":84,"address":[],"length":0,"stats":{"Line":1}},{"line":85,"address":[],"length":0,"stats":{"Line":1}},{"line":90,"address":[],"length":0,"stats":{"Line":3}},{"line":91,"address":[],"length":0,"stats":{"Line":3}},{"line":95,"address":[],"length":0,"stats":{"Line":4}},{"line":96,"address":[],"length":0,"stats":{"Line":4}},{"line":101,"address":[],"length":0,"stats":{"Line":57}},{"line":119,"address":[],"length":0,"stats":{"Line":51}},{"line":123,"address":[],"length":0,"stats":{"Line":51}},{"line":124,"address":[],"length":0,"stats":{"Line":51}},{"line":125,"address":[],"length":0,"stats":{"Line":67}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":51}},{"line":134,"address":[],"length":0,"stats":{"Line":6}},{"line":135,"address":[],"length":0,"stats":{"Line":6}},{"line":139,"address":[],"length":0,"stats":{"Line":49}},{"line":140,"address":[],"length":0,"stats":{"Line":49}},{"line":144,"address":[],"length":0,"stats":{"Line":49}},{"line":151,"address":[],"length":0,"stats":{"Line":49}},{"line":152,"address":[],"length":0,"stats":{"Line":49}},{"line":153,"address":[],"length":0,"stats":{"Line":31}},{"line":154,"address":[],"length":0,"stats":{"Line":5}},{"line":155,"address":[],"length":0,"stats":{"Line":4}},{"line":156,"address":[],"length":0,"stats":{"Line":4}},{"line":157,"address":[],"length":0,"stats":{"Line":5}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":98}},{"line":164,"address":[],"length":0,"stats":{"Line":98}},{"line":165,"address":[],"length":0,"stats":{"Line":49}}],"covered":52,"coverable":59},{"path":["/","Users","magnusmanske","rust","wikibase_rest_api","src","rest_api_builder.rs"],"content":"use crate::{bearer_token::BearerToken, RestApi, RestApiError};\nuse std::sync::Arc;\nuse tokio::sync::RwLock;\n\n/// The default user agent\nconst DEFAULT_USER_AGENT: &str = \"Rust Wikibase REST API\";\n\n/// The latest supported version of the Wikibase REST API\nconst WIKIBASE_REST_API_VERSION: u8 = 1;\n\n#[derive(Debug)]\npub struct RestApiBuilder {\n    client: Option<reqwest::Client>,\n    token: BearerToken,\n    user_agent: Option<String>,\n    api_url: String,\n    api_version: Option<u8>,\n    renewal_interval: Option<std::time::Duration>,\n}\n\nimpl RestApiBuilder {\n    /// Sets the REST API URL, specifically the URL ending in \"rest.php\". This in mandatory.\n    /// # Errors\n    /// Returns an error if REST API URL is invalid.\n    pub fn new<S: Into<String>>(api_url: S) -> Result<Self, RestApiError> {\n        let api_url = Self::validate_api_url(&api_url.into())?;\n        Ok(Self {\n            client: None,\n            token: BearerToken::default(),\n            user_agent: None,\n            api_url,\n            api_version: None,\n            renewal_interval: None,\n        })\n    }\n\n    /// Sets the API version (u8). Default is 1.\n    pub const fn with_api_version(mut self, api_version: u8) -> Self {\n        self.api_version = Some(api_version);\n        self\n    }\n\n    /// Sets the `OAuth2` bearer token.\n    pub fn with_access_token<S: Into<String>>(mut self, access_token: S) -> Self {\n        self.token.set_access_token(access_token);\n        self\n    }\n\n    /// Sets the user agent. By default, the user agent is \"Rust Wikibase REST API; {`package_name`}/{`package_version`}\"\n    pub fn with_user_agent<S: Into<String>>(mut self, user_agent: S) -> Self {\n        self.user_agent = Some(user_agent.into());\n        self\n    }\n\n    /// Sets the `reqwest::Client`. By default, a new `reqwest::Client` is created.\n    pub fn with_client(mut self, client: reqwest::Client) -> Self {\n        self.client = Some(client);\n        self\n    }\n\n    /// Sets the interval for bearer token renewal. By default, the interval is `DEFAULT_RENEWAL_INTERVAL_SEC`.\n    #[cfg(not(tarpaulin_include))]\n    pub const fn with_access_token_renewal(\n        mut self,\n        renewal_interval: std::time::Duration,\n    ) -> Self {\n        self.renewal_interval = Some(renewal_interval);\n        self\n    }\n\n    /// Sets the `OAuth2` client ID and client secret\n    #[cfg(not(tarpaulin_include))]\n    pub fn with_oauth2_info<S1: Into<String>, S2: Into<String>>(\n        mut self,\n        client_id: S1,\n        client_secret: S2,\n    ) -> Self {\n        self.token.set_oauth2_info(client_id, client_secret);\n        self\n    }\n\n    /// Builds the `RestApi`. Returns an error if no REST API URL is set.\n    /// The builder gets consumed by this operation.\n    /// # Returns\n    /// Returns a `RestApi` instance.\n    pub fn build(self) -> RestApi {\n        let api_url = self.api_url;\n        let mut token = self.token;\n        if let Some(interval) = self.renewal_interval {\n            token.set_renewal_interval(interval.as_secs());\n        }\n        let token = Arc::new(RwLock::new(token));\n        let user_agent = self.user_agent.unwrap_or(Self::default_user_agent());\n        let api_version = self.api_version.unwrap_or(WIKIBASE_REST_API_VERSION);\n        let client = self.client.unwrap_or_default(); // TODO check why miri fails here\n        RestApi::new(client, user_agent, api_url, api_version, token)\n    }\n\n    /// Checks if the REST API URL is valid. The URL must end in \"rest.php\".\n    /// Removes anything beyone that.\n    fn validate_api_url(api_url: &str) -> Result<String, RestApiError> {\n        let (base, _rest) = api_url\n            .split_once(\"/rest.php\")\n            .ok_or_else(|| RestApiError::RestApiUrlInvalid(api_url.to_owned()))?;\n        let ret = format!(\"{base}/rest.php\");\n        Ok(ret)\n    }\n\n    /// Returns the default user agent, a versioned string based on `DEFAULT_USER_AGENT`.\n    fn default_user_agent() -> String {\n        format!(\n            \"{DEFAULT_USER_AGENT}; {}/{}\",\n            env!(\"CARGO_PKG_NAME\"),\n            env!(\"CARGO_PKG_VERSION\")\n        )\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::time::Duration;\n\n    #[test]\n    fn test_default_user_agent() {\n        let user_agent = RestApiBuilder::default_user_agent();\n        assert!(user_agent.starts_with(DEFAULT_USER_AGENT));\n        assert!(user_agent.contains(env!(\"CARGO_PKG_NAME\")));\n        assert!(user_agent.contains(env!(\"CARGO_PKG_VERSION\")));\n    }\n\n    #[test]\n    fn test_validate_api_url_default() {\n        let builder = RestApiBuilder::new(\"foobar\");\n        assert!(builder.is_err());\n    }\n\n    #[test]\n    fn test_validate_api_url_api() {\n        let builder = RestApiBuilder::new(\"https://www.wikidata.org/w/api.php\");\n        assert!(builder.is_err());\n    }\n\n    #[test]\n    fn test_validate_api_url_rest_api() {\n        let builder = RestApiBuilder::new(\"https://www.wikidata.org/w/rest.php\");\n        assert!(builder.is_ok());\n    }\n\n    #[test]\n    #[cfg_attr(miri, ignore)] // TODO this should work in miri\n    fn test_user_agent() {\n        let api1 = RestApi::builder(\"https://test.wikidata.org/w/rest.php\")\n            .unwrap()\n            .build();\n        assert_eq!(api1.user_agent(), RestApiBuilder::default_user_agent());\n\n        let api2 = RestApi::builder(\"https://test.wikidata.org/w/rest.php\")\n            .unwrap()\n            .with_user_agent(\"Test User Agent\")\n            .build();\n        assert_eq!(api2.user_agent(), \"Test User Agent\");\n    }\n\n    #[test]\n    #[cfg_attr(miri, ignore)] // TODO this should work in miri\n    fn test_with_api_version() {\n        let api1 = RestApi::builder(\"https://test.wikidata.org/w/rest.php\")\n            .unwrap()\n            .build();\n        assert_eq!(api1.api_version(), WIKIBASE_REST_API_VERSION);\n\n        let api2 = RestApi::builder(\"https://test.wikidata.org/w/rest.php\")\n            .unwrap()\n            .with_api_version(2)\n            .build();\n        assert_eq!(api2.api_version(), 2);\n    }\n\n    #[tokio::test]\n    #[cfg_attr(miri, ignore)]\n    async fn test_with_access_token_renewal() {\n        let api1 = RestApi::builder(\"https://test.wikidata.org/w/rest.php\")\n            .unwrap()\n            .build();\n        assert_eq!(\n            api1.token().read().await.access_token_renewal_interval(),\n            Duration::from_secs(0)\n        );\n\n        let api2 = RestApi::builder(\"https://test.wikidata.org/w/rest.php\")\n            .unwrap()\n            .with_access_token_renewal(std::time::Duration::from_secs(60))\n            .build();\n        assert_eq!(\n            api2.token().read().await.access_token_renewal_interval(),\n            Duration::from_secs(60)\n        );\n    }\n\n    #[tokio::test]\n    #[cfg_attr(miri, ignore)]\n    async fn test_with_oauth2_info() {\n        let api1 = RestApi::builder(\"https://test.wikidata.org/w/rest.php\")\n            .unwrap()\n            .build();\n        assert_eq!(*api1.token().read().await.client_id(), None);\n        assert_eq!(*api1.token().read().await.client_secret(), None);\n\n        let api2 = RestApi::builder(\"https://test.wikidata.org/w/rest.php\")\n            .unwrap()\n            .with_oauth2_info(\"client_id\", \"client_secret\")\n            .build();\n        assert_eq!(\n            *api2.token().read().await.client_id(),\n            Some(\"client_id\".to_string())\n        );\n        assert_eq!(\n            *api2.token().read().await.client_secret(),\n            Some(\"client_secret\".to_string())\n        );\n    }\n}\n","traces":[{"line":25,"address":[],"length":0,"stats":{"Line":60}},{"line":26,"address":[],"length":0,"stats":{"Line":120}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":2}},{"line":39,"address":[],"length":0,"stats":{"Line":2}},{"line":40,"address":[],"length":0,"stats":{"Line":2}},{"line":44,"address":[],"length":0,"stats":{"Line":13}},{"line":45,"address":[],"length":0,"stats":{"Line":13}},{"line":46,"address":[],"length":0,"stats":{"Line":13}},{"line":50,"address":[],"length":0,"stats":{"Line":1}},{"line":51,"address":[],"length":0,"stats":{"Line":1}},{"line":52,"address":[],"length":0,"stats":{"Line":1}},{"line":56,"address":[],"length":0,"stats":{"Line":1}},{"line":57,"address":[],"length":0,"stats":{"Line":1}},{"line":58,"address":[],"length":0,"stats":{"Line":1}},{"line":86,"address":[],"length":0,"stats":{"Line":57}},{"line":87,"address":[],"length":0,"stats":{"Line":57}},{"line":88,"address":[],"length":0,"stats":{"Line":57}},{"line":89,"address":[],"length":0,"stats":{"Line":58}},{"line":92,"address":[],"length":0,"stats":{"Line":57}},{"line":93,"address":[],"length":0,"stats":{"Line":57}},{"line":94,"address":[],"length":0,"stats":{"Line":57}},{"line":95,"address":[],"length":0,"stats":{"Line":57}},{"line":96,"address":[],"length":0,"stats":{"Line":57}},{"line":101,"address":[],"length":0,"stats":{"Line":60}},{"line":102,"address":[],"length":0,"stats":{"Line":118}},{"line":104,"address":[],"length":0,"stats":{"Line":124}},{"line":110,"address":[],"length":0,"stats":{"Line":59}},{"line":111,"address":[],"length":0,"stats":{"Line":59}},{"line":113,"address":[],"length":0,"stats":{"Line":59}},{"line":114,"address":[],"length":0,"stats":{"Line":59}}],"covered":30,"coverable":37},{"path":["/","Users","magnusmanske","rust","wikibase_rest_api","src","revision_match.rs"],"content":"use crate::RestApiError;\nuse chrono::prelude::*;\nuse reqwest::header::{HeaderMap, HeaderValue};\n\n#[derive(Debug, Default, Clone, PartialEq)]\npub struct RevisionMatch {\n    modified_since_revisions: Vec<u64>,\n    modified_since_date: Option<NaiveDateTime>,\n    unmodified_since_revisions: Vec<u64>,\n    unmodified_since_date: Option<NaiveDateTime>,\n    if_match: Vec<String>,\n    if_none_match: Vec<String>,\n}\n\nimpl RevisionMatch {\n    pub fn modify_headers(&self, headers: &mut HeaderMap) -> Result<(), RestApiError> {\n        if let Some(date) = self.modified_since_date {\n            let hvs = format!(\"{}\", date.format(\"%c\"));\n            let hv = HeaderValue::from_str(&hvs)?;\n            headers.insert(\"If-Modified-Since\", hv);\n        }\n        if let Some(date) = self.unmodified_since_date {\n            let hvs = format!(\"{}\", date.format(\"%c\"));\n            let hv = HeaderValue::from_str(&hvs)?;\n            headers.insert(\"If-Unmodified-Since\", hv);\n        }\n        // TODO FIXME complete\n        Ok(())\n    }\n\n    pub fn modified_since_revisions(&self) -> &[u64] {\n        &self.modified_since_revisions\n    }\n\n    pub fn set_modified_since_revisions(&mut self, modified_since_revisions: Vec<u64>) {\n        self.modified_since_revisions = modified_since_revisions;\n    }\n\n    pub const fn modified_since_date(&self) -> Option<NaiveDateTime> {\n        self.modified_since_date\n    }\n\n    pub const fn set_modified_since_date(&mut self, modified_since_date: Option<NaiveDateTime>) {\n        self.modified_since_date = modified_since_date;\n    }\n\n    pub fn unmodified_since_revisions(&self) -> &[u64] {\n        &self.unmodified_since_revisions\n    }\n\n    pub fn set_unmodified_since_revisions(&mut self, unmodified_since_revisions: Vec<u64>) {\n        self.unmodified_since_revisions = unmodified_since_revisions;\n    }\n\n    pub const fn unmodified_since_date(&self) -> Option<NaiveDateTime> {\n        self.unmodified_since_date\n    }\n\n    pub const fn set_unmodified_since_date(\n        &mut self,\n        unmodified_since_date: Option<NaiveDateTime>,\n    ) {\n        self.unmodified_since_date = unmodified_since_date;\n    }\n\n    pub fn if_match(&self) -> &[String] {\n        &self.if_match\n    }\n\n    pub fn set_if_match(&mut self, if_match: Vec<String>) {\n        self.if_match = if_match;\n    }\n\n    pub fn if_none_match(&self) -> &[String] {\n        &self.if_none_match\n    }\n\n    pub fn set_if_none_match(&mut self, if_none_match: Vec<String>) {\n        self.if_none_match = if_none_match;\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_revision_match() {\n        // #lizard forgives the complexity\n        let mut revision_match = RevisionMatch::default();\n        assert!(revision_match.modified_since_revisions().is_empty());\n        assert_eq!(revision_match.modified_since_date(), None);\n        assert!(revision_match.unmodified_since_revisions().is_empty());\n        assert_eq!(revision_match.unmodified_since_date(), None);\n        assert!(revision_match.if_match().is_empty());\n        assert!(revision_match.if_none_match().is_empty());\n\n        revision_match.set_modified_since_revisions(vec![1, 2, 3]);\n        assert_eq!(revision_match.modified_since_revisions(), &[1, 2, 3]);\n\n        revision_match.set_modified_since_date(Some(\n            NaiveDate::from_ymd_opt(2021, 1, 1)\n                .unwrap()\n                .and_hms_opt(0, 0, 0)\n                .unwrap(),\n        ));\n        assert_eq!(\n            revision_match.modified_since_date(),\n            Some(\n                NaiveDate::from_ymd_opt(2021, 1, 1)\n                    .unwrap()\n                    .and_hms_opt(0, 0, 0)\n                    .unwrap()\n            )\n        );\n\n        revision_match.set_unmodified_since_revisions(vec![4, 5, 6]);\n        assert_eq!(revision_match.unmodified_since_revisions(), &[4, 5, 6]);\n\n        revision_match.set_unmodified_since_date(Some(\n            NaiveDate::from_ymd_opt(2021, 1, 2)\n                .unwrap()\n                .and_hms_opt(0, 0, 0)\n                .unwrap(),\n        ));\n        assert_eq!(\n            revision_match.unmodified_since_date(),\n            Some(\n                NaiveDate::from_ymd_opt(2021, 1, 2)\n                    .unwrap()\n                    .and_hms_opt(0, 0, 0)\n                    .unwrap()\n            )\n        );\n\n        revision_match.set_if_match(vec![\"1\".to_string(), \"2\".to_string()]);\n        assert_eq!(\n            revision_match.if_match(),\n            &[\"1\".to_string(), \"2\".to_string()]\n        );\n\n        revision_match.set_if_none_match(vec![\"3\".to_string(), \"4\".to_string()]);\n        assert_eq!(\n            revision_match.if_none_match(),\n            &[\"3\".to_string(), \"4\".to_string()]\n        );\n    }\n}\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":43}},{"line":17,"address":[],"length":0,"stats":{"Line":43}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":43}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":43}},{"line":31,"address":[],"length":0,"stats":{"Line":2}},{"line":32,"address":[],"length":0,"stats":{"Line":2}},{"line":35,"address":[],"length":0,"stats":{"Line":2}},{"line":36,"address":[],"length":0,"stats":{"Line":2}},{"line":39,"address":[],"length":0,"stats":{"Line":2}},{"line":40,"address":[],"length":0,"stats":{"Line":2}},{"line":43,"address":[],"length":0,"stats":{"Line":1}},{"line":44,"address":[],"length":0,"stats":{"Line":1}},{"line":47,"address":[],"length":0,"stats":{"Line":2}},{"line":48,"address":[],"length":0,"stats":{"Line":2}},{"line":51,"address":[],"length":0,"stats":{"Line":1}},{"line":52,"address":[],"length":0,"stats":{"Line":1}},{"line":55,"address":[],"length":0,"stats":{"Line":2}},{"line":56,"address":[],"length":0,"stats":{"Line":2}},{"line":59,"address":[],"length":0,"stats":{"Line":1}},{"line":63,"address":[],"length":0,"stats":{"Line":1}},{"line":66,"address":[],"length":0,"stats":{"Line":2}},{"line":67,"address":[],"length":0,"stats":{"Line":2}},{"line":70,"address":[],"length":0,"stats":{"Line":1}},{"line":71,"address":[],"length":0,"stats":{"Line":1}},{"line":74,"address":[],"length":0,"stats":{"Line":2}},{"line":75,"address":[],"length":0,"stats":{"Line":2}},{"line":78,"address":[],"length":0,"stats":{"Line":1}},{"line":79,"address":[],"length":0,"stats":{"Line":1}}],"covered":28,"coverable":30},{"path":["/","Users","magnusmanske","rust","wikibase_rest_api","src","search.rs"],"content":"use crate::{entity::EntityType, Language, RestApi, RestApiError};\nuse nutype::nutype;\nuse serde::{Deserialize, Serialize};\nuse serde_json::Value;\nuse std::collections::HashMap;\n\n#[nutype(\n    validate(greater_or_equal = 1, less_or_equal = 500),\n    derive(Debug, Display, Clone, PartialEq)\n)]\npub struct SearchLimit(u16);\n\n#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]\npub struct SearchResultText {\n    language: String,\n    value: String,\n}\n\nimpl SearchResultText {\n    pub fn language(&self) -> &str {\n        &self.language\n    }\n\n    pub fn value(&self) -> &str {\n        &self.value\n    }\n}\n\n#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]\npub struct SearchResultMatch {\n    #[serde(rename = \"type\")]\n    match_type: String,\n    language: String,\n    text: String,\n}\n\nimpl SearchResultMatch {\n    pub fn language(&self) -> &str {\n        &self.language\n    }\n\n    pub fn text(&self) -> &str {\n        &self.text\n    }\n\n    pub fn match_type(&self) -> &str {\n        &self.match_type\n    }\n}\n\n#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]\npub struct SearchResult {\n    id: String,\n    #[serde(rename = \"display-label\")]\n    display_label: Option<SearchResultText>,\n    description: Option<SearchResultText>,\n    #[serde(rename = \"match\")]\n    search_match: SearchResultMatch,\n}\n\nimpl SearchResult {\n    pub fn id(&self) -> &str {\n        &self.id\n    }\n\n    pub fn display_label(&self) -> Option<&SearchResultText> {\n        self.display_label.as_ref()\n    }\n\n    pub fn description(&self) -> Option<&SearchResultText> {\n        self.description.as_ref()\n    }\n\n    pub fn search_match(&self) -> &SearchResultMatch {\n        &self.search_match\n    }\n}\n\n#[derive(Debug)]\npub struct Search {\n    entity_type: EntityType,\n    q: String,\n    language: Language,\n    limit: Option<SearchLimit>,\n    offset: Option<usize>,\n}\n\nimpl Search {\n    pub fn items<S: Into<String>>(q: S, language: Language) -> Self {\n        Self {\n            entity_type: EntityType::Item,\n            q: q.into(),\n            language,\n            limit: None,\n            offset: None,\n        }\n    }\n\n    pub fn properties<S: Into<String>>(q: S, language: Language) -> Self {\n        Self {\n            entity_type: EntityType::Property,\n            q: q.into(),\n            language,\n            limit: None,\n            offset: None,\n        }\n    }\n\n    pub fn with_limit(mut self, limit: SearchLimit) -> Self {\n        self.limit = Some(limit);\n        self\n    }\n\n    pub fn with_offset(mut self, offset: usize) -> Self {\n        self.offset = Some(offset);\n        self\n    }\n\n    async fn generate_json_request(&self, api: &RestApi) -> Result<reqwest::Request, RestApiError> {\n        let path = self.get_my_rest_api_path();\n        let mut params = HashMap::new();\n        params.insert(\"q\".to_string(), self.q.to_string());\n        params.insert(\"language\".to_string(), self.language.to_string());\n        if let Some(limit) = &self.limit {\n            params.insert(\"limit\".to_string(), format!(\"{limit}\"));\n        }\n        if let Some(offset) = &self.offset {\n            params.insert(\"offset\".to_string(), offset.to_string());\n        }\n        let mut request = api\n            .wikibase_request_builder(&path, params, reqwest::Method::GET)\n            .await?\n            .build()?;\n        request\n            .headers_mut()\n            .insert(reqwest::header::CONTENT_TYPE, \"application/json\".parse()?);\n        Ok(request)\n    }\n\n    pub async fn get(&self, api: &RestApi) -> Result<Vec<SearchResult>, RestApiError> {\n        let request = self.generate_json_request(api).await?;\n        let response = api.execute(request).await?;\n        let response = self.filter_response_error(response).await?;\n        Self::response_to_results(response)\n    }\n\n    fn response_to_results(response: Value) -> Result<Vec<SearchResult>, RestApiError> {\n        let results = response[\"results\"]\n            .as_array()\n            .ok_or(RestApiError::MissingResults)?\n            .iter()\n            .filter_map(|result| serde_json::from_value(result.clone()).ok())\n            .collect();\n        Ok(results)\n    }\n\n    fn get_my_rest_api_path(&self) -> String {\n        format!(\"/search/{group}\", group = self.entity_type.group_name())\n    }\n\n    async fn filter_response_error(\n        &self,\n        response: reqwest::Response,\n    ) -> Result<Value, RestApiError> {\n        if !response.status().is_success() {\n            return Err(RestApiError::from_response(response).await);\n        }\n        let j: Value = response.error_for_status()?.json().await?;\n        Ok(j)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_get_my_rest_api_path() {\n        assert_eq!(\n            Search::items(\"foo\", Language::try_new(\"en\").unwrap()).get_my_rest_api_path(),\n            \"/search/items\"\n        );\n        assert_eq!(\n            Search::properties(\"foo\", Language::try_new(\"en\").unwrap()).get_my_rest_api_path(),\n            \"/search/properties\"\n        );\n    }\n\n    #[test]\n    fn test_response_to_results() {\n        let v = std::fs::read_to_string(\"test_data/test_search_response.json\").unwrap();\n        let v: Value = serde_json::from_str(&v).unwrap();\n        let results = Search::response_to_results(v).unwrap();\n        assert_eq!(results.len(), 4);\n        assert_eq!(results[0].id(), \"Q123\");\n        assert_eq!(results[1].id(), \"Q234\");\n        assert_eq!(results[2].id(), \"Q345\");\n        assert_eq!(results[3].id(), \"Q456\");\n        assert_eq!(results[0].display_label().unwrap().value(), \"potato\");\n        assert_eq!(results[0].description().unwrap().value(), \"staple food\");\n        assert_eq!(results[1].display_label().unwrap().value(), \"potato\");\n        assert_eq!(\n            results[1].description().unwrap().value(),\n            \"species of plant\"\n        );\n        assert!(results[2].description().is_none());\n        assert!(results[3].display_label().is_none());\n        assert_eq!(results[0].search_match().match_type(), \"label\");\n        assert_eq!(results[1].search_match().match_type(), \"label\");\n        assert_eq!(results[2].search_match().match_type(), \"label\");\n        assert_eq!(results[3].search_match().match_type(), \"description\");\n    }\n\n    #[tokio::test]\n    async fn test_search() {\n        let query = \"Magnus Manske\";\n        let language = Language::try_new(\"en\").unwrap();\n        let api = RestApi::builder(\"https://www.wikidata.org/w/rest.php\")\n            .unwrap()\n            .with_api_version(0) // Search\n            .build();\n        let results = Search::items(query, language).get(&api).await.unwrap();\n        // Check for \"Magnus Manske\"\n        assert!(results\n            .iter()\n            .map(|result| result.id())\n            .any(|id| id == \"Q13520818\"));\n        // Check for \"Magnus Manske Day\"\n        assert!(results\n            .iter()\n            .map(|result| result.id())\n            .any(|id| id == \"Q10995651\"));\n    }\n}\n","traces":[{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":4}},{"line":25,"address":[],"length":0,"stats":{"Line":4}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":4}},{"line":47,"address":[],"length":0,"stats":{"Line":4}},{"line":62,"address":[],"length":0,"stats":{"Line":7}},{"line":63,"address":[],"length":0,"stats":{"Line":7}},{"line":66,"address":[],"length":0,"stats":{"Line":3}},{"line":67,"address":[],"length":0,"stats":{"Line":3}},{"line":70,"address":[],"length":0,"stats":{"Line":3}},{"line":71,"address":[],"length":0,"stats":{"Line":3}},{"line":74,"address":[],"length":0,"stats":{"Line":4}},{"line":75,"address":[],"length":0,"stats":{"Line":4}},{"line":89,"address":[],"length":0,"stats":{"Line":2}},{"line":92,"address":[],"length":0,"stats":{"Line":2}},{"line":99,"address":[],"length":0,"stats":{"Line":1}},{"line":102,"address":[],"length":0,"stats":{"Line":1}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":2}},{"line":120,"address":[],"length":0,"stats":{"Line":1}},{"line":121,"address":[],"length":0,"stats":{"Line":1}},{"line":122,"address":[],"length":0,"stats":{"Line":1}},{"line":123,"address":[],"length":0,"stats":{"Line":1}},{"line":124,"address":[],"length":0,"stats":{"Line":1}},{"line":127,"address":[],"length":0,"stats":{"Line":1}},{"line":130,"address":[],"length":0,"stats":{"Line":2}},{"line":131,"address":[],"length":0,"stats":{"Line":1}},{"line":132,"address":[],"length":0,"stats":{"Line":1}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":1}},{"line":140,"address":[],"length":0,"stats":{"Line":2}},{"line":141,"address":[],"length":0,"stats":{"Line":2}},{"line":142,"address":[],"length":0,"stats":{"Line":1}},{"line":143,"address":[],"length":0,"stats":{"Line":1}},{"line":147,"address":[],"length":0,"stats":{"Line":2}},{"line":148,"address":[],"length":0,"stats":{"Line":4}},{"line":150,"address":[],"length":0,"stats":{"Line":2}},{"line":152,"address":[],"length":0,"stats":{"Line":6}},{"line":157,"address":[],"length":0,"stats":{"Line":3}},{"line":158,"address":[],"length":0,"stats":{"Line":3}},{"line":161,"address":[],"length":0,"stats":{"Line":1}},{"line":165,"address":[],"length":0,"stats":{"Line":1}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":3}}],"covered":40,"coverable":54},{"path":["/","Users","magnusmanske","rust","wikibase_rest_api","src","sitelink.rs"],"content":"use async_trait::async_trait;\nuse derivative::Derivative;\nuse serde::ser::{Serialize, SerializeStruct};\nuse serde_json::{json, Value};\n\nuse crate::{\n    EditMetadata, EntityId, HeaderInfo, HttpDelete, HttpGet, HttpMisc, HttpPut, RestApi,\n    RestApiError, RevisionMatch,\n};\n\n#[derive(Derivative, Debug, Clone)]\n#[derivative(PartialEq)]\npub struct Sitelink {\n    wiki: String,\n    title: String,\n    badges: Vec<String>,\n    url: Option<String>,\n    #[derivative(PartialEq = \"ignore\")]\n    header_info: HeaderInfo,\n}\n\nimpl Sitelink {\n    /// Create a new sitelink with the given wiki and title\n    pub fn new<S1: Into<String>, S2: Into<String>>(wiki: S1, title: S2) -> Sitelink {\n        Self::new_complete(wiki.into(), title.into(), Vec::new(), None)\n    }\n\n    /// Create a new sitelink with the given wiki, title, badges, and URL\n    pub fn new_complete(\n        wiki: String,\n        title: String,\n        badges: Vec<String>,\n        url: Option<String>,\n    ) -> Sitelink {\n        Sitelink {\n            wiki,\n            title,\n            badges,\n            url,\n            header_info: HeaderInfo::default(),\n        }\n    }\n\n    /// Create a new sitelink from a JSON object\n    pub fn from_json<S: Into<String>>(wiki: S, j: &Value) -> Result<Self, RestApiError> {\n        Self::from_json_header_info(wiki, j, HeaderInfo::default())\n    }\n\n    fn string_from_json_header_info(j: &Value, key: &str) -> Result<String, RestApiError> {\n        j[key]\n            .as_str()\n            .ok_or(RestApiError::MissingOrInvalidField {\n                field: key.to_string(),\n                j: j.clone(),\n            })\n            .map(|s| s.to_string())\n    }\n\n    fn badges_from_json_header_info(j: &Value) -> Result<Vec<String>, RestApiError> {\n        Ok(j[\"badges\"]\n            .as_array()\n            .ok_or(RestApiError::MissingOrInvalidField {\n                field: \"badges\".to_string(),\n                j: j.clone(),\n            })?\n            .iter()\n            .filter_map(|b| b.as_str())\n            .map(|s| s.to_string())\n            .collect())\n    }\n\n    /// Create a new sitelink from a JSON object with header info\n    pub fn from_json_header_info<S: Into<String>>(\n        wiki: S,\n        j: &Value,\n        header_info: HeaderInfo,\n    ) -> Result<Self, RestApiError> {\n        let wiki = wiki.into().to_string();\n        let title = Self::string_from_json_header_info(j, \"title\")?;\n        let badges = Self::badges_from_json_header_info(j)?;\n        let url = Some(Self::string_from_json_header_info(j, \"url\")?);\n        let mut ret = Sitelink::new_complete(wiki, title, badges, url);\n        ret.header_info = header_info;\n        Ok(ret)\n    }\n\n    /// Returns the wiki of the sitelink\n    pub fn wiki(&self) -> &str {\n        &self.wiki\n    }\n\n    /// Returns the title of the sitelink\n    pub fn title(&self) -> &str {\n        &self.title\n    }\n\n    /// Returns the badges of the sitelink\n    pub const fn badges(&self) -> &Vec<String> {\n        &self.badges\n    }\n\n    /// Returns the URL of the sitelink\n    pub fn url(&self) -> Option<&str> {\n        self.url.as_deref()\n    }\n\n    fn get_rest_api_path_from_wiki(id: &EntityId, wiki: &str) -> Result<String, RestApiError> {\n        Ok(format!(\n            \"/entities/{group}/{id}/sitelinks/{wiki}\",\n            group = id.group()?\n        ))\n    }\n}\n\nimpl Serialize for Sitelink {\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: serde::Serializer,\n    {\n        // #lizard forgives the complexity\n        let mut fields = 2;\n        if self.url.is_some() {\n            fields += 1;\n        }\n        let mut s = serializer.serialize_struct(\"Sitelink\", fields)?;\n        s.serialize_field(\"title\", &self.title)?;\n        s.serialize_field(\"badges\", &self.badges)?;\n        if let Some(url) = &self.url {\n            s.serialize_field(\"url\", url)?;\n        }\n        s.end()\n    }\n}\n\nimpl HttpMisc for Sitelink {\n    fn get_my_rest_api_path(&self, id: &EntityId) -> Result<String, RestApiError> {\n        Self::get_rest_api_path_from_wiki(id, self.wiki())\n    }\n}\n\n#[async_trait]\nimpl HttpGet for Sitelink {\n    async fn get_match(\n        id: &EntityId,\n        site_id: &str,\n        api: &RestApi,\n        rm: RevisionMatch,\n    ) -> Result<Self, RestApiError> {\n        let path = Self::get_rest_api_path_from_wiki(id, site_id)?;\n        let (j, header_info) = Self::get_match_internal(api, &path, rm).await?;\n        Self::from_json_header_info(site_id, &j, header_info)\n    }\n}\n\n#[async_trait]\nimpl HttpDelete for Sitelink {\n    async fn delete_meta(\n        &self,\n        id: &EntityId,\n        api: &mut RestApi,\n        em: EditMetadata,\n    ) -> Result<(), RestApiError> {\n        let j = json!({});\n        let (j, _revision_id) = self\n            .run_json_query(id, reqwest::Method::DELETE, j, api, &em)\n            .await?;\n        match j.as_str() {\n            Some(\"Sitelink deleted\") => Ok(()),\n            _ => Err(RestApiError::UnexpectedResponse(j.to_owned())),\n        }\n    }\n}\n\n#[async_trait]\nimpl HttpPut for Sitelink {\n    async fn put_meta(\n        &self,\n        id: &EntityId,\n        api: &mut RestApi,\n        em: EditMetadata,\n    ) -> Result<Sitelink, RestApiError> {\n        let j = json!({\n            \"sitelink\": {\n                \"title\": self.title(),\n                \"badges\": self.badges()\n            }\n        });\n        let (j, header_info) = self\n            .run_json_query(id, reqwest::Method::PUT, j, api, &em)\n            .await?;\n        let ret = Self::from_json_header_info(&self.wiki, &j, header_info)?;\n        Ok(ret)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use wiremock::matchers::{bearer_token, body_partial_json, method, path};\n    use wiremock::{Mock, MockServer, ResponseTemplate};\n\n    #[test]\n    fn test_sitelink() {\n        let wiki = \"enwiki\".to_string();\n        let title = \"Foo\".to_string();\n        let badges = vec![\"Q17437796\".to_string()];\n        let url = \"https://en.wikipedia.org/wiki/Foo\".to_string();\n        let sitelink = Sitelink::new_complete(\n            wiki.clone(),\n            title.clone(),\n            badges.clone(),\n            Some(url.to_string()),\n        );\n        assert_eq!(sitelink.wiki(), wiki);\n        assert_eq!(sitelink.title(), title);\n        assert_eq!(sitelink.badges(), &badges);\n        assert_eq!(sitelink.url().unwrap(), url);\n    }\n\n    #[tokio::test]\n    #[cfg_attr(miri, ignore)]\n    async fn test_sitelink_get() {\n        let v = std::fs::read_to_string(\"test_data/Q42.json\").unwrap();\n        let v: Value = serde_json::from_str(&v).unwrap();\n        let id = v[\"id\"].as_str().unwrap();\n\n        let mock_path = format!(\"/w/rest.php/wikibase/v1/entities/items/{id}/sitelinks/enwiki\");\n        let mock_server = MockServer::start().await;\n        Mock::given(method(\"GET\"))\n            .and(path(&mock_path))\n            .respond_with(ResponseTemplate::new(200).set_body_json(&v[\"sitelinks\"][\"enwiki\"]))\n            .mount(&mock_server)\n            .await;\n        let api = RestApi::builder(&(mock_server.uri() + \"/w/rest.php\"))\n            .unwrap()\n            .build();\n\n        let sitelink = Sitelink::get(&EntityId::item(id), \"enwiki\", &api)\n            .await\n            .unwrap();\n        assert_eq!(sitelink.wiki(), \"enwiki\");\n        assert_eq!(sitelink.title(), \"Douglas Adams\");\n        assert_eq!(\n            sitelink.url(),\n            Some(\"https://en.wikipedia.org/wiki/Douglas_Adams\")\n        );\n    }\n\n    #[tokio::test]\n    #[cfg_attr(miri, ignore)]\n    async fn test_sitelink_put() {\n        let page_title = \"Foo Bar\";\n        let v = std::fs::read_to_string(\"test_data/Q42.json\").unwrap();\n        let v: Value = serde_json::from_str(&v).unwrap();\n        let id = v[\"id\"].as_str().unwrap();\n\n        let mock_path = format!(\"/w/rest.php/wikibase/v1/entities/items/{id}/sitelinks/enwiki\");\n        let mock_server = MockServer::start().await;\n        let token = \"FAKE_TOKEN\";\n        Mock::given(body_partial_json(\n            json!({\"sitelink\":{\"badges\":[],\"title\":page_title}}),\n        ))\n        .and(method(\"PUT\"))\n        .and(path(&mock_path))\n        .and(bearer_token(token))\n        .respond_with(\n            ResponseTemplate::new(200)\n                .set_body_json(json!({\"badges\":[],\"title\":page_title,\"url\":\"dummy\"})),\n        )\n        .mount(&mock_server)\n        .await;\n        let mut api = RestApi::builder(&(mock_server.uri() + \"/w/rest.php\"))\n            .unwrap()\n            .with_access_token(token)\n            .build();\n\n        let id = EntityId::item(id);\n        let sitelink = Sitelink::new(\"enwiki\", page_title);\n        let new_sitelink = sitelink.put(&id, &mut api).await.unwrap();\n        assert_eq!(new_sitelink.wiki(), sitelink.wiki());\n        assert_eq!(new_sitelink.title(), sitelink.title());\n    }\n\n    #[tokio::test]\n    #[cfg_attr(miri, ignore)]\n    async fn test_sitelink_delete() {\n        let v = std::fs::read_to_string(\"test_data/Q42.json\").unwrap();\n        let v: Value = serde_json::from_str(&v).unwrap();\n        let id = v[\"id\"].as_str().unwrap();\n\n        let mock_path = format!(\"/w/rest.php/wikibase/v1/entities/items/{id}/sitelinks/enwiki\");\n        let mock_server = MockServer::start().await;\n        let token = \"FAKE_TOKEN\";\n        Mock::given(method(\"DELETE\"))\n            .and(path(&mock_path))\n            .and(bearer_token(token))\n            .respond_with(ResponseTemplate::new(200).set_body_json(json!(\"Sitelink deleted\")))\n            .mount(&mock_server)\n            .await;\n        let mut api = RestApi::builder(&(mock_server.uri() + \"/w/rest.php\"))\n            .unwrap()\n            .with_access_token(token)\n            .build();\n\n        let id = EntityId::item(id);\n        let new_sitelink = Sitelink::new(\"enwiki\", \"doesn't matter\");\n        new_sitelink.delete(&id, &mut api).await.unwrap();\n    }\n}\n","traces":[{"line":24,"address":[],"length":0,"stats":{"Line":13}},{"line":25,"address":[],"length":0,"stats":{"Line":13}},{"line":29,"address":[],"length":0,"stats":{"Line":1636}},{"line":40,"address":[],"length":0,"stats":{"Line":1636}},{"line":45,"address":[],"length":0,"stats":{"Line":1612}},{"line":46,"address":[],"length":0,"stats":{"Line":1612}},{"line":49,"address":[],"length":0,"stats":{"Line":3228}},{"line":50,"address":[],"length":0,"stats":{"Line":3228}},{"line":52,"address":[],"length":0,"stats":{"Line":3228}},{"line":53,"address":[],"length":0,"stats":{"Line":3228}},{"line":54,"address":[],"length":0,"stats":{"Line":3228}},{"line":56,"address":[],"length":0,"stats":{"Line":9684}},{"line":59,"address":[],"length":0,"stats":{"Line":1614}},{"line":60,"address":[],"length":0,"stats":{"Line":1614}},{"line":61,"address":[],"length":0,"stats":{"Line":1614}},{"line":62,"address":[],"length":0,"stats":{"Line":1614}},{"line":63,"address":[],"length":0,"stats":{"Line":1614}},{"line":64,"address":[],"length":0,"stats":{"Line":1614}},{"line":66,"address":[],"length":0,"stats":{"Line":1614}},{"line":67,"address":[],"length":0,"stats":{"Line":1642}},{"line":68,"address":[],"length":0,"stats":{"Line":28}},{"line":73,"address":[],"length":0,"stats":{"Line":1614}},{"line":78,"address":[],"length":0,"stats":{"Line":1614}},{"line":79,"address":[],"length":0,"stats":{"Line":3228}},{"line":80,"address":[],"length":0,"stats":{"Line":1614}},{"line":81,"address":[],"length":0,"stats":{"Line":1614}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":483}},{"line":89,"address":[],"length":0,"stats":{"Line":483}},{"line":93,"address":[],"length":0,"stats":{"Line":14}},{"line":94,"address":[],"length":0,"stats":{"Line":14}},{"line":98,"address":[],"length":0,"stats":{"Line":2}},{"line":99,"address":[],"length":0,"stats":{"Line":2}},{"line":103,"address":[],"length":0,"stats":{"Line":2}},{"line":104,"address":[],"length":0,"stats":{"Line":2}},{"line":107,"address":[],"length":0,"stats":{"Line":3}},{"line":108,"address":[],"length":0,"stats":{"Line":3}},{"line":109,"address":[],"length":0,"stats":{"Line":3}},{"line":110,"address":[],"length":0,"stats":{"Line":3}},{"line":116,"address":[],"length":0,"stats":{"Line":374}},{"line":121,"address":[],"length":0,"stats":{"Line":374}},{"line":122,"address":[],"length":0,"stats":{"Line":744}},{"line":123,"address":[],"length":0,"stats":{"Line":370}},{"line":125,"address":[],"length":0,"stats":{"Line":748}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":374}},{"line":128,"address":[],"length":0,"stats":{"Line":744}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":374}},{"line":136,"address":[],"length":0,"stats":{"Line":2}},{"line":137,"address":[],"length":0,"stats":{"Line":2}},{"line":149,"address":[],"length":0,"stats":{"Line":2}},{"line":150,"address":[],"length":0,"stats":{"Line":1}},{"line":163,"address":[],"length":0,"stats":{"Line":1}},{"line":164,"address":[],"length":0,"stats":{"Line":2}},{"line":165,"address":[],"length":0,"stats":{"Line":1}},{"line":166,"address":[],"length":0,"stats":{"Line":1}},{"line":168,"address":[],"length":0,"stats":{"Line":2}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":1}},{"line":183,"address":[],"length":0,"stats":{"Line":1}},{"line":184,"address":[],"length":0,"stats":{"Line":1}},{"line":185,"address":[],"length":0,"stats":{"Line":1}},{"line":188,"address":[],"length":0,"stats":{"Line":2}},{"line":189,"address":[],"length":0,"stats":{"Line":1}},{"line":190,"address":[],"length":0,"stats":{"Line":1}},{"line":191,"address":[],"length":0,"stats":{"Line":1}}],"covered":63,"coverable":69},{"path":["/","Users","magnusmanske","rust","wikibase_rest_api","src","sitelinks.rs"],"content":"use crate::{\n    sitelinks_patch::SitelinksPatch, EntityId, FromJson, HeaderInfo, HttpGetEntity, HttpMisc,\n    RestApi, RestApiError, RevisionMatch, Sitelink,\n};\nuse async_trait::async_trait;\nuse derivative::Derivative;\nuse serde::ser::{Serialize, SerializeMap};\nuse serde_json::{json, Value};\n\n#[derive(Derivative, Debug, Clone, Default)]\n#[derivative(PartialEq)]\npub struct Sitelinks {\n    sitelinks: Vec<Sitelink>,\n    #[derivative(PartialEq = \"ignore\")]\n    header_info: HeaderInfo,\n}\n\nimpl HttpMisc for Sitelinks {\n    fn get_rest_api_path(id: &EntityId) -> Result<String, RestApiError> {\n        Ok(format!(\n            \"/entities/{group}/{id}/sitelinks\",\n            group = id.group()?\n        ))\n    }\n}\n\nimpl FromJson for Sitelinks {\n    fn header_info(&self) -> &HeaderInfo {\n        &self.header_info\n    }\n\n    fn from_json_header_info(json: &Value, header_info: HeaderInfo) -> Result<Self, RestApiError> {\n        let sitelinks = json\n            .as_object()\n            .ok_or(RestApiError::MissingOrInvalidField {\n                field: \"Sitelinks\".to_string(),\n                j: json.clone(),\n            })?\n            .iter()\n            .map(|(wiki, j)| Sitelink::from_json(wiki, j))\n            .collect::<Result<Vec<Sitelink>, RestApiError>>()?;\n        Ok(Sitelinks {\n            sitelinks,\n            header_info,\n        })\n    }\n}\n\n#[async_trait]\nimpl HttpGetEntity for Sitelinks {\n    async fn get_match(\n        id: &EntityId,\n        api: &RestApi,\n        rm: RevisionMatch,\n    ) -> Result<Self, RestApiError> {\n        let path = Self::get_rest_api_path(id)?;\n        let (j, header_info) = Self::get_match_internal(api, &path, rm).await?;\n        Self::from_json_header_info(&j, header_info)\n    }\n}\n\nimpl Sitelinks {\n    /// Returns the sitelinks\n    pub const fn sitelinks(&self) -> &Vec<Sitelink> {\n        &self.sitelinks\n    }\n\n    /// Returns the sitelink for a given wiki\n    pub fn get_wiki<S: Into<String>>(&self, wiki: S) -> Option<&Sitelink> {\n        let wiki = wiki.into();\n        self.sitelinks.iter().find(|s| s.wiki() == wiki)\n    }\n\n    /// Sets the sitelink for a given wiki\n    pub fn set_wiki(&mut self, sitelink: Sitelink) {\n        self.sitelinks.retain(|s| s.wiki() != sitelink.wiki());\n        self.sitelinks.push(sitelink);\n    }\n\n    /// Deletes the sitelink for a given wiki\n    pub fn remove_wiki<S: Into<String>>(&mut self, wiki: S) {\n        let wiki = wiki.into();\n        self.sitelinks.retain(|s| s.wiki() != wiki);\n    }\n\n    /// Returns the number of sitelinks\n    pub fn len(&self) -> usize {\n        self.sitelinks.len()\n    }\n\n    /// Returns true if there are no sitelinks\n    pub fn is_empty(&self) -> bool {\n        self.sitelinks.is_empty()\n    }\n\n    /// Generates a patch to transform `other` into `self`\n    pub fn patch(&self, other: &Self) -> Result<SitelinksPatch, RestApiError> {\n        let patch = json_patch::diff(&json!(&other), &json!(&self));\n        let patch = SitelinksPatch::from_json(&json!(patch))?;\n        Ok(patch)\n    }\n}\n\nimpl Serialize for Sitelinks {\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: serde::Serializer,\n    {\n        let mut s = serializer.serialize_map(Some(self.sitelinks.len()))?;\n        for sl in &self.sitelinks {\n            s.serialize_entry(sl.wiki(), sl)?;\n        }\n        s.end()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use serde_json::json;\n    use wiremock::matchers::{method, path};\n    use wiremock::{Mock, MockServer, ResponseTemplate};\n\n    #[tokio::test]\n    #[cfg_attr(miri, ignore)]\n    async fn test_sitelinks_get() {\n        let v = std::fs::read_to_string(\"test_data/Q42.json\").unwrap();\n        let v: Value = serde_json::from_str(&v).unwrap();\n        let id = v[\"id\"].as_str().unwrap();\n\n        let mock_path = format!(\"/w/rest.php/wikibase/v1/entities/items/{id}/sitelinks\");\n        let mock_server = MockServer::start().await;\n        Mock::given(method(\"GET\"))\n            .and(path(&mock_path))\n            .respond_with(ResponseTemplate::new(200).set_body_json(&v[\"sitelinks\"]))\n            .mount(&mock_server)\n            .await;\n        let api = RestApi::builder(&(mock_server.uri() + \"/w/rest.php\"))\n            .unwrap()\n            .build();\n\n        let sitelinks = Sitelinks::get(&EntityId::item(\"Q42\"), &api).await.unwrap();\n        assert_eq!(sitelinks.sitelinks.len(), 122);\n        assert_eq!(\n            sitelinks.get_wiki(\"enwiki\").unwrap().title(),\n            \"Douglas Adams\"\n        );\n    }\n\n    #[test]\n    fn test_sitelinks_json() {\n        let sitelinks = Sitelinks {\n            sitelinks: vec![\n                Sitelink::new_complete(\n                    \"enwiki\".to_string(),\n                    \"Douglas Adams\".to_string(),\n                    vec![],\n                    Some(\"https://en.wikipedia.org/wiki/Douglas_Adams\".to_string()),\n                ),\n                Sitelink::new_complete(\n                    \"dewiki\".to_string(),\n                    \"Douglas Adams\".to_string(),\n                    vec![],\n                    Some(\"https://de.wikipedia.org/wiki/Douglas_Adams\".to_string()),\n                ),\n            ],\n            header_info: HeaderInfo::default(),\n        };\n        let j = json!(sitelinks);\n        assert_eq!(j[\"enwiki\"][\"title\"].as_str().unwrap(), \"Douglas Adams\");\n        assert_eq!(j[\"dewiki\"][\"title\"].as_str().unwrap(), \"Douglas Adams\");\n    }\n\n    #[test]\n    fn test_sitelinks_set_wiki() {\n        let mut sitelinks = Sitelinks::default();\n        sitelinks.set_wiki(Sitelink::new_complete(\n            \"enwiki\".to_string(),\n            \"Douglas Adams\".to_string(),\n            vec![],\n            Some(\"https://en.wikipedia.org/wiki/Douglas_Adams\".to_string()),\n        ));\n        assert_eq!(\n            sitelinks.get_wiki(\"enwiki\").unwrap().title(),\n            \"Douglas Adams\"\n        );\n        sitelinks.set_wiki(Sitelink::new_complete(\n            \"enwiki\".to_string(),\n            \"Douglas NoÃ«l Adams\".to_string(),\n            vec![],\n            Some(\"https://en.wikipedia.org/wiki/Douglas_Adams\".to_string()),\n        ));\n        assert_eq!(\n            sitelinks.get_wiki(\"enwiki\").unwrap().title(),\n            \"Douglas NoÃ«l Adams\"\n        );\n    }\n\n    #[test]\n    fn test_sitelinks_get_wiki() {\n        let sitelinks = Sitelinks {\n            sitelinks: vec![\n                Sitelink::new_complete(\n                    \"enwiki\".to_string(),\n                    \"Douglas Adams\".to_string(),\n                    vec![],\n                    Some(\"https://en.wikipedia.org/wiki/Douglas_Adams\".to_string()),\n                ),\n                Sitelink::new_complete(\n                    \"dewiki\".to_string(),\n                    \"Douglas Adams\".to_string(),\n                    vec![],\n                    Some(\"https://de.wikipedia.org/wiki/Douglas_Adams\".to_string()),\n                ),\n            ],\n            header_info: HeaderInfo::default(),\n        };\n        assert_eq!(\n            sitelinks.get_wiki(\"enwiki\").unwrap().title(),\n            \"Douglas Adams\"\n        );\n        assert_eq!(\n            sitelinks.get_wiki(\"dewiki\").unwrap().title(),\n            \"Douglas Adams\"\n        );\n        assert!(sitelinks.get_wiki(\"frwiki\").is_none());\n    }\n\n    #[test]\n    fn test_patch() {\n        let mut s1 = Sitelinks::default();\n        s1.set_wiki(Sitelink::new(\"enwiki\", \"Foo\"));\n        s1.set_wiki(Sitelink::new(\"frwiki\", \"Le Foo\"));\n        let mut s2 = Sitelinks::default();\n        s2.set_wiki(Sitelink::new(\"dewiki\", \"Bar\"));\n        s2.set_wiki(Sitelink::new(\"enwiki\", \"Baz\"));\n\n        let patch = s2.patch(&s1).unwrap();\n        let patch_json = json!(patch);\n        assert_eq!(\n            patch_json,\n            json!({\"patch\":[\n                {\"op\":\"add\",\"path\":\"/dewiki\",\"value\":{\"badges\":[],\"title\":\"Bar\"}},\n                {\"op\":\"replace\",\"path\":\"/enwiki/title\",\"value\":\"Baz\"},\n                {\"op\":\"remove\",\"path\":\"/frwiki\"}\n            ]})\n        );\n    }\n\n    #[test]\n    fn test_len() {\n        let mut sitelinks = Sitelinks::default();\n        assert_eq!(sitelinks.len(), 0);\n        sitelinks.set_wiki(Sitelink::new(\"enwiki\", \"Foo\"));\n        assert_eq!(sitelinks.len(), 1);\n    }\n\n    #[test]\n    fn test_is_empty() {\n        let mut sitelinks = Sitelinks::default();\n        assert!(sitelinks.is_empty());\n        sitelinks.set_wiki(Sitelink::new(\"enwiki\", \"Foo\"));\n        assert!(!sitelinks.is_empty());\n    }\n\n    #[test]\n    fn test_get_rest_api_path() {\n        let sitelinks = Sitelinks::default();\n        assert_eq!(\n            sitelinks\n                .get_my_rest_api_path(&EntityId::item(\"Q42\"))\n                .unwrap(),\n            \"/entities/items/Q42/sitelinks\"\n        );\n    }\n\n    #[test]\n    fn test_header_info() {\n        let sitelinks = Sitelinks::default();\n        assert_eq!(sitelinks.header_info(), &HeaderInfo::default());\n    }\n\n    #[test]\n    fn test_serialize() {\n        let sitelinks = Sitelinks {\n            sitelinks: vec![\n                Sitelink::new_complete(\n                    \"enwiki\".to_string(),\n                    \"Douglas Adams\".to_string(),\n                    vec![],\n                    Some(\"https://en.wikipedia.org/wiki/Douglas_Adams\".to_string()),\n                ),\n                Sitelink::new_complete(\n                    \"dewiki\".to_string(),\n                    \"Douglas Adams\".to_string(),\n                    vec![],\n                    Some(\"https://de.wikipedia.org/wiki/Douglas_Adams\".to_string()),\n                ),\n            ],\n            header_info: HeaderInfo::default(),\n        };\n        let j = serde_json::to_value(&sitelinks).unwrap();\n        assert_eq!(j[\"enwiki\"][\"title\"].as_str().unwrap(), \"Douglas Adams\");\n        assert_eq!(j[\"dewiki\"][\"title\"].as_str().unwrap(), \"Douglas Adams\");\n    }\n\n    #[test]\n    fn test_sitelinks() {\n        let mut s = Sitelinks::default();\n        s.set_wiki(Sitelink::new(\"enwiki\", \"foo\"));\n        s.set_wiki(Sitelink::new(\"dewiki\", \"bar\"));\n        let mut pages = s\n            .sitelinks()\n            .iter()\n            .map(|s| s.title().to_string())\n            .collect::<Vec<String>>();\n        pages.sort();\n        assert_eq!(pages, vec![\"bar\", \"foo\"]);\n    }\n\n    #[test]\n    fn test_remove_wiki() {\n        let mut s = Sitelinks::default();\n        s.set_wiki(Sitelink::new(\"enwiki\", \"foo\"));\n        s.set_wiki(Sitelink::new(\"dewiki\", \"bar\"));\n        s.remove_wiki(\"enwiki\");\n        let pages = s\n            .sitelinks()\n            .iter()\n            .map(|s| s.title().to_string())\n            .collect::<Vec<String>>();\n        assert_eq!(pages, vec![\"bar\"]);\n    }\n}\n","traces":[{"line":19,"address":[],"length":0,"stats":{"Line":2}},{"line":20,"address":[],"length":0,"stats":{"Line":2}},{"line":21,"address":[],"length":0,"stats":{"Line":2}},{"line":22,"address":[],"length":0,"stats":{"Line":2}},{"line":28,"address":[],"length":0,"stats":{"Line":1}},{"line":29,"address":[],"length":0,"stats":{"Line":1}},{"line":32,"address":[],"length":0,"stats":{"Line":11}},{"line":33,"address":[],"length":0,"stats":{"Line":22}},{"line":35,"address":[],"length":0,"stats":{"Line":11}},{"line":36,"address":[],"length":0,"stats":{"Line":11}},{"line":37,"address":[],"length":0,"stats":{"Line":11}},{"line":40,"address":[],"length":0,"stats":{"Line":1623}},{"line":56,"address":[],"length":0,"stats":{"Line":2}},{"line":57,"address":[],"length":0,"stats":{"Line":1}},{"line":64,"address":[],"length":0,"stats":{"Line":2}},{"line":65,"address":[],"length":0,"stats":{"Line":2}},{"line":69,"address":[],"length":0,"stats":{"Line":8}},{"line":70,"address":[],"length":0,"stats":{"Line":8}},{"line":71,"address":[],"length":0,"stats":{"Line":107}},{"line":75,"address":[],"length":0,"stats":{"Line":13}},{"line":76,"address":[],"length":0,"stats":{"Line":31}},{"line":77,"address":[],"length":0,"stats":{"Line":13}},{"line":81,"address":[],"length":0,"stats":{"Line":1}},{"line":82,"address":[],"length":0,"stats":{"Line":1}},{"line":83,"address":[],"length":0,"stats":{"Line":4}},{"line":87,"address":[],"length":0,"stats":{"Line":4}},{"line":88,"address":[],"length":0,"stats":{"Line":4}},{"line":92,"address":[],"length":0,"stats":{"Line":10}},{"line":93,"address":[],"length":0,"stats":{"Line":10}},{"line":97,"address":[],"length":0,"stats":{"Line":2}},{"line":98,"address":[],"length":0,"stats":{"Line":2}},{"line":99,"address":[],"length":0,"stats":{"Line":4}},{"line":105,"address":[],"length":0,"stats":{"Line":9}},{"line":109,"address":[],"length":0,"stats":{"Line":18}},{"line":110,"address":[],"length":0,"stats":{"Line":757}},{"line":111,"address":[],"length":0,"stats":{"Line":374}},{"line":113,"address":[],"length":0,"stats":{"Line":9}}],"covered":37,"coverable":37},{"path":["/","Users","magnusmanske","rust","wikibase_rest_api","src","sitelinks_patch.rs"],"content":"use crate::{\n    patch_entry::PatchEntry, EntityId, HttpMisc, Patch, PatchApply, RestApiError, Sitelinks,\n};\nuse async_trait::async_trait;\nuse serde::Serialize;\nuse serde_json::Value;\n\n#[derive(Debug, Clone, Default, PartialEq, Serialize)]\npub struct SitelinksPatch {\n    patch: Vec<PatchEntry>,\n}\n\nimpl SitelinksPatch {\n    /// Adds a command to replace the title of a sitelink\n    pub fn replace_title<S1: Into<String>, S2: Into<String>>(&mut self, wiki: S1, value: S2) {\n        self.replace(format!(\"/{}/title\", wiki.into()), value.into().into());\n    }\n\n    /// Generates a patch from JSON, presumably from `json_patch`\n    pub fn from_json(j: &Value) -> Result<Self, RestApiError> {\n        let pe = j\n            .as_array()\n            .ok_or(RestApiError::WrongType {\n                field: \"SitelinksPatch\".into(),\n                j: j.to_owned(),\n            })?\n            .iter()\n            .map(|x| serde_json::from_value(x.clone()).map_err(|e| e.into()))\n            .collect::<Result<Vec<PatchEntry>, RestApiError>>()?;\n        Ok(Self { patch: pe })\n    }\n}\n\nimpl Patch for SitelinksPatch {\n    fn patch(&self) -> &Vec<PatchEntry> {\n        &self.patch\n    }\n\n    fn patch_mut(&mut self) -> &mut Vec<PatchEntry> {\n        &mut self.patch\n    }\n}\n\n#[async_trait]\nimpl PatchApply<Sitelinks> for SitelinksPatch {}\n\nimpl HttpMisc for SitelinksPatch {\n    fn get_my_rest_api_path(&self, id: &EntityId) -> Result<String, RestApiError> {\n        Ok(format!(\"/entities/{}/{id}/sitelinks\", id.group()?))\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::RestApi;\n    use serde_json::{json, Value};\n    use wiremock::matchers::{bearer_token, body_partial_json, header, method, path};\n    use wiremock::{Mock, MockServer, ResponseTemplate};\n\n    use super::*;\n\n    #[tokio::test]\n    #[cfg_attr(miri, ignore)]\n    async fn test_sitelinks_patch() {\n        let id = \"Q42\";\n        let page_title = \"Foo Bar\";\n        let v = std::fs::read_to_string(\"test_data/Q42.json\").unwrap();\n        let v: Value = serde_json::from_str(&v).unwrap();\n        let mut new_sitelinks = v[\"sitelinks\"].clone();\n        new_sitelinks[\"enwiki\"][\"title\"] = json!(page_title);\n\n        let mock_path = format!(\"/w/rest.php/wikibase/v1/entities/items/{id}/sitelinks\");\n        let mock_server = MockServer::start().await;\n        let token = \"FAKE_TOKEN\";\n        Mock::given(body_partial_json(\n            json!({\"patch\":[{\"op\": \"replace\",\"path\": \"/enwiki/title\",\"value\": page_title}]}),\n        ))\n        .and(method(\"PATCH\"))\n        .and(path(&mock_path))\n        .and(bearer_token(token))\n        .and(header(\"content-type\", \"application/json-patch+json\"))\n        .respond_with(\n            ResponseTemplate::new(200)\n                .insert_header(\"ETag\", \"12345\")\n                .set_body_json(new_sitelinks),\n        )\n        .mount(&mock_server)\n        .await;\n        let mut api = RestApi::builder(&(mock_server.uri() + \"/w/rest.php\"))\n            .unwrap()\n            .with_access_token(token)\n            .build();\n\n        // Apply patch and check API response\n        let id = EntityId::new(id).unwrap();\n        let mut patch = SitelinksPatch::default();\n        patch.replace_title(\"enwiki\", page_title);\n        let sl = patch.apply(&id, &mut api).await.unwrap();\n        assert_eq!(sl.get_wiki(\"enwiki\").unwrap().title(), page_title);\n    }\n\n    #[test]\n    fn test_replace_title() {\n        let mut patch = SitelinksPatch::default();\n        patch.replace_title(\"enwiki\", \"Foo Bar\");\n        assert_eq!(\n            patch.patch(),\n            &[PatchEntry::new(\n                \"replace\",\n                \"/enwiki/title\",\n                json!(\"Foo Bar\")\n            )]\n        );\n    }\n}\n","traces":[{"line":15,"address":[],"length":0,"stats":{"Line":2}},{"line":16,"address":[],"length":0,"stats":{"Line":2}},{"line":20,"address":[],"length":0,"stats":{"Line":2}},{"line":21,"address":[],"length":0,"stats":{"Line":4}},{"line":23,"address":[],"length":0,"stats":{"Line":2}},{"line":24,"address":[],"length":0,"stats":{"Line":2}},{"line":25,"address":[],"length":0,"stats":{"Line":2}},{"line":28,"address":[],"length":0,"stats":{"Line":8}},{"line":35,"address":[],"length":0,"stats":{"Line":3}},{"line":36,"address":[],"length":0,"stats":{"Line":3}},{"line":39,"address":[],"length":0,"stats":{"Line":2}},{"line":40,"address":[],"length":0,"stats":{"Line":2}},{"line":48,"address":[],"length":0,"stats":{"Line":1}},{"line":49,"address":[],"length":0,"stats":{"Line":2}}],"covered":14,"coverable":14},{"path":["/","Users","magnusmanske","rust","wikibase_rest_api","src","statement.rs"],"content":"use crate::{\n    property_value::{PropertyType, PropertyValue},\n    statement_patch::StatementPatch,\n    statement_value::StatementValue,\n    EditMetadata, EntityId, FromJson, HeaderInfo, HttpMisc, Reference, RestApi, RestApiError,\n    RevisionMatch, StatementRank,\n};\nuse derivative::Derivative;\nuse serde::ser::{Serialize, SerializeStruct, Serializer};\nuse serde_json::{json, Value};\nuse uuid::Uuid;\n\n#[derive(Derivative, Debug, Clone, Default)]\n#[derivative(PartialEq)]\npub struct Statement {\n    statement_id: Option<String>,\n    property: PropertyType,\n    value: StatementValue,\n    rank: StatementRank,\n    references: Vec<Reference>,\n    qualifiers: Vec<PropertyValue>,\n    #[derivative(PartialEq = \"ignore\")]\n    header_info: HeaderInfo,\n}\n\nimpl Serialize for Statement {\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: Serializer,\n    {\n        // #lizard forgives the complexity\n        let mut fields = 5;\n        if self.statement_id.is_some() {\n            fields += 1;\n        }\n        let mut s = serializer.serialize_struct(\"Statement\", fields)?;\n        if let Some(id) = &self.statement_id {\n            s.serialize_field(\"id\", &id)?;\n        }\n        s.serialize_field(\"property\", &self.property)?;\n        s.serialize_field(\"value\", &self.value)?;\n        s.serialize_field(\"rank\", &self.rank.as_str())?;\n        s.serialize_field(\"references\", &self.references)?;\n        s.serialize_field(\"qualifiers\", &self.qualifiers)?;\n        s.end()\n    }\n}\n\nimpl HttpMisc for Statement {\n    fn get_my_rest_api_path(&self, _id: &EntityId) -> Result<String, RestApiError> {\n        let id = self.id().ok_or(RestApiError::MissingId)?;\n        Self::get_rest_api_path_from_id(id)\n    }\n}\n\n// GET/PUT/POST/DELETE\nimpl Statement {\n    /// Convenience function to create a new string statement\n    pub fn new_string(property: &str, s: &str) -> Self {\n        Self {\n            statement_id: None,\n            property: PropertyType::property(property),\n            value: StatementValue::new_string(s),\n            rank: StatementRank::Normal,\n            references: vec![],\n            qualifiers: vec![],\n            header_info: HeaderInfo::default(),\n        }\n    }\n\n    /// Generates a new statement ID\n    pub fn new_id_for_entity(&mut self, entity_id: &EntityId) {\n        let uuid = Uuid::new_v4().to_string().to_ascii_uppercase();\n        self.set_id(Some(format!(\"{entity_id}${uuid}\")));\n    }\n\n    /// Fetches a statement from the API\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use wikibase_rest_api::prelude::*;\n    /// #[tokio::main]\n    /// async fn main() {\n    ///     let api = RestApi::wikidata().unwrap();\n    ///     let statement = Statement::get(\"Q42$F078E5B3-F9A8-480E-B7AC-D97778CBBEF9\", &api).await.unwrap();\n    ///     println!(\"{:?}\", statement);\n    /// }\n    /// ```\n    pub async fn get(statement_id: &str, api: &RestApi) -> Result<Self, RestApiError> {\n        Self::get_match(statement_id, api, RevisionMatch::default()).await\n    }\n\n    /// Creates a new statement via the API. And `id` needs to be set.\n    ///\n    /// Returns a `Statement`, which is **not** the same as the input `Statement`, but should be identical.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use wikibase_rest_api::prelude::*;\n    /// #[tokio::main]\n    /// async fn main() {\n    ///     let mut api = RestApi::wikidata().unwrap(); // Use Wikidata API\n    ///     let mut statement = Statement::new_string(\"P31\", \"Q42\"); // New statement\n    ///     statement.new_id_for_entity(&EntityId::new(\"Q13406268\").unwrap()); // New statement ID for entity\n    ///     statement = statement.put(&mut api).await.unwrap(); // Add statement to entity\n    /// }\n    pub async fn put(&self, api: &mut RestApi) -> Result<Self, RestApiError> {\n        self.put_match(api, EditMetadata::default()).await\n    }\n\n    /// Deletes a statement via the API\n    pub async fn delete(&self, api: &mut RestApi) -> Result<(), RestApiError> {\n        self.delete_match(api, EditMetadata::default()).await\n    }\n\n    /// Fetches a statement from the API with revision matching\n    pub async fn get_match(\n        statement_id: &str,\n        api: &RestApi,\n        rm: RevisionMatch,\n    ) -> Result<Self, RestApiError> {\n        let path = Self::get_rest_api_path_from_id(statement_id)?;\n        let (j, header_info) = Self::get_match_internal(api, &path, rm).await?;\n        Self::from_json_header_info(&j, header_info)\n    }\n\n    /// Creates a new statement via the API. And `id` needs to be set.\n    ///\n    /// Returns a `Statement`, which is **not** the same as the input `Statement`, but should be identical.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use wikibase_rest_api::prelude::*;\n    /// #[tokio::main]\n    /// async fn main() {\n    ///     let mut api = RestApi::wikidata().unwrap(); // Use Wikidata API\n    ///     let mut statement = Statement::new_string(\"P31\", \"Q42\"); // New statement\n    ///     statement.new_id_for_entity(&EntityId::new(\"Q13406268\").unwrap()); // New statement ID for entity\n    ///     statement = statement.put_match(&mut api, EditMetadata::default()).await.unwrap();\n    /// }\n    pub async fn put_match(\n        &self,\n        api: &mut RestApi,\n        em: EditMetadata,\n    ) -> Result<Self, RestApiError> {\n        let j0 = json!({\"statement\": self});\n        let request = self\n            .generate_json_request(&EntityId::None, reqwest::Method::PUT, j0, api, &em)\n            .await?;\n        let response = api.execute(request).await?;\n        let header_info = HeaderInfo::from_header(response.headers());\n        let j: Value = response.error_for_status()?.json().await?;\n        Self::from_json_header_info(&j, header_info)\n    }\n\n    /// Deletes a statement via the API with revision matching\n    pub async fn delete_match(\n        &self,\n        api: &mut RestApi,\n        em: EditMetadata,\n    ) -> Result<(), RestApiError> {\n        let j0 = json!({});\n        let request = self\n            .generate_json_request(&EntityId::None, reqwest::Method::DELETE, j0, api, &em)\n            .await?;\n        let message: Value = api\n            .execute(request)\n            .await?\n            .error_for_status()?\n            .json()\n            .await?;\n        if message == \"Statement deleted\" {\n            return Ok(());\n        }\n        Err(RestApiError::UnexpectedResponse(message))\n    }\n\n    /// Sets the statement property\n    pub fn set_property(&mut self, property: PropertyType) {\n        self.property = property;\n    }\n\n    /// Sets the statement value\n    pub fn set_value(&mut self, value: StatementValue) {\n        self.value = value;\n    }\n\n    /// Sets the statement rank\n    pub const fn set_rank(&mut self, rank: StatementRank) {\n        self.rank = rank;\n    }\n\n    /// Returns the references of the statement, mutable\n    pub const fn references_mut(&mut self) -> &mut Vec<Reference> {\n        &mut self.references\n    }\n\n    /// Returns the qualifiers of the statement, mutable\n    pub const fn qualifiers_mut(&mut self) -> &mut Vec<PropertyValue> {\n        &mut self.qualifiers\n    }\n\n    fn get_rest_api_path_from_id(id: &str) -> Result<String, RestApiError> {\n        Ok(format!(\"/statements/{id}\"))\n    }\n}\n\n// FromJson helper function\nimpl Statement {\n    fn generate_id_rank_from_json_header_info(\n        j: &Value,\n    ) -> Result<(String, StatementRank), RestApiError> {\n        let id = j[\"id\"]\n            .as_str()\n            .ok_or(RestApiError::MissingOrInvalidField {\n                field: \"id\".into(),\n                j: j.to_owned(),\n            })?\n            .to_string();\n        let rank_text = j[\"rank\"]\n            .as_str()\n            .ok_or(RestApiError::MissingOrInvalidField {\n                field: \"rank\".into(),\n                j: j.to_owned(),\n            })?;\n        let rank = StatementRank::new(rank_text)?;\n        Ok((id, rank))\n    }\n}\n\nimpl FromJson for Statement {\n    fn header_info(&self) -> &HeaderInfo {\n        &self.header_info\n    }\n\n    fn from_json_header_info(j: &Value, header_info: HeaderInfo) -> Result<Self, RestApiError> {\n        let (id, rank) = Self::generate_id_rank_from_json_header_info(j)?;\n        let property = PropertyType::from_json(&j[\"property\"])?;\n        let value = StatementValue::from_json(&j[\"value\"])?;\n        Ok(Statement {\n            statement_id: Some(id.to_string()),\n            property,\n            rank,\n            value,\n            references: Self::references_from_json(&j[\"references\"])?,\n            qualifiers: Self::qualifiers_from_json(&j[\"qualifiers\"])?,\n            header_info,\n        })\n    }\n}\n\n// The rest\nimpl Statement {\n    /// Generates a patch to transform `other` into `self`\n    pub fn patch(&self, other: &Self) -> Result<StatementPatch, RestApiError> {\n        let statement_id = match self.statement_id {\n            Some(ref id) => id,\n            None => return Err(RestApiError::MissingId),\n        };\n        let patch = json_patch::diff(&json!(&other), &json!(&self));\n        let patch = StatementPatch::from_json(statement_id, &json!(patch))?;\n        Ok(patch)\n    }\n\n    fn references_from_json(j: &Value) -> Result<Vec<Reference>, RestApiError> {\n        let mut ret = vec![];\n        let array = j.as_array().ok_or(RestApiError::WrongType {\n            field: \"references\".into(),\n            j: j.to_owned(),\n        })?;\n        for reference in array {\n            let ref_from_json = Reference::from_json(reference)?;\n            ret.push(ref_from_json);\n        }\n        Ok(ret)\n    }\n\n    fn qualifiers_from_json(j: &Value) -> Result<Vec<PropertyValue>, RestApiError> {\n        let array = j.as_array().ok_or(RestApiError::WrongType {\n            field: \"qualifiers\".into(),\n            j: j.to_owned(),\n        })?;\n        let mut ret = vec![];\n        for pv in array.iter() {\n            let property = PropertyType::from_json(&pv[\"property\"])?;\n            let value = StatementValue::from_json(&pv[\"value\"])?;\n            ret.push(PropertyValue::new(property, value));\n        }\n        Ok(ret)\n    }\n\n    /// Returns the statement ID\n    pub const fn id(&self) -> Option<&String> {\n        self.statement_id.as_ref()\n    }\n\n    /// Sets the statement ID\n    pub fn set_id(&mut self, id: Option<String>) {\n        self.statement_id = id;\n    }\n\n    /// Returns the statement property\n    pub const fn property(&self) -> &PropertyType {\n        &self.property\n    }\n\n    /// Returns the statement value\n    pub const fn value(&self) -> &StatementValue {\n        &self.value\n    }\n\n    /// Returns the statement rank\n    pub const fn rank(&self) -> &StatementRank {\n        &self.rank\n    }\n\n    /// Returns the references of the statement\n    pub fn references(&self) -> &[Reference] {\n        &self.references\n    }\n\n    /// Returns the qualifiers of the statement\n    pub fn qualifiers(&self) -> &[PropertyValue] {\n        &self.qualifiers\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::statement_value_content::StatementValueContent;\n    use wiremock::matchers::{body_partial_json, method, path};\n    use wiremock::{Mock, MockServer, ResponseTemplate};\n\n    #[tokio::test]\n    #[cfg_attr(miri, ignore)]\n    async fn test_statement_get() {\n        // #lizard forgives the complexity\n        let v = std::fs::read_to_string(\"test_data/test_statement_get.json\").unwrap();\n        let v: Value = serde_json::from_str(&v).unwrap();\n        let statement_id = v[\"id\"].as_str().unwrap().to_string();\n        let mock_path = format!(\"/w/rest.php/wikibase/v1/statements/{statement_id}\",);\n\n        let mock_server = MockServer::start().await;\n        Mock::given(method(\"GET\"))\n            .and(path(&mock_path))\n            .respond_with(ResponseTemplate::new(200).set_body_json(v))\n            .mount(&mock_server)\n            .await;\n\n        let api = RestApi::builder(&(mock_server.uri() + \"/w/rest.php\"))\n            .unwrap()\n            .build();\n        let statement = Statement::get(&statement_id, &api).await.unwrap();\n        assert_eq!(statement.id().unwrap(), &statement_id);\n        assert_eq!(\n            *statement.value(),\n            StatementValue::Value(StatementValueContent::String(\"Q42\".to_string()))\n        );\n    }\n\n    #[tokio::test]\n    #[cfg_attr(miri, ignore)]\n    async fn test_statement_put() {\n        // #lizard forgives the complexity\n        let v = std::fs::read_to_string(\"test_data/test_statement_put.json\").unwrap();\n        let v: Value = serde_json::from_str(&v).unwrap();\n        let statement_id = v[\"before\"][\"id\"].as_str().unwrap();\n        let mock_path = format!(\"/w/rest.php/wikibase/v1/statements/{statement_id}\");\n        let mock_value_before = StatementValue::Value(StatementValueContent::String(\n            v[\"before\"][\"value\"][\"content\"]\n                .as_str()\n                .unwrap()\n                .to_string(),\n        ));\n        let mock_value_after = StatementValue::Value(StatementValueContent::String(\n            v[\"after\"][\"value\"][\"content\"].as_str().unwrap().to_string(),\n        ));\n\n        let mock_server = MockServer::start().await;\n        Mock::given(method(\"GET\"))\n            .and(path(&mock_path))\n            .respond_with(ResponseTemplate::new(200).set_body_json(&v[\"before\"]))\n            .mount(&mock_server)\n            .await;\n        Mock::given(body_partial_json(json!({\"statement\": &v[\"after\"]})))\n            .and(method(\"PUT\"))\n            .and(path(&mock_path))\n            .respond_with(ResponseTemplate::new(200).set_body_json(&v[\"after\"]))\n            .mount(&mock_server)\n            .await;\n        let mut api = RestApi::builder(&(mock_server.uri() + \"/w/rest.php\"))\n            .unwrap()\n            .build();\n\n        // Get and check statement\n        let mut statement = Statement::get(statement_id, &api).await.unwrap();\n        assert_eq!(*statement.value(), mock_value_before);\n\n        // Change statement\n        statement.value = mock_value_after.to_owned();\n\n        // PUT, and check return value\n        let statement = statement.put(&mut api).await.unwrap();\n        assert_eq!(*statement.value(), mock_value_after);\n    }\n\n    #[tokio::test]\n    #[cfg_attr(miri, ignore)]\n    async fn test_statement_delete() {\n        // #lizard forgives the complexity\n        let statement_id = \"Q42$F078E5B3-F9A8-480E-B7AC-D97778CBBEF9\";\n        let mock_path = format!(\"/w/rest.php/wikibase/v1/statements/{statement_id}\");\n\n        let statement_id2 = \"no_such_statement\";\n        let mock_path2 = format!(\"/w/rest.php/wikibase/v1/statements/{statement_id2}\");\n\n        let mock_server = MockServer::start().await;\n        Mock::given(method(\"DELETE\"))\n            .and(path(&mock_path))\n            .respond_with(ResponseTemplate::new(200).set_body_json(\"Statement deleted\"))\n            .mount(&mock_server)\n            .await;\n        Mock::given(method(\"DELETE\"))\n            .and(path(&mock_path2))\n            .respond_with(ResponseTemplate::new(200).set_body_json(json!({\n              \"code\": \"invalid-statement-id\",\n              \"message\": format!(\"Not a valid statement ID: {statement_id2}\")\n            })))\n            .mount(&mock_server)\n            .await;\n        let mut api = RestApi::builder(&(mock_server.uri() + \"/w/rest.php\"))\n            .unwrap()\n            .build();\n\n        // Delete\n        let mut statement0 = Statement::new_string(\"P31\", \"Q42\");\n        statement0.set_id(Some(statement_id.to_string()));\n        assert!(statement0.delete(&mut api).await.is_ok());\n\n        // Delete (error)\n        let mut statement1 = Statement::new_string(\"P31\", \"Q42\");\n        statement1.set_id(Some(statement_id2.to_string()));\n        let result = statement1.delete(&mut api).await.unwrap_err().to_string();\n        assert_eq!(\n            result,\n            r#\"Unexpected response: {\"code\":\"invalid-statement-id\",\"message\":\"Not a valid statement ID: no_such_statement\"}\"#\n        );\n    }\n\n    #[test]\n    fn test_patch() {\n        let mut s1 = Statement::default();\n        s1.set_id(Some(\"Q42$F078E5B3-F9A8-480E-B7AC-D97778CBBEF9\".to_string()));\n        s1.set_property(PropertyType::property(\"P31\"));\n        s1.set_value(StatementValue::new_string(\"Q42\"));\n        let mut s2 = s1.clone();\n        s2.set_property(PropertyType::property(\"P32\"));\n        s2.set_value(StatementValue::new_string(\"Q43\"));\n        let patch = s2.patch(&s1).unwrap();\n        let patch_json = json!(patch);\n        assert_eq!(\n            patch_json,\n            json!({\"patch\":[{\"op\":\"replace\",\"path\":\"/property/id\",\"value\":\"P32\"},{\"op\":\"replace\",\"path\":\"/value/content\",\"value\":\"Q43\"}],\"statement_id\":\"Q42$F078E5B3-F9A8-480E-B7AC-D97778CBBEF9\"})\n        );\n    }\n\n    #[test]\n    fn test_set_rank() {\n        let mut s = Statement::default();\n        assert_eq!(s.rank(), &StatementRank::Normal);\n        s.set_rank(StatementRank::Preferred);\n        assert_eq!(s.rank(), &StatementRank::Preferred);\n    }\n\n    #[test]\n    fn test_references_mut() {\n        let mut s = Statement::default();\n        assert_eq!(s.references_mut().len(), 0);\n        s.references_mut().push(Reference::default());\n        assert_eq!(s.references_mut().len(), 1);\n    }\n\n    #[test]\n    fn test_qualifiers_mut() {\n        let mut s = Statement::default();\n        assert_eq!(s.qualifiers_mut().len(), 0);\n        s.qualifiers_mut().push(PropertyValue::new(\n            PropertyType::property(\"P31\"),\n            StatementValue::new_string(\"Q42\"),\n        ));\n        assert_eq!(s.qualifiers_mut().len(), 1);\n    }\n\n    #[test]\n    fn test_rank() {\n        let s = Statement::default();\n        assert_eq!(s.rank(), &StatementRank::Normal);\n    }\n\n    #[test]\n    fn test_references() {\n        let s = Statement::default();\n        assert_eq!(s.references().len(), 0);\n    }\n\n    #[test]\n    fn test_patch_no_id() {\n        let s1 = Statement::default();\n        let s2 = Statement::default();\n        let patch = s2.patch(&s1);\n        assert!(patch.is_err());\n    }\n\n    #[test]\n    fn test_references_from_json_not_array() {\n        let j = json!(123);\n        assert!(Statement::references_from_json(&j).is_err());\n    }\n\n    #[test]\n    fn test_references_from_json_not_a_reference() {\n        let j = json!([123]);\n        assert!(Statement::references_from_json(&j).is_err());\n    }\n\n    #[test]\n    fn test_references_from_json() {\n        let j = json!([\n            Reference::default(),\n            Reference::default(),\n            Reference::default()\n        ]);\n        let references = Statement::references_from_json(&j).unwrap();\n        assert_eq!(references.len(), 3);\n    }\n\n    #[test]\n    fn test_new_id_for_entity() {\n        let entity_id = EntityId::new(\"Q42\").unwrap();\n        let mut statement = Statement::default();\n        statement.new_id_for_entity(&entity_id);\n        assert_eq!(&statement.id().unwrap()[0..4], \"Q42$\");\n    }\n}\n","traces":[{"line":27,"address":[],"length":0,"stats":{"Line":1102}},{"line":32,"address":[],"length":0,"stats":{"Line":1102}},{"line":33,"address":[],"length":0,"stats":{"Line":2203}},{"line":34,"address":[],"length":0,"stats":{"Line":1101}},{"line":36,"address":[],"length":0,"stats":{"Line":2204}},{"line":37,"address":[],"length":0,"stats":{"Line":1101}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":1102}},{"line":41,"address":[],"length":0,"stats":{"Line":1102}},{"line":42,"address":[],"length":0,"stats":{"Line":1102}},{"line":43,"address":[],"length":0,"stats":{"Line":1102}},{"line":44,"address":[],"length":0,"stats":{"Line":1102}},{"line":45,"address":[],"length":0,"stats":{"Line":1102}},{"line":50,"address":[],"length":0,"stats":{"Line":3}},{"line":51,"address":[],"length":0,"stats":{"Line":6}},{"line":59,"address":[],"length":0,"stats":{"Line":4}},{"line":62,"address":[],"length":0,"stats":{"Line":4}},{"line":63,"address":[],"length":0,"stats":{"Line":4}},{"line":65,"address":[],"length":0,"stats":{"Line":4}},{"line":66,"address":[],"length":0,"stats":{"Line":4}},{"line":67,"address":[],"length":0,"stats":{"Line":4}},{"line":72,"address":[],"length":0,"stats":{"Line":1}},{"line":73,"address":[],"length":0,"stats":{"Line":1}},{"line":74,"address":[],"length":0,"stats":{"Line":1}},{"line":90,"address":[],"length":0,"stats":{"Line":4}},{"line":91,"address":[],"length":0,"stats":{"Line":2}},{"line":109,"address":[],"length":0,"stats":{"Line":2}},{"line":110,"address":[],"length":0,"stats":{"Line":1}},{"line":114,"address":[],"length":0,"stats":{"Line":4}},{"line":115,"address":[],"length":0,"stats":{"Line":2}},{"line":119,"address":[],"length":0,"stats":{"Line":2}},{"line":124,"address":[],"length":0,"stats":{"Line":4}},{"line":125,"address":[],"length":0,"stats":{"Line":2}},{"line":144,"address":[],"length":0,"stats":{"Line":1}},{"line":149,"address":[],"length":0,"stats":{"Line":1}},{"line":150,"address":[],"length":0,"stats":{"Line":2}},{"line":151,"address":[],"length":0,"stats":{"Line":1}},{"line":152,"address":[],"length":0,"stats":{"Line":1}},{"line":153,"address":[],"length":0,"stats":{"Line":1}},{"line":155,"address":[],"length":0,"stats":{"Line":2}},{"line":160,"address":[],"length":0,"stats":{"Line":2}},{"line":165,"address":[],"length":0,"stats":{"Line":2}},{"line":166,"address":[],"length":0,"stats":{"Line":4}},{"line":167,"address":[],"length":0,"stats":{"Line":2}},{"line":168,"address":[],"length":0,"stats":{"Line":2}},{"line":169,"address":[],"length":0,"stats":{"Line":2}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":2}},{"line":176,"address":[],"length":0,"stats":{"Line":1}},{"line":178,"address":[],"length":0,"stats":{"Line":1}},{"line":182,"address":[],"length":0,"stats":{"Line":15}},{"line":183,"address":[],"length":0,"stats":{"Line":15}},{"line":187,"address":[],"length":0,"stats":{"Line":3}},{"line":188,"address":[],"length":0,"stats":{"Line":3}},{"line":192,"address":[],"length":0,"stats":{"Line":1}},{"line":193,"address":[],"length":0,"stats":{"Line":1}},{"line":197,"address":[],"length":0,"stats":{"Line":3}},{"line":198,"address":[],"length":0,"stats":{"Line":3}},{"line":202,"address":[],"length":0,"stats":{"Line":3}},{"line":203,"address":[],"length":0,"stats":{"Line":3}},{"line":206,"address":[],"length":0,"stats":{"Line":5}},{"line":207,"address":[],"length":0,"stats":{"Line":5}},{"line":213,"address":[],"length":0,"stats":{"Line":3701}},{"line":216,"address":[],"length":0,"stats":{"Line":7402}},{"line":218,"address":[],"length":0,"stats":{"Line":3701}},{"line":219,"address":[],"length":0,"stats":{"Line":3701}},{"line":220,"address":[],"length":0,"stats":{"Line":3701}},{"line":223,"address":[],"length":0,"stats":{"Line":3701}},{"line":229,"address":[],"length":0,"stats":{"Line":3701}},{"line":235,"address":[],"length":0,"stats":{"Line":1}},{"line":236,"address":[],"length":0,"stats":{"Line":1}},{"line":239,"address":[],"length":0,"stats":{"Line":3701}},{"line":240,"address":[],"length":0,"stats":{"Line":7402}},{"line":241,"address":[],"length":0,"stats":{"Line":3701}},{"line":242,"address":[],"length":0,"stats":{"Line":3701}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":3701}},{"line":250,"address":[],"length":0,"stats":{"Line":3701}},{"line":258,"address":[],"length":0,"stats":{"Line":3}},{"line":259,"address":[],"length":0,"stats":{"Line":5}},{"line":260,"address":[],"length":0,"stats":{"Line":2}},{"line":261,"address":[],"length":0,"stats":{"Line":1}},{"line":263,"address":[],"length":0,"stats":{"Line":2}},{"line":264,"address":[],"length":0,"stats":{"Line":4}},{"line":268,"address":[],"length":0,"stats":{"Line":3704}},{"line":269,"address":[],"length":0,"stats":{"Line":3704}},{"line":270,"address":[],"length":0,"stats":{"Line":7407}},{"line":271,"address":[],"length":0,"stats":{"Line":3704}},{"line":272,"address":[],"length":0,"stats":{"Line":3704}},{"line":274,"address":[],"length":0,"stats":{"Line":6888}},{"line":275,"address":[],"length":0,"stats":{"Line":3186}},{"line":278,"address":[],"length":0,"stats":{"Line":3702}},{"line":281,"address":[],"length":0,"stats":{"Line":3701}},{"line":282,"address":[],"length":0,"stats":{"Line":7402}},{"line":283,"address":[],"length":0,"stats":{"Line":3701}},{"line":284,"address":[],"length":0,"stats":{"Line":3701}},{"line":287,"address":[],"length":0,"stats":{"Line":1595}},{"line":288,"address":[],"length":0,"stats":{"Line":3190}},{"line":289,"address":[],"length":0,"stats":{"Line":1595}},{"line":292,"address":[],"length":0,"stats":{"Line":3701}},{"line":296,"address":[],"length":0,"stats":{"Line":15}},{"line":297,"address":[],"length":0,"stats":{"Line":15}},{"line":301,"address":[],"length":0,"stats":{"Line":13}},{"line":302,"address":[],"length":0,"stats":{"Line":13}},{"line":306,"address":[],"length":0,"stats":{"Line":18}},{"line":307,"address":[],"length":0,"stats":{"Line":18}},{"line":311,"address":[],"length":0,"stats":{"Line":6}},{"line":312,"address":[],"length":0,"stats":{"Line":6}},{"line":316,"address":[],"length":0,"stats":{"Line":3}},{"line":317,"address":[],"length":0,"stats":{"Line":3}},{"line":321,"address":[],"length":0,"stats":{"Line":1}},{"line":322,"address":[],"length":0,"stats":{"Line":1}},{"line":326,"address":[],"length":0,"stats":{"Line":1}},{"line":327,"address":[],"length":0,"stats":{"Line":1}}],"covered":111,"coverable":114},{"path":["/","Users","magnusmanske","rust","wikibase_rest_api","src","statement_patch.rs"],"content":"use crate::{\n    patch_entry::PatchEntry, EditMetadata, EntityId, FromJson, HttpMisc, Patch, PatchApply,\n    RestApi, RestApiError, Statement,\n};\nuse async_trait::async_trait;\nuse serde::Serialize;\nuse serde_json::{json, Value};\n\n#[derive(Debug, Clone, Default, PartialEq, Serialize)]\npub struct StatementPatch {\n    statement_id: String,\n    patch: Vec<PatchEntry>,\n}\n\nimpl HttpMisc for StatementPatch {\n    fn get_my_rest_api_path(&self, _id: &EntityId) -> Result<String, RestApiError> {\n        Ok(format!(\"/statements/{id}\", id = self.statement_id))\n    }\n}\n\nimpl StatementPatch {\n    /// Generates a new `StatementPatch` for a given statement ID\n    pub fn new<S: Into<String>>(id: S) -> Self {\n        Self {\n            statement_id: id.into(),\n            patch: vec![],\n        }\n    }\n\n    /// Generates a patch from JSON, presumably from `json_patch`\n    pub fn from_json<S: Into<String>>(\n        statement_id: S,\n        j: &Value,\n    ) -> Result<StatementPatch, RestApiError> {\n        let pe = j\n            .as_array()\n            .ok_or(RestApiError::WrongType {\n                field: \"StatementPatch\".into(),\n                j: j.to_owned(),\n            })?\n            .iter()\n            .map(|x| serde_json::from_value(x.clone()).map_err(|e| e.into()))\n            .collect::<Result<Vec<PatchEntry>, RestApiError>>()?;\n        Ok(StatementPatch {\n            patch: pe,\n            statement_id: statement_id.into(),\n        })\n    }\n\n    /// Adds a command to replace the content of a statement\n    pub fn replace_content(&mut self, value: Value) {\n        self.replace(\"/value/content\".to_string(), value);\n    }\n\n    // Overrides the Patch<Statement> implementation becaue we don't need the EntityId\n    pub async fn apply(&self, api: &mut RestApi) -> Result<Statement, RestApiError> {\n        self.apply_match(api, EditMetadata::default()).await\n    }\n\n    // Overrides the Patch<Statement> implementation becaue we don't need the EntityId\n    pub async fn apply_match(\n        &self,\n        api: &mut RestApi,\n        em: EditMetadata,\n    ) -> Result<Statement, RestApiError> {\n        <Self as PatchApply<Statement>>::apply_match(self, &EntityId::None, api, em).await\n    }\n}\n\n#[async_trait]\nimpl Patch for StatementPatch {\n    fn patch(&self) -> &Vec<PatchEntry> {\n        &self.patch\n    }\n\n    fn patch_mut(&mut self) -> &mut Vec<PatchEntry> {\n        &mut self.patch\n    }\n}\n\n#[async_trait]\nimpl PatchApply<Statement> for StatementPatch {\n    async fn apply_match(\n        &self,\n        _id: &EntityId,\n        api: &mut RestApi,\n        em: EditMetadata,\n    ) -> Result<Statement, RestApiError> {\n        let j0 = json!({\"patch\":self.patch});\n        let request = self\n            .generate_json_request(&EntityId::None, reqwest::Method::PATCH, j0, api, &em)\n            .await?;\n        let response = api.execute(request).await?;\n        let (j, header_info) = self.filter_response_error(response).await?;\n        Statement::from_json_header_info(&j, header_info)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::statement_value::StatementValue;\n    use wiremock::matchers::{bearer_token, body_partial_json, header, method, path};\n    use wiremock::{Mock, MockServer, ResponseTemplate};\n\n    use super::*;\n\n    #[tokio::test]\n    #[cfg_attr(miri, ignore)]\n    async fn test_statement_patch() {\n        let v = std::fs::read_to_string(\"test_data/Q42.json\").unwrap();\n        let v: Value = serde_json::from_str(&v).unwrap();\n        let mut new_statement = v[\"statements\"][\"P31\"][0].clone();\n        new_statement[\"value\"][\"content\"] = json!(\"Q6\");\n\n        let statement_id = \"Q42$F078E5B3-F9A8-480E-B7AC-D97778CBBEF9\";\n        let mock_path = format!(\"/w/rest.php/wikibase/v1/statements/{statement_id}\");\n        let mock_server = MockServer::start().await;\n        let token = \"FAKE_TOKEN\";\n        Mock::given(body_partial_json(\n            json!({\"patch\":[{\"op\": \"replace\",\"path\": \"/value/content\",\"value\": \"Q6\"}]}),\n        ))\n        .and(method(\"PATCH\"))\n        .and(path(&mock_path))\n        .and(bearer_token(token))\n        .and(header(\"content-type\", \"application/json-patch+json\"))\n        .respond_with(\n            ResponseTemplate::new(200)\n                .insert_header(\"ETag\", \"12345\")\n                .set_body_json(new_statement),\n        )\n        .mount(&mock_server)\n        .await;\n        let mut api = RestApi::builder(&(mock_server.uri() + \"/w/rest.php\"))\n            .unwrap()\n            .with_access_token(token)\n            .build();\n\n        // Patch statement\n        let mut patch = StatementPatch::new(statement_id);\n        patch.replace_content(json!(\"Q6\"));\n        let statement = patch.apply(&mut api).await.unwrap();\n        assert_eq!(statement.header_info().revision_id(), Some(12345));\n        assert_eq!(statement.value(), &StatementValue::new_string(\"Q6\"));\n    }\n\n    #[test]\n    fn test_replace_content() {\n        let mut patch = StatementPatch::new(\"Q42$F078E5B3-F9A8-480E-B7AC-D97778CBBEF9\");\n        patch.replace_content(json!(\"Q6\"));\n        assert_eq!(\n            patch.patch(),\n            &[PatchEntry::new(\"replace\", \"/value/content\", json!(\"Q6\"))]\n        );\n    }\n\n    #[test]\n    fn test_get_rest_api_path() {\n        let patch = StatementPatch::new(\"Q42$F078E5B3-F9A8-480E-B7AC-D97778CBBEF9\");\n        assert_eq!(\n            patch\n                .get_my_rest_api_path(&EntityId::new(\"Q42\").unwrap())\n                .unwrap(),\n            \"/statements/Q42$F078E5B3-F9A8-480E-B7AC-D97778CBBEF9\"\n        );\n    }\n}\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":2}},{"line":17,"address":[],"length":0,"stats":{"Line":2}},{"line":23,"address":[],"length":0,"stats":{"Line":3}},{"line":25,"address":[],"length":0,"stats":{"Line":3}},{"line":26,"address":[],"length":0,"stats":{"Line":3}},{"line":31,"address":[],"length":0,"stats":{"Line":2}},{"line":35,"address":[],"length":0,"stats":{"Line":4}},{"line":37,"address":[],"length":0,"stats":{"Line":2}},{"line":38,"address":[],"length":0,"stats":{"Line":2}},{"line":39,"address":[],"length":0,"stats":{"Line":2}},{"line":42,"address":[],"length":0,"stats":{"Line":6}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":2}},{"line":52,"address":[],"length":0,"stats":{"Line":2}},{"line":56,"address":[],"length":0,"stats":{"Line":2}},{"line":57,"address":[],"length":0,"stats":{"Line":1}},{"line":61,"address":[],"length":0,"stats":{"Line":1}},{"line":66,"address":[],"length":0,"stats":{"Line":1}},{"line":72,"address":[],"length":0,"stats":{"Line":2}},{"line":73,"address":[],"length":0,"stats":{"Line":2}},{"line":76,"address":[],"length":0,"stats":{"Line":2}},{"line":77,"address":[],"length":0,"stats":{"Line":2}},{"line":89,"address":[],"length":0,"stats":{"Line":1}},{"line":90,"address":[],"length":0,"stats":{"Line":2}},{"line":91,"address":[],"length":0,"stats":{"Line":1}},{"line":92,"address":[],"length":0,"stats":{"Line":1}},{"line":93,"address":[],"length":0,"stats":{"Line":1}},{"line":94,"address":[],"length":0,"stats":{"Line":1}}],"covered":27,"coverable":30},{"path":["/","Users","magnusmanske","rust","wikibase_rest_api","src","statement_rank.rs"],"content":"use crate::RestApiError;\n\n#[derive(Debug, Clone, PartialEq, Default, Copy)]\npub enum StatementRank {\n    #[default]\n    Normal,\n    Preferred,\n    Deprecated,\n}\n\nimpl StatementRank {\n    /// Create a new `StatementRank` from a string\n    pub fn new<S: Into<String>>(s: S) -> Result<Self, RestApiError> {\n        match s.into().to_lowercase().as_str() {\n            \"normal\" => Ok(StatementRank::Normal),\n            \"preferred\" => Ok(StatementRank::Preferred),\n            \"deprecated\" => Ok(StatementRank::Deprecated),\n            s => Err(RestApiError::UnknownStatementRank(s.into())),\n        }\n    }\n\n    /// Returns the `StatementRank` as a string\n    pub const fn as_str(&self) -> &str {\n        match self {\n            StatementRank::Normal => \"normal\",\n            StatementRank::Preferred => \"preferred\",\n            StatementRank::Deprecated => \"deprecated\",\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_from_str() {\n        assert_eq!(StatementRank::new(\"normal\").unwrap(), StatementRank::Normal);\n        assert_eq!(\n            StatementRank::new(\"preferred\").unwrap(),\n            StatementRank::Preferred\n        );\n        assert_eq!(\n            StatementRank::new(\"deprecated\").unwrap(),\n            StatementRank::Deprecated\n        );\n        assert!(StatementRank::new(\"unknown\").is_err());\n    }\n\n    #[test]\n    fn test_as_str() {\n        assert_eq!(StatementRank::Normal.as_str(), \"normal\");\n        assert_eq!(StatementRank::Preferred.as_str(), \"preferred\");\n        assert_eq!(StatementRank::Deprecated.as_str(), \"deprecated\");\n    }\n}\n","traces":[{"line":13,"address":[],"length":0,"stats":{"Line":3705}},{"line":14,"address":[],"length":0,"stats":{"Line":3705}},{"line":15,"address":[],"length":0,"stats":{"Line":7336}},{"line":16,"address":[],"length":0,"stats":{"Line":125}},{"line":17,"address":[],"length":0,"stats":{"Line":45}},{"line":18,"address":[],"length":0,"stats":{"Line":1}},{"line":23,"address":[],"length":0,"stats":{"Line":1105}},{"line":24,"address":[],"length":0,"stats":{"Line":1105}},{"line":25,"address":[],"length":0,"stats":{"Line":1082}},{"line":26,"address":[],"length":0,"stats":{"Line":16}},{"line":27,"address":[],"length":0,"stats":{"Line":7}}],"covered":11,"coverable":11},{"path":["/","Users","magnusmanske","rust","wikibase_rest_api","src","statement_value.rs"],"content":"use crate::statement_value_content::StatementValueContent;\nuse crate::RestApiError;\nuse serde::ser::{Serialize, SerializeStruct, Serializer};\nuse serde_json::Value;\n\n#[derive(Debug, Clone, PartialEq, Default)]\npub enum StatementValue {\n    Value(StatementValueContent),\n    SomeValue,\n    #[default]\n    NoValue,\n}\n\nimpl StatementValue {\n    /// Creates a new `StatementValue` object from a JSON object.\n    pub fn from_json(j: &Value) -> Result<Self, RestApiError> {\n        let value_type = j[\"type\"]\n            .as_str()\n            .ok_or_else(|| RestApiError::MissingOrInvalidField {\n                field: \"type\".into(),\n                j: j.to_owned(),\n            })?;\n        match value_type {\n            \"value\" => Ok(Self::Value(StatementValueContent::from_json(\n                &j[\"content\"],\n            )?)),\n            \"somevalue\" => Ok(Self::SomeValue),\n            \"novalue\" => Ok(Self::NoValue),\n            _ => Err(RestApiError::UnknownValue(value_type.into())),\n        }\n    }\n\n    /// Creates a new `StatementValue` object from a string, as a String value.\n    pub fn new_string<S: Into<String>>(text: S) -> Self {\n        StatementValue::Value(StatementValueContent::String(text.into()))\n    }\n\n    // TODO more convenience functions\n}\n\n#[cfg(not(tarpaulin_include))] // tarpaulin can't handle the Serialize trait\nimpl Serialize for StatementValue {\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: Serializer,\n    {\n        // #lizard forgives the complexity\n        match self {\n            StatementValue::Value(content) => {\n                let mut s = serializer.serialize_struct(\"StatementValue\", 2)?;\n                s.serialize_field(\"type\", \"value\")?;\n                s.serialize_field(\"content\", content)?;\n                s.end()\n            }\n            StatementValue::SomeValue => {\n                let mut s = serializer.serialize_struct(\"StatementValue\", 1)?;\n                s.serialize_field(\"type\", \"somevalue\")?;\n                s.end()\n            }\n            StatementValue::NoValue => {\n                let mut s = serializer.serialize_struct(\"StatementValue\", 1)?;\n                s.serialize_field(\"type\", \"novalue\")?;\n                s.end()\n            }\n        }\n    }\n}\n\n/// Implement the From trait for `StatementValueContent` to `StatementValue`, for convenience assignments.\nimpl From<StatementValueContent> for StatementValue {\n    fn from(content: StatementValueContent) -> Self {\n        StatementValue::Value(content)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::prelude::*;\n    use crate::{entity::Entity, EntityId, Item};\n    use serde_json::json;\n    use wiremock::matchers::{method, path};\n    use wiremock::{Mock, MockServer, ResponseTemplate};\n\n    #[tokio::test]\n    #[cfg_attr(miri, ignore)]\n    async fn test_somevalue() {\n        let v = std::fs::read_to_string(\"test_data/Q42.json\").unwrap();\n        let v: Value = serde_json::from_str(&v).unwrap();\n        let id = v[\"id\"].as_str().unwrap();\n\n        let mock_path = format!(\"/w/rest.php/wikibase/v1/entities/items/{id}\");\n        let mock_server = MockServer::start().await;\n        Mock::given(method(\"GET\"))\n            .and(path(&mock_path))\n            .respond_with(ResponseTemplate::new(200).set_body_json(&v))\n            .mount(&mock_server)\n            .await;\n        let api = RestApi::builder(&(mock_server.uri() + \"/w/rest.php\"))\n            .unwrap()\n            .build();\n\n        let item = Item::get(EntityId::item(id), &api).await.unwrap();\n        let prop = item.statements().property(\"P2021\")[0].to_owned();\n        let qual = &prop.qualifiers()[0];\n        assert_eq!(qual.value(), &StatementValue::SomeValue);\n    }\n\n    #[tokio::test]\n    #[cfg_attr(miri, ignore)]\n    async fn test_novalue() {\n        let v = std::fs::read_to_string(\"test_data/Q255.json\").unwrap();\n        let v: Value = serde_json::from_str(&v).unwrap();\n        let id = v[\"id\"].as_str().unwrap();\n\n        let mock_path = format!(\"/w/rest.php/wikibase/v1/entities/items/{id}\");\n        let mock_server = MockServer::start().await;\n        Mock::given(method(\"GET\"))\n            .and(path(&mock_path))\n            .respond_with(ResponseTemplate::new(200).set_body_json(&v))\n            .mount(&mock_server)\n            .await;\n        let api = RestApi::builder(&(mock_server.uri() + \"/w/rest.php\"))\n            .unwrap()\n            .build();\n\n        let item = Item::get(EntityId::item(id), &api).await.unwrap();\n        let prop = item.statements().property(\"P40\")[0];\n        assert_eq!(prop.value(), &StatementValue::NoValue);\n    }\n\n    #[test]\n    fn test_serialize_string() {\n        let s = StatementValue::Value(StatementValueContent::String(\"foo\".to_string()));\n        let j: Value = json!(s);\n        assert_eq!(j, json!({\"type\": \"value\", \"content\": \"foo\"}));\n    }\n\n    #[test]\n    fn test_serialize_time() {\n        let s = StatementValue::Value(StatementValueContent::Time {\n            time: \"+2021-01-01T00:00:00Z\".to_string(),\n            precision: TimePrecision::Day,\n            calendarmodel: \"http://www.wikidata.org/entity/Q1985727\".to_string(),\n        });\n        let j: Value = json!(s);\n        assert_eq!(\n            j,\n            json!({\"type\": \"value\", \"content\": {\"time\": \"+2021-01-01T00:00:00Z\", \"precision\": 11, \"calendarmodel\": \"http://www.wikidata.org/entity/Q1985727\"}})\n        );\n    }\n\n    #[test]\n    fn test_serialize_location() {\n        let s = StatementValue::Value(StatementValueContent::Location {\n            latitude: 37.786971,\n            longitude: -122.399677,\n            precision: 0.0001,\n            globe: \"http://www.wikidata.org/entity/Q2\".to_string(),\n        });\n        let j: Value = json!(s);\n        assert_eq!(\n            j,\n            json!({\"type\": \"value\", \"content\": {\"latitude\": 37.786971, \"longitude\": -122.399677, \"precision\": 0.0001, \"globe\": \"http://www.wikidata.org/entity/Q2\"}})\n        );\n    }\n\n    #[test]\n    fn test_serialize_quantity() {\n        let s = StatementValue::Value(StatementValueContent::Quantity {\n            amount: \"42\".to_string(),\n            unit: \"http://www.wikidata.org/entity/Q11573\".to_string(),\n        });\n        let j: Value = json!(s);\n        assert_eq!(\n            j,\n            json!({\"type\": \"value\", \"content\": {\"amount\": \"42\", \"unit\": \"http://www.wikidata.org/entity/Q11573\"}})\n        );\n    }\n\n    #[test]\n    fn test_serialize_monolingual_text() {\n        let s = StatementValue::Value(StatementValueContent::MonolingualText {\n            language: \"en\".to_string(),\n            text: \"foo\".to_string(),\n        });\n        let j: Value = json!(s);\n        assert_eq!(\n            j,\n            json!({\"type\": \"value\", \"content\": {\"language\": \"en\", \"text\": \"foo\"}})\n        );\n    }\n\n    #[test]\n    fn test_serialize_somevalue() {\n        let s = StatementValue::SomeValue;\n        let j: Value = json!(s);\n        assert_eq!(j, json!({\"type\": \"somevalue\"}));\n    }\n\n    #[test]\n    fn test_serialize_novalue() {\n        let s = StatementValue::NoValue;\n        let j: Value = json!(s);\n        assert_eq!(j, json!({\"type\": \"novalue\"}));\n    }\n\n    #[test]\n    fn test_from_string() {\n        let s = StatementValue::new_string(\"foo\");\n        assert_eq!(\n            s,\n            StatementValue::Value(StatementValueContent::String(\"foo\".to_string()))\n        );\n    }\n\n    #[test]\n    fn test_from_time() {\n        let s = StatementValue::Value(StatementValueContent::Time {\n            time: \"+2021-01-01T00:00:00Z\".to_string(),\n            precision: TimePrecision::Day,\n            calendarmodel: \"http://www.wikidata.org/entity/Q1985727\".to_string(),\n        });\n        assert_eq!(\n            s,\n            StatementValue::Value(StatementValueContent::Time {\n                time: \"+2021-01-01T00:00:00Z\".to_string(),\n                precision: TimePrecision::Day,\n                calendarmodel: \"http://www.wikidata.org/entity/Q1985727\".to_string()\n            })\n        );\n    }\n\n    #[test]\n    fn test_from_location() {\n        let s = StatementValue::Value(StatementValueContent::Location {\n            latitude: 37.786971,\n            longitude: -122.399677,\n            precision: 0.0001,\n            globe: \"http://www.wikidata.org/entity/Q2\".to_string(),\n        });\n        assert_eq!(\n            s,\n            StatementValue::Value(StatementValueContent::Location {\n                latitude: 37.786971,\n                longitude: -122.399677,\n                precision: 0.0001,\n                globe: \"http://www.wikidata.org/entity/Q2\".to_string()\n            })\n        );\n    }\n\n    #[test]\n    fn test_from_quantity() {\n        let s = StatementValue::Value(StatementValueContent::Quantity {\n            amount: \"42\".to_string(),\n            unit: \"http://www.wikidata.org/entity/Q11573\".to_string(),\n        });\n        assert_eq!(\n            s,\n            StatementValue::Value(StatementValueContent::Quantity {\n                amount: \"42\".to_string(),\n                unit: \"http://www.wikidata.org/entity/Q11573\".to_string()\n            })\n        );\n    }\n\n    #[test]\n    fn test_from_monolingual_text() {\n        let s = StatementValue::Value(StatementValueContent::MonolingualText {\n            language: \"en\".to_string(),\n            text: \"foo\".to_string(),\n        });\n        assert_eq!(\n            s,\n            StatementValue::Value(StatementValueContent::MonolingualText {\n                language: \"en\".to_string(),\n                text: \"foo\".to_string()\n            })\n        );\n    }\n\n    #[test]\n    fn test_from_somevalue() {\n        let s = StatementValue::SomeValue;\n        assert_eq!(s, StatementValue::SomeValue);\n    }\n\n    #[test]\n    fn test_from_novalue() {\n        let s = StatementValue::NoValue;\n        assert_eq!(s, StatementValue::NoValue);\n    }\n\n    #[test]\n    fn test_from_json_string() {\n        let j = json!(\"foo\");\n        let s = StatementValueContent::from_json(&j).unwrap();\n        assert_eq!(s, StatementValueContent::String(\"foo\".to_string()));\n    }\n\n    #[test]\n    fn test_from_json_time() {\n        let j = json!({\"time\": \"+2021-01-01T00:00:00Z\", \"precision\": 11, \"calendarmodel\": \"http://www.wikidata.org/entity/Q1985727\"});\n        let s = StatementValueContent::from_json(&j).unwrap();\n        assert_eq!(\n            s,\n            StatementValueContent::Time {\n                time: \"+2021-01-01T00:00:00Z\".to_string(),\n                precision: TimePrecision::Day,\n                calendarmodel: \"http://www.wikidata.org/entity/Q1985727\".to_string()\n            }\n        );\n    }\n\n    #[test]\n    fn test_from_json_location() {\n        let j = json!({\"latitude\": 37.786971, \"longitude\": -122.399677, \"precision\": 0.0001, \"globe\": \"http://www.wikidata.org/entity/Q2\"});\n        let s = StatementValueContent::from_json(&j).unwrap();\n        assert_eq!(\n            s,\n            StatementValueContent::Location {\n                latitude: 37.786971,\n                longitude: -122.399677,\n                precision: 0.0001,\n                globe: \"http://www.wikidata.org/entity/Q2\".to_string()\n            }\n        );\n    }\n\n    #[test]\n    fn test_from_json_quantity() {\n        let j = json!({\"amount\": \"42\", \"unit\": \"http://www.wikidata.org/entity/Q11573\"});\n        let s = StatementValueContent::from_json(&j).unwrap();\n        assert_eq!(\n            s,\n            StatementValueContent::Quantity {\n                amount: \"42\".to_string(),\n                unit: \"http://www.wikidata.org/entity/Q11573\".to_string()\n            }\n        );\n    }\n\n    #[test]\n    fn test_from_json_monolingual_text() {\n        let j = json!({\"language\": \"en\", \"text\": \"foo\"});\n        let s = StatementValueContent::from_json(&j).unwrap();\n        assert_eq!(\n            s,\n            StatementValueContent::MonolingualText {\n                language: \"en\".to_string(),\n                text: \"foo\".to_string()\n            }\n        );\n    }\n\n    #[test]\n    fn test_from_json_error() {\n        let j = json!({\"foo\": \"bar\"});\n        let s = StatementValueContent::from_json(&j);\n        assert!(s.is_err());\n    }\n\n    #[test]\n    fn test_statement_value_contents_serialize_string() {\n        // #lizard forgives the complexity\n        let svc = StatementValueContent::String(\"foo\".to_string());\n        let j: Value = serde_json::to_value(&svc).unwrap();\n        assert_eq!(j, json!(\"foo\"));\n    }\n\n    #[test]\n    fn test_statement_value_contents_serialize_time() {\n        let svc = StatementValueContent::Time {\n            time: \"+2021-01-01T00:00:00Z\".to_string(),\n            precision: TimePrecision::Day,\n            calendarmodel: \"http://www.wikidata.org/entity/Q1985727\".to_string(),\n        };\n        let j: Value = serde_json::to_value(&svc).unwrap();\n        assert_eq!(\n            j,\n            json!({\"time\": \"+2021-01-01T00:00:00Z\", \"precision\": 11, \"calendarmodel\": \"http://www.wikidata.org/entity/Q1985727\"})\n        );\n    }\n\n    #[test]\n    fn test_statement_value_contents_serialize_location() {\n        let svc = StatementValueContent::Location {\n            latitude: 37.786971,\n            longitude: -122.399677,\n            precision: 0.0001,\n            globe: \"http://www.wikidata.org/entity/Q2\".to_string(),\n        };\n        let j: Value = serde_json::to_value(&svc).unwrap();\n        assert_eq!(\n            j,\n            json!({\"latitude\": 37.786971, \"longitude\": -122.399677, \"precision\": 0.0001, \"globe\": \"http://www.wikidata.org/entity/Q2\"})\n        );\n    }\n\n    #[test]\n    fn test_statement_value_contents_serialize_quantity() {\n        let svc = StatementValueContent::Quantity {\n            amount: \"42\".to_string(),\n            unit: \"http://www.wikidata.org/entity/Q11573\".to_string(),\n        };\n        let j: Value = serde_json::to_value(&svc).unwrap();\n        assert_eq!(\n            j,\n            json!({\"amount\": \"42\", \"unit\": \"http://www.wikidata.org/entity/Q11573\"})\n        );\n    }\n\n    #[test]\n    fn test_statement_value_contents_serialize_monolingual_text() {\n        let svc = StatementValueContent::MonolingualText {\n            language: \"en\".to_string(),\n            text: \"foo\".to_string(),\n        };\n        let j: Value = serde_json::to_value(&svc).unwrap();\n        assert_eq!(j, json!({\"language\": \"en\", \"text\": \"foo\"}));\n    }\n}\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":9809}},{"line":17,"address":[],"length":0,"stats":{"Line":19618}},{"line":19,"address":[],"length":0,"stats":{"Line":9809}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":9797}},{"line":25,"address":[],"length":0,"stats":{"Line":9797}},{"line":27,"address":[],"length":0,"stats":{"Line":20}},{"line":28,"address":[],"length":0,"stats":{"Line":8}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":18}},{"line":35,"address":[],"length":0,"stats":{"Line":18}},{"line":71,"address":[],"length":0,"stats":{"Line":1}},{"line":72,"address":[],"length":0,"stats":{"Line":1}}],"covered":11,"coverable":14},{"path":["/","Users","magnusmanske","rust","wikibase_rest_api","src","statement_value_content.rs"],"content":"use crate::RestApiError;\nuse serde::ser::{Serialize, SerializeStruct, Serializer};\nuse serde_json::{json, Value};\n\n/// Represents the Gregorian calendar model.\npub const GREGORIAN_CALENDAR: &str = \"http://www.wikidata.org/entity/Q1985727\";\n\n/// Represents the Julian calendar model.\npub const JULIAN_CALENDAR: &str = \"http://www.wikidata.org/entity/Q11184\";\n\n/// Represents the precision of a time value.\n#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]\npub enum TimePrecision {\n    BillionYears = 0,\n    HundredMillionYears = 1,\n    TenMillionYears = 2,\n    MillionYears = 3,\n    HundredMillennia = 4,\n    TenMillennia = 5,\n    Millennia = 6,\n    Century = 7,\n    Decade = 8,\n    Year = 9,\n    Month = 10,\n    Day = 11,\n    Hour = 12,\n    Minute = 13,\n    Second = 14,\n}\n\nimpl TryFrom<u8> for TimePrecision {\n    type Error = &'static str;\n\n    fn try_from(value: u8) -> Result<Self, Self::Error> {\n        match value {\n            0 => Ok(TimePrecision::BillionYears),\n            1 => Ok(TimePrecision::HundredMillionYears),\n            2 => Ok(TimePrecision::TenMillionYears),\n            3 => Ok(TimePrecision::MillionYears),\n            4 => Ok(TimePrecision::HundredMillennia),\n            5 => Ok(TimePrecision::TenMillennia),\n            6 => Ok(TimePrecision::Millennia),\n            7 => Ok(TimePrecision::Century),\n            8 => Ok(TimePrecision::Decade),\n            9 => Ok(TimePrecision::Year),\n            10 => Ok(TimePrecision::Month),\n            11 => Ok(TimePrecision::Day),\n            12 => Ok(TimePrecision::Hour),\n            13 => Ok(TimePrecision::Minute),\n            14 => Ok(TimePrecision::Second),\n            _ => Err(\"Invalid TimePrecision value\"),\n        }\n    }\n}\n\nimpl From<TimePrecision> for u8 {\n    fn from(precision: TimePrecision) -> Self {\n        precision as u8\n    }\n}\n\nimpl TryFrom<u64> for TimePrecision {\n    type Error = &'static str;\n\n    fn try_from(value: u64) -> Result<Self, Self::Error> {\n        if value > u64::from(u8::MAX) {\n            return Err(\"Value too large for TimePrecision\");\n        }\n        (value as u8).try_into()\n    }\n}\n\nimpl From<TimePrecision> for u64 {\n    fn from(precision: TimePrecision) -> Self {\n        u64::from(u8::from(precision))\n    }\n}\n\n#[derive(Debug, Clone, PartialEq)]\npub enum StatementValueContent {\n    String(String),\n    Time {\n        time: String,\n        precision: TimePrecision,\n        calendarmodel: String,\n    },\n    Location {\n        latitude: f64,\n        longitude: f64,\n        precision: f64,\n        globe: String,\n    },\n    Quantity {\n        amount: String,\n        unit: String,\n    },\n    MonolingualText {\n        language: String,\n        text: String,\n    },\n}\n\nimpl StatementValueContent {\n    /// Creates a new `StatementValueContent` object from a JSON object.\n    pub fn from_json(j: &Value) -> Result<Self, RestApiError> {\n        // #lizard forgives the complexity\n        if let Some(s) = j.as_str() {\n            return Ok(StatementValueContent::String(s.to_string()));\n        }\n        if let (Some(time), Some(precision), Some(calendarmodel)) = (\n            j[\"time\"].as_str(),\n            j[\"precision\"].as_u64(),\n            j[\"calendarmodel\"].as_str(),\n        ) {\n            return Ok(StatementValueContent::Time {\n                time: time.to_string(),\n                precision: precision\n                    .try_into()\n                    .map_err(|_| RestApiError::InvalidPrecision)?,\n                calendarmodel: calendarmodel.to_string(),\n            });\n        }\n        if let (Some(latitude), Some(longitude), Some(precision), Some(globe)) = (\n            j[\"latitude\"].as_f64(),\n            j[\"longitude\"].as_f64(),\n            j[\"precision\"].as_f64(),\n            j[\"globe\"].as_str(),\n        ) {\n            return Ok(StatementValueContent::Location {\n                latitude,\n                longitude,\n                precision,\n                globe: globe.to_string(),\n            });\n        }\n        if let (Some(amount), Some(unit)) = (j[\"amount\"].as_str(), j[\"unit\"].as_str()) {\n            return Ok(StatementValueContent::Quantity {\n                amount: amount.to_string(),\n                unit: unit.to_string(),\n            });\n        }\n        if let (Some(language), Some(text)) = (j[\"language\"].as_str(), j[\"text\"].as_str()) {\n            return Ok(StatementValueContent::MonolingualText {\n                language: language.to_string(),\n                text: text.to_string(),\n            });\n        }\n        Err(RestApiError::UnknownValue(format!(\"{j:?}\")))\n    }\n}\n\n#[cfg(not(tarpaulin_include))] // tarpaulin can't handle the Serialize trait\nimpl Serialize for StatementValueContent {\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: Serializer,\n    {\n        match &self {\n            StatementValueContent::String(text) => serialize_text(text, serializer),\n            StatementValueContent::Time {\n                time,\n                precision,\n                calendarmodel,\n            } => serailize_time(serializer, time, precision, calendarmodel),\n            StatementValueContent::Location {\n                latitude,\n                longitude,\n                precision,\n                globe,\n            } => serialize_location(serializer, latitude, longitude, precision, globe),\n            StatementValueContent::Quantity { amount, unit } => {\n                serialize_quantity(serializer, amount, unit)\n            }\n            StatementValueContent::MonolingualText { language, text } => {\n                serialize_monolingual_text(serializer, language, text)\n            }\n        }\n    }\n}\n\nfn serialize_text<S>(\n    text: &String,\n    serializer: S,\n) -> Result<<S as Serializer>::Ok, <S as Serializer>::Error>\nwhere\n    S: Serializer,\n{\n    json!(text).serialize(serializer)\n}\n\nfn serialize_monolingual_text<S>(\n    serializer: S,\n    language: &String,\n    text: &String,\n) -> Result<<S as Serializer>::Ok, <S as Serializer>::Error>\nwhere\n    S: Serializer,\n{\n    let mut s = serializer.serialize_struct(\"StatementValueContent\", 2)?;\n    s.serialize_field(\"language\", language)?;\n    s.serialize_field(\"text\", text)?;\n    s.end()\n}\n\nfn serialize_quantity<S>(\n    serializer: S,\n    amount: &String,\n    unit: &String,\n) -> Result<<S as Serializer>::Ok, <S as Serializer>::Error>\nwhere\n    S: Serializer,\n{\n    let mut s = serializer.serialize_struct(\"StatementValueContent\", 2)?;\n    s.serialize_field(\"amount\", amount)?;\n    s.serialize_field(\"unit\", unit)?;\n    s.end()\n}\n\nfn serialize_location<S>(\n    serializer: S,\n    latitude: &f64,\n    longitude: &f64,\n    precision: &f64,\n    globe: &String,\n) -> Result<<S as Serializer>::Ok, <S as Serializer>::Error>\nwhere\n    S: Serializer,\n{\n    let mut s = serializer.serialize_struct(\"StatementValueContent\", 4)?;\n    s.serialize_field(\"latitude\", latitude)?;\n    s.serialize_field(\"longitude\", longitude)?;\n    s.serialize_field(\"precision\", precision)?;\n    s.serialize_field(\"globe\", globe)?;\n    s.end()\n}\n\nfn serailize_time<S>(\n    serializer: S,\n    time: &String,\n    precision: &TimePrecision,\n    calendarmodel: &String,\n) -> Result<<S as Serializer>::Ok, <S as Serializer>::Error>\nwhere\n    S: Serializer,\n{\n    let precision = *precision as u8;\n    let mut s = serializer.serialize_struct(\"StatementValueContent\", 3)?;\n    s.serialize_field(\"time\", time)?;\n    s.serialize_field(\"precision\", &precision)?;\n    s.serialize_field(\"calendarmodel\", calendarmodel)?;\n    s.end()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_from_u8_conversion() {\n        assert_eq!(\n            TimePrecision::try_from(0_u8),\n            Ok(TimePrecision::BillionYears)\n        );\n        assert_eq!(\n            TimePrecision::try_from(1_u8),\n            Ok(TimePrecision::HundredMillionYears)\n        );\n        assert_eq!(\n            TimePrecision::try_from(2_u8),\n            Ok(TimePrecision::TenMillionYears)\n        );\n        assert_eq!(\n            TimePrecision::try_from(3_u8),\n            Ok(TimePrecision::MillionYears)\n        );\n        assert_eq!(\n            TimePrecision::try_from(4_u8),\n            Ok(TimePrecision::HundredMillennia)\n        );\n        assert_eq!(\n            TimePrecision::try_from(5_u8),\n            Ok(TimePrecision::TenMillennia)\n        );\n        assert_eq!(TimePrecision::try_from(6_u8), Ok(TimePrecision::Millennia));\n        assert_eq!(TimePrecision::try_from(7_u8), Ok(TimePrecision::Century));\n        assert_eq!(TimePrecision::try_from(8_u8), Ok(TimePrecision::Decade));\n        assert_eq!(TimePrecision::try_from(9_u8), Ok(TimePrecision::Year));\n        assert_eq!(TimePrecision::try_from(10_u8), Ok(TimePrecision::Month));\n        assert_eq!(TimePrecision::try_from(11_u8), Ok(TimePrecision::Day));\n        assert_eq!(TimePrecision::try_from(12_u8), Ok(TimePrecision::Hour));\n        assert_eq!(TimePrecision::try_from(13_u8), Ok(TimePrecision::Minute));\n        assert_eq!(TimePrecision::try_from(14_u8), Ok(TimePrecision::Second));\n        assert!(TimePrecision::try_from(15_u8).is_err());\n    }\n\n    #[test]\n    fn test_to_u8_conversion() {\n        assert_eq!(u8::from(TimePrecision::BillionYears), 0);\n        assert_eq!(u8::from(TimePrecision::HundredMillionYears), 1);\n        assert_eq!(u8::from(TimePrecision::TenMillionYears), 2);\n        assert_eq!(u8::from(TimePrecision::MillionYears), 3);\n        assert_eq!(u8::from(TimePrecision::HundredMillennia), 4);\n        assert_eq!(u8::from(TimePrecision::TenMillennia), 5);\n        assert_eq!(u8::from(TimePrecision::Millennia), 6);\n        assert_eq!(u8::from(TimePrecision::Century), 7);\n        assert_eq!(u8::from(TimePrecision::Decade), 8);\n        assert_eq!(u8::from(TimePrecision::Year), 9);\n        assert_eq!(u8::from(TimePrecision::Month), 10);\n        assert_eq!(u8::from(TimePrecision::Day), 11);\n        assert_eq!(u8::from(TimePrecision::Hour), 12);\n        assert_eq!(u8::from(TimePrecision::Minute), 13);\n        assert_eq!(u8::from(TimePrecision::Second), 14);\n    }\n\n    #[test]\n    fn test_from_u64_conversion() {\n        assert_eq!(\n            TimePrecision::try_from(0_u64),\n            Ok(TimePrecision::BillionYears)\n        );\n        assert_eq!(\n            TimePrecision::try_from(1_u64),\n            Ok(TimePrecision::HundredMillionYears)\n        );\n        assert_eq!(\n            TimePrecision::try_from(2_u64),\n            Ok(TimePrecision::TenMillionYears)\n        );\n        assert_eq!(\n            TimePrecision::try_from(3_u64),\n            Ok(TimePrecision::MillionYears)\n        );\n        assert_eq!(\n            TimePrecision::try_from(4_u64),\n            Ok(TimePrecision::HundredMillennia)\n        );\n        assert_eq!(\n            TimePrecision::try_from(5_u64),\n            Ok(TimePrecision::TenMillennia)\n        );\n        assert_eq!(TimePrecision::try_from(6_u64), Ok(TimePrecision::Millennia));\n        assert_eq!(TimePrecision::try_from(7_u64), Ok(TimePrecision::Century));\n        assert_eq!(TimePrecision::try_from(8_u64), Ok(TimePrecision::Decade));\n        assert_eq!(TimePrecision::try_from(9_u64), Ok(TimePrecision::Year));\n        assert_eq!(TimePrecision::try_from(10_u64), Ok(TimePrecision::Month));\n        assert_eq!(TimePrecision::try_from(11_u64), Ok(TimePrecision::Day));\n        assert_eq!(TimePrecision::try_from(12_u64), Ok(TimePrecision::Hour));\n        assert_eq!(TimePrecision::try_from(13_u64), Ok(TimePrecision::Minute));\n        assert_eq!(TimePrecision::try_from(14_u64), Ok(TimePrecision::Second));\n        assert!(TimePrecision::try_from(15_u64).is_err());\n    }\n\n    #[test]\n    fn test_to_u64_conversion() {\n        assert_eq!(u64::from(TimePrecision::BillionYears), 0);\n        assert_eq!(u64::from(TimePrecision::HundredMillionYears), 1);\n        assert_eq!(u64::from(TimePrecision::TenMillionYears), 2);\n        assert_eq!(u64::from(TimePrecision::MillionYears), 3);\n        assert_eq!(u64::from(TimePrecision::HundredMillennia), 4);\n        assert_eq!(u64::from(TimePrecision::TenMillennia), 5);\n        assert_eq!(u64::from(TimePrecision::Millennia), 6);\n        assert_eq!(u64::from(TimePrecision::Century), 7);\n        assert_eq!(u64::from(TimePrecision::Decade), 8);\n        assert_eq!(u64::from(TimePrecision::Year), 9);\n        assert_eq!(u64::from(TimePrecision::Month), 10);\n        assert_eq!(u64::from(TimePrecision::Day), 11);\n        assert_eq!(u64::from(TimePrecision::Hour), 12);\n        assert_eq!(u64::from(TimePrecision::Minute), 13);\n        assert_eq!(u64::from(TimePrecision::Second), 14);\n    }\n}\n","traces":[{"line":34,"address":[],"length":0,"stats":{"Line":1471}},{"line":35,"address":[],"length":0,"stats":{"Line":1471}},{"line":36,"address":[],"length":0,"stats":{"Line":2}},{"line":37,"address":[],"length":0,"stats":{"Line":2}},{"line":38,"address":[],"length":0,"stats":{"Line":2}},{"line":39,"address":[],"length":0,"stats":{"Line":2}},{"line":40,"address":[],"length":0,"stats":{"Line":2}},{"line":41,"address":[],"length":0,"stats":{"Line":2}},{"line":42,"address":[],"length":0,"stats":{"Line":2}},{"line":43,"address":[],"length":0,"stats":{"Line":2}},{"line":44,"address":[],"length":0,"stats":{"Line":2}},{"line":45,"address":[],"length":0,"stats":{"Line":128}},{"line":46,"address":[],"length":0,"stats":{"Line":26}},{"line":47,"address":[],"length":0,"stats":{"Line":1291}},{"line":48,"address":[],"length":0,"stats":{"Line":2}},{"line":49,"address":[],"length":0,"stats":{"Line":2}},{"line":50,"address":[],"length":0,"stats":{"Line":2}},{"line":51,"address":[],"length":0,"stats":{"Line":2}},{"line":57,"address":[],"length":0,"stats":{"Line":30}},{"line":58,"address":[],"length":0,"stats":{"Line":30}},{"line":65,"address":[],"length":0,"stats":{"Line":1455}},{"line":66,"address":[],"length":0,"stats":{"Line":1455}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":1455}},{"line":74,"address":[],"length":0,"stats":{"Line":15}},{"line":75,"address":[],"length":0,"stats":{"Line":15}},{"line":105,"address":[],"length":0,"stats":{"Line":9803}},{"line":107,"address":[],"length":0,"stats":{"Line":17577}},{"line":110,"address":[],"length":0,"stats":{"Line":1439}},{"line":111,"address":[],"length":0,"stats":{"Line":2029}},{"line":112,"address":[],"length":0,"stats":{"Line":2029}},{"line":113,"address":[],"length":0,"stats":{"Line":2029}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":1439}},{"line":123,"address":[],"length":0,"stats":{"Line":9}},{"line":124,"address":[],"length":0,"stats":{"Line":590}},{"line":125,"address":[],"length":0,"stats":{"Line":590}},{"line":126,"address":[],"length":0,"stats":{"Line":590}},{"line":127,"address":[],"length":0,"stats":{"Line":590}},{"line":136,"address":[],"length":0,"stats":{"Line":654}},{"line":142,"address":[],"length":0,"stats":{"Line":1015}},{"line":148,"address":[],"length":0,"stats":{"Line":1}},{"line":181,"address":[],"length":0,"stats":{"Line":2433}},{"line":188,"address":[],"length":0,"stats":{"Line":2433}},{"line":191,"address":[],"length":0,"stats":{"Line":185}},{"line":199,"address":[],"length":0,"stats":{"Line":370}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":185}},{"line":202,"address":[],"length":0,"stats":{"Line":185}},{"line":205,"address":[],"length":0,"stats":{"Line":26}},{"line":213,"address":[],"length":0,"stats":{"Line":52}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":26}},{"line":216,"address":[],"length":0,"stats":{"Line":26}},{"line":219,"address":[],"length":0,"stats":{"Line":5}},{"line":229,"address":[],"length":0,"stats":{"Line":10}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":5}},{"line":232,"address":[],"length":0,"stats":{"Line":5}},{"line":233,"address":[],"length":0,"stats":{"Line":5}},{"line":234,"address":[],"length":0,"stats":{"Line":5}},{"line":237,"address":[],"length":0,"stats":{"Line":467}},{"line":246,"address":[],"length":0,"stats":{"Line":467}},{"line":247,"address":[],"length":0,"stats":{"Line":934}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":467}},{"line":250,"address":[],"length":0,"stats":{"Line":467}},{"line":251,"address":[],"length":0,"stats":{"Line":467}}],"covered":62,"coverable":68},{"path":["/","Users","magnusmanske","rust","wikibase_rest_api","src","statements.rs"],"content":"use crate::{\n    statements_patch::StatementsPatch, EditMetadata, EntityId, FromJson, HeaderInfo, HttpGetEntity,\n    HttpMisc, Patch, RestApi, RestApiError, RevisionMatch, Statement,\n};\nuse async_trait::async_trait;\nuse derivative::Derivative;\nuse serde::ser::{Serialize, SerializeMap};\nuse serde_json::{json, Value};\nuse std::collections::HashMap;\n\n#[derive(Derivative, Debug, Clone, Default)]\n#[derivative(PartialEq)]\npub struct Statements {\n    statements: HashMap<String, Vec<Statement>>, // property => Statements\n    #[derivative(PartialEq = \"ignore\")]\n    header_info: HeaderInfo,\n}\n\nimpl Statements {\n    /// Creates a new `Statements` object from a JSON structure\n    pub fn from_json(j: &Value) -> Result<Self, RestApiError> {\n        Self::from_json_header_info(j, HeaderInfo::default())\n    }\n\n    /// Creates a new `Statements` object from a JSON structure with header info\n    pub fn from_json_header_info(j: &Value, header_info: HeaderInfo) -> Result<Self, RestApiError> {\n        let mut ret = Self::default();\n        let statements_j = j\n            .as_object()\n            .ok_or_else(|| RestApiError::MissingOrInvalidField {\n                field: \"Statements\".into(),\n                j: j.to_owned(),\n            })?;\n        for (property, statements) in statements_j {\n            let statements =\n                statements\n                    .as_array()\n                    .ok_or_else(|| RestApiError::MissingOrInvalidField {\n                        field: property.into(),\n                        j: json!(statements),\n                    })?;\n            let statements = statements\n                .iter()\n                .map(Statement::from_json)\n                .collect::<Result<Vec<Statement>, RestApiError>>()?;\n            ret.statements.insert(property.to_owned(), statements);\n        }\n        ret.header_info = header_info;\n        Ok(ret)\n    }\n\n    /// Returns the number of statements\n    pub fn len(&self) -> usize {\n        self.statements.iter().flat_map(|(_, v)| v).count()\n    }\n\n    /// Returns true if there are no statements\n    pub fn is_empty(&self) -> bool {\n        self.statements.is_empty()\n    }\n\n    /// Returns the Statements for a specific property\n    pub fn property<S: Into<String>>(&self, property: S) -> Vec<&Statement> {\n        self.statements\n            .get(&property.into())\n            .map_or_else(Vec::new, |v| v.iter().collect())\n    }\n\n    pub fn insert(&mut self, statement: Statement) {\n        let property = statement.property().to_owned();\n        self.statements\n            .entry(property.id().to_owned())\n            .or_default()\n            .push(statement);\n    }\n\n    pub const fn statements(&self) -> &HashMap<String, Vec<Statement>> {\n        &self.statements\n    }\n\n    pub const fn statements_mut(&mut self) -> &mut HashMap<String, Vec<Statement>> {\n        &mut self.statements\n    }\n\n    pub const fn header_info(&self) -> &HeaderInfo {\n        &self.header_info\n    }\n\n    // Returns a list of all statements with an ID, as HashMap ID => &Statement\n    fn get_id_statement_map(&self) -> HashMap<&str, &Statement> {\n        self.statements\n            .values()\n            .flat_map(|v| v.iter())\n            .filter_map(|statement| Some((statement.id()?.as_str(), statement)))\n            .collect()\n    }\n\n    // Returns a list of all statements without IDs\n    fn get_statements_without_id(&self) -> Vec<&Statement> {\n        self.statements\n            .values()\n            .flat_map(|v| v.iter())\n            .filter(|statement| statement.id().is_none())\n            .collect()\n    }\n\n    pub fn patch(&self, other: &Self) -> Result<StatementsPatch, RestApiError> {\n        // Statements without ID in other => fail\n        if !other.get_statements_without_id().is_empty() {\n            return Err(RestApiError::MissingId);\n        }\n\n        let mut patch = StatementsPatch::default();\n        let from_statements_with_id = self.get_id_statement_map();\n        let to_statements_with_id = other.get_id_statement_map();\n\n        Self::patch_modify_remove(&mut patch, &from_statements_with_id, &to_statements_with_id)?;\n        Self::patch_add_new(&mut patch, from_statements_with_id, to_statements_with_id);\n\n        Ok(patch)\n    }\n\n    fn patch_modify_remove(\n        patch: &mut StatementsPatch,\n        from_statements_with_id: &HashMap<&str, &Statement>,\n        to_statements_with_id: &HashMap<&str, &Statement>,\n    ) -> Result<(), RestApiError> {\n        for (statement_id, from_statement) in from_statements_with_id {\n            match to_statements_with_id.get(statement_id) {\n                Some(to_statement) => {\n                    // Modify statement\n                    let statement_patch = from_statement.patch(to_statement)?;\n                    patch.patch_mut().extend(statement_patch.patch().to_owned());\n                }\n                None => {\n                    // Remove statement\n                    let statement_path = format!(\"/statements/{statement_id}\"); // TODO check\n                    patch.remove(statement_path);\n                }\n            }\n        }\n        Ok(())\n    }\n\n    fn patch_add_new(\n        patch: &mut StatementsPatch,\n        from_statements_with_id: HashMap<&str, &Statement>,\n        to_statements_with_id: HashMap<&str, &Statement>,\n    ) {\n        // Add new statements\n        for (statement_id, to_statement) in &to_statements_with_id {\n            if !from_statements_with_id.contains_key(statement_id) {\n                // Add new statement\n                let add_path = format!(\"/statements/{statement_id}\"); // TODO check\n                let value = json!(to_statement);\n                patch.add(add_path, value);\n            }\n        }\n    }\n}\n\n// GET\n#[async_trait]\nimpl HttpGetEntity for Statements {\n    async fn get_match(\n        id: &EntityId,\n        api: &RestApi,\n        rm: RevisionMatch,\n    ) -> Result<Self, RestApiError> {\n        let path = Self::get_rest_api_path(id)?;\n        let (j, header_info) = Self::get_match_internal(api, &path, rm).await?;\n        Self::from_json_header_info(&j, header_info)\n    }\n}\n\n// POST\nimpl Statements {\n    /// Posts a new statement to an entity\n    pub async fn post(\n        &self,\n        id: &EntityId,\n        statement: Statement,\n        api: &mut RestApi,\n    ) -> Result<Statement, RestApiError> {\n        self.post_meta(id, statement, api, EditMetadata::default())\n            .await\n    }\n\n    /// Posts a new statement to an entity with metadata\n    pub async fn post_meta(\n        &self,\n        id: &EntityId,\n        mut statement: Statement,\n        api: &mut RestApi,\n        em: EditMetadata,\n    ) -> Result<Statement, RestApiError> {\n        statement.set_id(None);\n        let j0 = json!({\"statement\": statement});\n        let request = self\n            .generate_json_request(id, reqwest::Method::POST, j0, api, &em)\n            .await?;\n        let response = api.execute(request).await?;\n        let (j, _statement_id) = self.filter_response_error(response).await?;\n        // TODO add to self.statements?\n        Statement::from_json(&j)\n    }\n}\n\nimpl HttpMisc for Statements {\n    fn get_rest_api_path(id: &EntityId) -> Result<String, RestApiError> {\n        Ok(format!(\n            \"/entities/{group}/{id}/statements\",\n            group = id.group()?\n        ))\n    }\n}\n\nimpl Serialize for Statements {\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: serde::Serializer,\n    {\n        let mut s = serializer.serialize_map(Some(self.statements.len()))?;\n        for (property, statements) in &self.statements {\n            s.serialize_entry(property, statements)?;\n        }\n        s.end()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::statement_value::StatementValue;\n    use http::{HeaderMap, HeaderValue};\n    use wiremock::matchers::{bearer_token, body_partial_json, method, path};\n    use wiremock::{Mock, MockServer, ResponseTemplate};\n\n    use super::*;\n\n    #[tokio::test]\n    #[cfg_attr(miri, ignore)]\n    async fn test_statements_get() {\n        let v = std::fs::read_to_string(\"test_data/Q42.json\").unwrap();\n        let v: Value = serde_json::from_str(&v).unwrap();\n\n        let mock_path = \"/w/rest.php/wikibase/v1/entities/items/Q42/statements\";\n        let mock_server = MockServer::start().await;\n        Mock::given(method(\"GET\"))\n            .and(path(mock_path))\n            .respond_with(ResponseTemplate::new(200).set_body_json(&v[\"statements\"]))\n            .mount(&mock_server)\n            .await;\n        let api = RestApi::builder(&(mock_server.uri() + \"/w/rest.php\"))\n            .unwrap()\n            .build();\n\n        let statements = Statements::get(&EntityId::item(\"Q42\"), &api).await.unwrap();\n        assert!(!statements.property(\"P31\").is_empty());\n    }\n\n    #[tokio::test]\n    #[cfg_attr(miri, ignore)]\n    async fn test_statements_post() {\n        // #lizard forgives the complexity\n        let id = EntityId::item(\"Q42\");\n        let v = std::fs::read_to_string(\"test_data/test_statements_post.json\").unwrap();\n        let v: Value = serde_json::from_str(&v).unwrap();\n        let mock_path = \"/w/rest.php/wikibase/v1/entities/items/Q42/statements\";\n        let mock_server = MockServer::start().await;\n        let token = \"FAKE_TOKEN\";\n        Mock::given(method(\"GET\"))\n            .and(path(mock_path))\n            .respond_with(\n                ResponseTemplate::new(200)\n                    .set_body_json(json!({}))\n                    .insert_header(\"ETag\", \"123\"),\n            )\n            .mount(&mock_server)\n            .await;\n        Mock::given(body_partial_json(\n            json!({\"statement\": {\"value\":{\"content\":\"Q5\"}}}),\n        ))\n        .and(method(\"POST\"))\n        .and(path(mock_path))\n        .and(bearer_token(token))\n        .respond_with(ResponseTemplate::new(200).set_body_json(&v))\n        .mount(&mock_server)\n        .await;\n        let mut api = RestApi::builder(&(mock_server.uri() + \"/w/rest.php\"))\n            .unwrap()\n            .with_access_token(token)\n            .build();\n\n        // Get and check existing statements\n        let statements = Statements::get(&id, &api).await.unwrap();\n        assert!(statements.property(\"P31\").is_empty());\n\n        // Create new statement\n        let mut statement = Statement::default();\n        statement.set_property(\"P31\".into());\n        statement.set_value(StatementValue::new_string(\"Q5\"));\n\n        // POST new statement\n        let statement = statements.post(&id, statement, &mut api).await.unwrap();\n        assert_eq!(statement.value(), &StatementValue::new_string(\"Q5\"));\n    }\n\n    #[tokio::test]\n    #[cfg_attr(miri, ignore)]\n    async fn test_eq() {\n        // To ensure that statement lists with and without header info are equal\n        let id = EntityId::item(\"Q42\");\n        let mock_path = \"/w/rest.php/wikibase/v1/entities/items/Q42/statements\";\n        let mock_server = MockServer::start().await;\n        let token = \"FAKE_TOKEN\";\n        Mock::given(method(\"GET\"))\n            .and(path(mock_path))\n            .respond_with(\n                ResponseTemplate::new(200)\n                    .set_body_json(json!({}))\n                    .insert_header(\"ETag\", \"123\"),\n            )\n            .mount(&mock_server)\n            .await;\n        let api = RestApi::builder(&(mock_server.uri() + \"/w/rest.php\"))\n            .unwrap()\n            .with_access_token(token)\n            .build();\n\n        // Get empty statements but with revision ID\n        let statements1 = Statements::get(&id, &api).await.unwrap();\n        let statements2 = Statements::default();\n        assert_eq!(statements1, statements2);\n    }\n\n    #[test]\n    fn test_insert_and_len() {\n        let mut statements = Statements::default();\n        assert_eq!(statements.len(), 0);\n        let mut statement = Statement::default();\n        statement.set_property(\"P31\".into());\n        statements.insert(statement.clone());\n        statements.insert(statement.clone());\n        statement.set_property(\"P1\".into());\n        statements.insert(statement.clone());\n        assert_eq!(statements.len(), 3);\n    }\n\n    #[test]\n    fn test_statements_statements() {\n        let mut statements = Statements::default();\n        let mut statement = Statement::default();\n        statement.set_property(\"P31\".into());\n        statements.insert(statement.clone());\n        statement.set_property(\"P1\".into());\n        statements.insert(statement.clone());\n        assert_eq!(statements.statements().len(), 2);\n        statements.statements_mut().remove(\"P31\");\n        assert_eq!(statements.statements().len(), 1);\n    }\n\n    #[test]\n    fn test_header_info() {\n        let mut headers = HeaderMap::new();\n        headers.insert(\"ETag\", HeaderValue::from_str(\"1234567890\").unwrap());\n        headers.insert(\n            \"Last-Modified\",\n            HeaderValue::from_str(\"Wed, 21 Oct 2015 07:28:00 GMT\").unwrap(),\n        );\n        let hi = HeaderInfo::from_header(&headers);\n        let mut statements = Statements::default();\n        assert_eq!(statements.header_info(), &HeaderInfo::default());\n        statements.header_info = hi.to_owned();\n        assert_eq!(statements.header_info(), &hi);\n    }\n\n    #[test]\n    fn test_get_id_statement_map() {\n        let mut statements = Statements::default();\n        let mut statement = Statement::default();\n        statement.set_id(Some(\"Q1\".into()));\n        statement.set_property(\"P31\".into());\n        statements.insert(statement.clone());\n        statement.set_id(Some(\"Q2\".into()));\n        statement.set_property(\"P1\".into());\n        statements.insert(statement.clone());\n        let id_statement_map = statements.get_id_statement_map();\n        assert_eq!(id_statement_map.len(), 2);\n        assert_eq!(id_statement_map.get(\"Q1\").unwrap().property().id(), \"P31\");\n        assert_eq!(id_statement_map.get(\"Q2\").unwrap().property().id(), \"P1\");\n    }\n\n    #[test]\n    fn test_get_statements_without_id() {\n        let mut statements = Statements::default();\n        let mut statement = Statement::default();\n        statement.set_id(Some(\"Q1\".into()));\n        statement.set_property(\"P31\".into());\n        statements.insert(statement.clone());\n        statement.set_id(None);\n        statement.set_property(\"P1\".into());\n        statements.insert(statement.clone());\n        let statements_without_id = statements.get_statements_without_id();\n        assert_eq!(statements_without_id.len(), 1);\n        assert_eq!(statements_without_id[0].property().id(), \"P1\");\n    }\n\n    #[test]\n    fn test_patch() {\n        let mut statements1 = Statements::default();\n        let mut statement = Statement::default();\n        statement.set_id(Some(\"Q1\".into()));\n        statement.set_property(\"P31\".into());\n        statements1.insert(statement.clone());\n        statement.set_id(Some(\"Q2\".into()));\n        statement.set_property(\"P1\".into());\n        statements1.insert(statement.clone());\n\n        let mut statements2 = Statements::default();\n        statement.set_id(Some(\"Q1\".into()));\n        statement.set_property(\"P31\".into());\n        statements2.insert(statement.clone());\n        statement.set_id(Some(\"Q3\".into()));\n        statement.set_property(\"P1\".into());\n        statements2.insert(statement.clone());\n\n        let patch = statements1.patch(&statements2).unwrap();\n        assert_eq!(patch.patch().len(), 2);\n        assert_eq!(patch.patch()[0].op(), \"remove\");\n        assert_eq!(patch.patch()[1].op(), \"add\");\n    }\n}\n","traces":[{"line":21,"address":[],"length":0,"stats":{"Line":15}},{"line":22,"address":[],"length":0,"stats":{"Line":15}},{"line":26,"address":[],"length":0,"stats":{"Line":18}},{"line":27,"address":[],"length":0,"stats":{"Line":18}},{"line":28,"address":[],"length":0,"stats":{"Line":36}},{"line":30,"address":[],"length":0,"stats":{"Line":18}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":6134}},{"line":35,"address":[],"length":0,"stats":{"Line":3058}},{"line":36,"address":[],"length":0,"stats":{"Line":3058}},{"line":38,"address":[],"length":0,"stats":{"Line":3058}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":3058}},{"line":48,"address":[],"length":0,"stats":{"Line":18}},{"line":49,"address":[],"length":0,"stats":{"Line":18}},{"line":53,"address":[],"length":0,"stats":{"Line":6}},{"line":54,"address":[],"length":0,"stats":{"Line":16}},{"line":58,"address":[],"length":0,"stats":{"Line":17}},{"line":59,"address":[],"length":0,"stats":{"Line":17}},{"line":63,"address":[],"length":0,"stats":{"Line":4}},{"line":64,"address":[],"length":0,"stats":{"Line":4}},{"line":65,"address":[],"length":0,"stats":{"Line":4}},{"line":66,"address":[],"length":0,"stats":{"Line":11}},{"line":69,"address":[],"length":0,"stats":{"Line":15}},{"line":70,"address":[],"length":0,"stats":{"Line":15}},{"line":71,"address":[],"length":0,"stats":{"Line":15}},{"line":72,"address":[],"length":0,"stats":{"Line":15}},{"line":74,"address":[],"length":0,"stats":{"Line":15}},{"line":77,"address":[],"length":0,"stats":{"Line":2}},{"line":78,"address":[],"length":0,"stats":{"Line":2}},{"line":81,"address":[],"length":0,"stats":{"Line":1}},{"line":82,"address":[],"length":0,"stats":{"Line":1}},{"line":85,"address":[],"length":0,"stats":{"Line":2}},{"line":86,"address":[],"length":0,"stats":{"Line":2}},{"line":90,"address":[],"length":0,"stats":{"Line":5}},{"line":91,"address":[],"length":0,"stats":{"Line":5}},{"line":93,"address":[],"length":0,"stats":{"Line":16}},{"line":94,"address":[],"length":0,"stats":{"Line":22}},{"line":99,"address":[],"length":0,"stats":{"Line":3}},{"line":100,"address":[],"length":0,"stats":{"Line":3}},{"line":102,"address":[],"length":0,"stats":{"Line":10}},{"line":103,"address":[],"length":0,"stats":{"Line":10}},{"line":107,"address":[],"length":0,"stats":{"Line":2}},{"line":109,"address":[],"length":0,"stats":{"Line":2}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":2}},{"line":114,"address":[],"length":0,"stats":{"Line":2}},{"line":115,"address":[],"length":0,"stats":{"Line":2}},{"line":117,"address":[],"length":0,"stats":{"Line":2}},{"line":118,"address":[],"length":0,"stats":{"Line":2}},{"line":120,"address":[],"length":0,"stats":{"Line":2}},{"line":123,"address":[],"length":0,"stats":{"Line":2}},{"line":128,"address":[],"length":0,"stats":{"Line":6}},{"line":129,"address":[],"length":0,"stats":{"Line":2}},{"line":130,"address":[],"length":0,"stats":{"Line":1}},{"line":132,"address":[],"length":0,"stats":{"Line":2}},{"line":135,"address":[],"length":0,"stats":{"Line":1}},{"line":137,"address":[],"length":0,"stats":{"Line":1}},{"line":138,"address":[],"length":0,"stats":{"Line":1}},{"line":142,"address":[],"length":0,"stats":{"Line":2}},{"line":145,"address":[],"length":0,"stats":{"Line":2}},{"line":151,"address":[],"length":0,"stats":{"Line":6}},{"line":152,"address":[],"length":0,"stats":{"Line":1}},{"line":154,"address":[],"length":0,"stats":{"Line":1}},{"line":155,"address":[],"length":0,"stats":{"Line":1}},{"line":156,"address":[],"length":0,"stats":{"Line":1}},{"line":170,"address":[],"length":0,"stats":{"Line":6}},{"line":171,"address":[],"length":0,"stats":{"Line":3}},{"line":179,"address":[],"length":0,"stats":{"Line":1}},{"line":185,"address":[],"length":0,"stats":{"Line":1}},{"line":186,"address":[],"length":0,"stats":{"Line":1}},{"line":190,"address":[],"length":0,"stats":{"Line":1}},{"line":197,"address":[],"length":0,"stats":{"Line":1}},{"line":198,"address":[],"length":0,"stats":{"Line":1}},{"line":199,"address":[],"length":0,"stats":{"Line":2}},{"line":200,"address":[],"length":0,"stats":{"Line":1}},{"line":201,"address":[],"length":0,"stats":{"Line":1}},{"line":202,"address":[],"length":0,"stats":{"Line":1}},{"line":203,"address":[],"length":0,"stats":{"Line":1}},{"line":210,"address":[],"length":0,"stats":{"Line":4}},{"line":211,"address":[],"length":0,"stats":{"Line":4}},{"line":212,"address":[],"length":0,"stats":{"Line":4}},{"line":213,"address":[],"length":0,"stats":{"Line":4}},{"line":219,"address":[],"length":0,"stats":{"Line":6}},{"line":223,"address":[],"length":0,"stats":{"Line":12}},{"line":224,"address":[],"length":0,"stats":{"Line":1824}},{"line":225,"address":[],"length":0,"stats":{"Line":909}},{"line":227,"address":[],"length":0,"stats":{"Line":6}}],"covered":85,"coverable":90},{"path":["/","Users","magnusmanske","rust","wikibase_rest_api","src","statements_patch.rs"],"content":"use crate::{patch_entry::PatchEntry, Patch};\nuse serde::Serialize;\n\n#[derive(Debug, Clone, Default, PartialEq, Serialize)]\npub struct StatementsPatch {\n    patch: Vec<PatchEntry>,\n}\n\nimpl Patch for StatementsPatch {\n    fn patch(&self) -> &Vec<PatchEntry> {\n        &self.patch\n    }\n\n    fn patch_mut(&mut self) -> &mut Vec<PatchEntry> {\n        &mut self.patch\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use serde_json::json;\n\n    #[test]\n    fn test_statements_patch() {\n        let mut patch = StatementsPatch::default();\n        patch.add(\"/foo/bar\", json!(\"baz\"));\n        assert_eq!(patch.patch().len(), 1);\n        let expected = PatchEntry::new(\"add\", \"/foo/bar\", json!(\"baz\"));\n        assert_eq!(patch.patch()[0], expected);\n\n        patch.patch_mut().remove(0);\n        assert_eq!(patch.patch().len(), 0);\n    }\n}\n","traces":[{"line":10,"address":[],"length":0,"stats":{"Line":7}},{"line":11,"address":[],"length":0,"stats":{"Line":7}},{"line":14,"address":[],"length":0,"stats":{"Line":5}},{"line":15,"address":[],"length":0,"stats":{"Line":5}}],"covered":4,"coverable":4}],"coverage":88.4971098265896,"covered":1531,"coverable":1730}